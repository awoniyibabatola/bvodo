/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/leaflet";
exports.ids = ["vendor-chunks/leaflet"];
exports.modules = {

/***/ "(ssr)/./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/* @preserve\n * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com\n * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */ (function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    var version = \"1.9.4\";\n    /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */ // @function extend(dest: Object, src?: Object): Object\n    // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\n    function extend(dest) {\n        var i, j, len, src;\n        for(j = 1, len = arguments.length; j < len; j++){\n            src = arguments[j];\n            for(i in src){\n                dest[i] = src[i];\n            }\n        }\n        return dest;\n    }\n    // @function create(proto: Object, properties?: Object): Object\n    // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n    var create$2 = Object.create || function() {\n        function F() {}\n        return function(proto) {\n            F.prototype = proto;\n            return new F();\n        };\n    }();\n    // @function bind(fn: Function, …): Function\n    // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n    // Has a `L.bind()` shortcut.\n    function bind(fn, obj) {\n        var slice = Array.prototype.slice;\n        if (fn.bind) {\n            return fn.bind.apply(fn, slice.call(arguments, 1));\n        }\n        var args = slice.call(arguments, 2);\n        return function() {\n            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n        };\n    }\n    // @property lastId: Number\n    // Last unique ID used by [`stamp()`](#util-stamp)\n    var lastId = 0;\n    // @function stamp(obj: Object): Number\n    // Returns the unique ID of an object, assigning it one if it doesn't have it.\n    function stamp(obj) {\n        if (!(\"_leaflet_id\" in obj)) {\n            obj[\"_leaflet_id\"] = ++lastId;\n        }\n        return obj._leaflet_id;\n    }\n    // @function throttle(fn: Function, time: Number, context: Object): Function\n    // Returns a function which executes function `fn` with the given scope `context`\n    // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\n    // `fn` will be called no more than one time per given amount of `time`. The arguments\n    // received by the bound function will be any arguments passed when binding the\n    // function, followed by any arguments passed when invoking the bound function.\n    // Has an `L.throttle` shortcut.\n    function throttle(fn, time, context) {\n        var lock, args, wrapperFn, later;\n        later = function() {\n            // reset lock and call if queued\n            lock = false;\n            if (args) {\n                wrapperFn.apply(context, args);\n                args = false;\n            }\n        };\n        wrapperFn = function() {\n            if (lock) {\n                // called too soon, queue to call later\n                args = arguments;\n            } else {\n                // call and lock until later\n                fn.apply(context, arguments);\n                setTimeout(later, time);\n                lock = true;\n            }\n        };\n        return wrapperFn;\n    }\n    // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\n    // Returns the number `num` modulo `range` in such a way so it lies within\n    // `range[0]` and `range[1]`. The returned value will be always smaller than\n    // `range[1]` unless `includeMax` is set to `true`.\n    function wrapNum(x, range, includeMax) {\n        var max = range[1], min = range[0], d = max - min;\n        return x === max && includeMax ? x : ((x - min) % d + d) % d + min;\n    }\n    // @function falseFn(): Function\n    // Returns a function which always returns `false`.\n    function falseFn() {\n        return false;\n    }\n    // @function formatNum(num: Number, precision?: Number|false): Number\n    // Returns the number `num` rounded with specified `precision`.\n    // The default `precision` value is 6 decimal places.\n    // `false` can be passed to skip any processing (can be useful to avoid round-off errors).\n    function formatNum(num, precision) {\n        if (precision === false) {\n            return num;\n        }\n        var pow = Math.pow(10, precision === undefined ? 6 : precision);\n        return Math.round(num * pow) / pow;\n    }\n    // @function trim(str: String): String\n    // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\n    function trim(str) {\n        return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, \"\");\n    }\n    // @function splitWords(str: String): String[]\n    // Trims and splits the string on whitespace and returns the array of parts.\n    function splitWords(str) {\n        return trim(str).split(/\\s+/);\n    }\n    // @function setOptions(obj: Object, options: Object): Object\n    // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\n    function setOptions(obj, options) {\n        if (!Object.prototype.hasOwnProperty.call(obj, \"options\")) {\n            obj.options = obj.options ? create$2(obj.options) : {};\n        }\n        for(var i in options){\n            obj.options[i] = options[i];\n        }\n        return obj.options;\n    }\n    // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\n    // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\n    // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\n    // be appended at the end. If `uppercase` is `true`, the parameter names will\n    // be uppercased (e.g. `'?A=foo&B=bar'`)\n    function getParamString(obj, existingUrl, uppercase) {\n        var params = [];\n        for(var i in obj){\n            params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + \"=\" + encodeURIComponent(obj[i]));\n        }\n        return (!existingUrl || existingUrl.indexOf(\"?\") === -1 ? \"?\" : \"&\") + params.join(\"&\");\n    }\n    var templateRe = /\\{ *([\\w_ -]+) *\\}/g;\n    // @function template(str: String, data: Object): String\n    // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n    // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n    // `('Hello foo, bar')`. You can also specify functions instead of strings for\n    // data values — they will be evaluated passing `data` as an argument.\n    function template(str, data) {\n        return str.replace(templateRe, function(str, key) {\n            var value = data[key];\n            if (value === undefined) {\n                throw new Error(\"No value provided for variable \" + str);\n            } else if (typeof value === \"function\") {\n                value = value(data);\n            }\n            return value;\n        });\n    }\n    // @function isArray(obj): Boolean\n    // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\n    var isArray = Array.isArray || function(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Array]\";\n    };\n    // @function indexOf(array: Array, el: Object): Number\n    // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n    function indexOf(array, el) {\n        for(var i = 0; i < array.length; i++){\n            if (array[i] === el) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    // @property emptyImageUrl: String\n    // Data URI string containing a base64-encoded empty GIF image.\n    // Used as a hack to free memory from unused images on WebKit-powered\n    // mobile devices (by setting image `src` to this string).\n    var emptyImageUrl = \"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=\";\n    // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/\n    function getPrefixed(name) {\n        return window[\"webkit\" + name] || window[\"moz\" + name] || window[\"ms\" + name];\n    }\n    var lastTime = 0;\n    // fallback for IE 7-8\n    function timeoutDefer(fn) {\n        var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));\n        lastTime = time + timeToCall;\n        return window.setTimeout(fn, timeToCall);\n    }\n    var requestFn = window.requestAnimationFrame || getPrefixed(\"RequestAnimationFrame\") || timeoutDefer;\n    var cancelFn = window.cancelAnimationFrame || getPrefixed(\"CancelAnimationFrame\") || getPrefixed(\"CancelRequestAnimationFrame\") || function(id) {\n        window.clearTimeout(id);\n    };\n    // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\n    // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\n    // `context` if given. When `immediate` is set, `fn` is called immediately if\n    // the browser doesn't have native support for\n    // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\n    // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\n    function requestAnimFrame(fn, context, immediate) {\n        if (immediate && requestFn === timeoutDefer) {\n            fn.call(context);\n        } else {\n            return requestFn.call(window, bind(fn, context));\n        }\n    }\n    // @function cancelAnimFrame(id: Number): undefined\n    // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\n    function cancelAnimFrame(id) {\n        if (id) {\n            cancelFn.call(window, id);\n        }\n    }\n    var Util = {\n        __proto__: null,\n        extend: extend,\n        create: create$2,\n        bind: bind,\n        get lastId () {\n            return lastId;\n        },\n        stamp: stamp,\n        throttle: throttle,\n        wrapNum: wrapNum,\n        falseFn: falseFn,\n        formatNum: formatNum,\n        trim: trim,\n        splitWords: splitWords,\n        setOptions: setOptions,\n        getParamString: getParamString,\n        template: template,\n        isArray: isArray,\n        indexOf: indexOf,\n        emptyImageUrl: emptyImageUrl,\n        requestFn: requestFn,\n        cancelFn: cancelFn,\n        requestAnimFrame: requestAnimFrame,\n        cancelAnimFrame: cancelAnimFrame\n    };\n    // @class Class\n    // @aka L.Class\n    // @section\n    // @uninheritable\n    // Thanks to John Resig and Dean Edwards for inspiration!\n    function Class() {}\n    Class.extend = function(props) {\n        // @function extend(props: Object): Function\n        // [Extends the current class](#class-inheritance) given the properties to be included.\n        // Returns a Javascript function that is a class constructor (to be called with `new`).\n        var NewClass = function() {\n            setOptions(this);\n            // call the constructor\n            if (this.initialize) {\n                this.initialize.apply(this, arguments);\n            }\n            // call all constructor hooks\n            this.callInitHooks();\n        };\n        var parentProto = NewClass.__super__ = this.prototype;\n        var proto = create$2(parentProto);\n        proto.constructor = NewClass;\n        NewClass.prototype = proto;\n        // inherit parent's statics\n        for(var i in this){\n            if (Object.prototype.hasOwnProperty.call(this, i) && i !== \"prototype\" && i !== \"__super__\") {\n                NewClass[i] = this[i];\n            }\n        }\n        // mix static properties into the class\n        if (props.statics) {\n            extend(NewClass, props.statics);\n        }\n        // mix includes into the prototype\n        if (props.includes) {\n            checkDeprecatedMixinEvents(props.includes);\n            extend.apply(null, [\n                proto\n            ].concat(props.includes));\n        }\n        // mix given properties into the prototype\n        extend(proto, props);\n        delete proto.statics;\n        delete proto.includes;\n        // merge options\n        if (proto.options) {\n            proto.options = parentProto.options ? create$2(parentProto.options) : {};\n            extend(proto.options, props.options);\n        }\n        proto._initHooks = [];\n        // add method for calling all hooks\n        proto.callInitHooks = function() {\n            if (this._initHooksCalled) {\n                return;\n            }\n            if (parentProto.callInitHooks) {\n                parentProto.callInitHooks.call(this);\n            }\n            this._initHooksCalled = true;\n            for(var i = 0, len = proto._initHooks.length; i < len; i++){\n                proto._initHooks[i].call(this);\n            }\n        };\n        return NewClass;\n    };\n    // @function include(properties: Object): this\n    // [Includes a mixin](#class-includes) into the current class.\n    Class.include = function(props) {\n        var parentOptions = this.prototype.options;\n        extend(this.prototype, props);\n        if (props.options) {\n            this.prototype.options = parentOptions;\n            this.mergeOptions(props.options);\n        }\n        return this;\n    };\n    // @function mergeOptions(options: Object): this\n    // [Merges `options`](#class-options) into the defaults of the class.\n    Class.mergeOptions = function(options) {\n        extend(this.prototype.options, options);\n        return this;\n    };\n    // @function addInitHook(fn: Function): this\n    // Adds a [constructor hook](#class-constructor-hooks) to the class.\n    Class.addInitHook = function(fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        var init = typeof fn === \"function\" ? fn : function() {\n            this[fn].apply(this, args);\n        };\n        this.prototype._initHooks = this.prototype._initHooks || [];\n        this.prototype._initHooks.push(init);\n        return this;\n    };\n    function checkDeprecatedMixinEvents(includes) {\n        /* global L: true */ if (typeof L === \"undefined\" || !L || !L.Mixin) {\n            return;\n        }\n        includes = isArray(includes) ? includes : [\n            includes\n        ];\n        for(var i = 0; i < includes.length; i++){\n            if (includes[i] === L.Mixin.Events) {\n                console.warn(\"Deprecated include of L.Mixin.Events: \" + \"this property will be removed in future releases, \" + \"please inherit from L.Evented instead.\", new Error().stack);\n            }\n        }\n    }\n    /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */ var Events = {\n        /* @method on(type: String, fn: Function, context?: Object): this\r\n  \t * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method on(eventMap: Object): this\r\n  \t * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n  \t */ on: function(types, fn, context) {\n            // types can be a map of types/handlers\n            if (typeof types === \"object\") {\n                for(var type in types){\n                    // we don't process space-separated events here for performance;\n                    // it's a hot path since Layer uses the on(obj) syntax\n                    this._on(type, types[type], fn);\n                }\n            } else {\n                // types can be a string of space-separated words\n                types = splitWords(types);\n                for(var i = 0, len = types.length; i < len; i++){\n                    this._on(types[i], fn, context);\n                }\n            }\n            return this;\n        },\n        /* @method off(type: String, fn?: Function, context?: Object): this\r\n  \t * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method off(eventMap: Object): this\r\n  \t * Removes a set of type/listener pairs.\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method off: this\r\n  \t * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n  \t */ off: function(types, fn, context) {\n            if (!arguments.length) {\n                // clear all listeners if called without arguments\n                delete this._events;\n            } else if (typeof types === \"object\") {\n                for(var type in types){\n                    this._off(type, types[type], fn);\n                }\n            } else {\n                types = splitWords(types);\n                var removeAll = arguments.length === 1;\n                for(var i = 0, len = types.length; i < len; i++){\n                    if (removeAll) {\n                        this._off(types[i]);\n                    } else {\n                        this._off(types[i], fn, context);\n                    }\n                }\n            }\n            return this;\n        },\n        // attach listener (without syntactic sugar now)\n        _on: function(type, fn, context, _once) {\n            if (typeof fn !== \"function\") {\n                console.warn(\"wrong listener type: \" + typeof fn);\n                return;\n            }\n            // check if fn already there\n            if (this._listens(type, fn, context) !== false) {\n                return;\n            }\n            if (context === this) {\n                // Less memory footprint.\n                context = undefined;\n            }\n            var newListener = {\n                fn: fn,\n                ctx: context\n            };\n            if (_once) {\n                newListener.once = true;\n            }\n            this._events = this._events || {};\n            this._events[type] = this._events[type] || [];\n            this._events[type].push(newListener);\n        },\n        _off: function(type, fn, context) {\n            var listeners, i, len;\n            if (!this._events) {\n                return;\n            }\n            listeners = this._events[type];\n            if (!listeners) {\n                return;\n            }\n            if (arguments.length === 1) {\n                if (this._firingCount) {\n                    // Set all removed listeners to noop\n                    // so they are not called if remove happens in fire\n                    for(i = 0, len = listeners.length; i < len; i++){\n                        listeners[i].fn = falseFn;\n                    }\n                }\n                // clear all listeners for a type if function isn't specified\n                delete this._events[type];\n                return;\n            }\n            if (typeof fn !== \"function\") {\n                console.warn(\"wrong listener type: \" + typeof fn);\n                return;\n            }\n            // find fn and remove it\n            var index = this._listens(type, fn, context);\n            if (index !== false) {\n                var listener = listeners[index];\n                if (this._firingCount) {\n                    // set the removed listener to noop so that's not called if remove happens in fire\n                    listener.fn = falseFn;\n                    /* copy array in case events are being fired */ this._events[type] = listeners = listeners.slice();\n                }\n                listeners.splice(index, 1);\n            }\n        },\n        // @method fire(type: String, data?: Object, propagate?: Boolean): this\n        // Fires an event of the specified type. You can optionally provide a data\n        // object — the first argument of the listener function will contain its\n        // properties. The event can optionally be propagated to event parents.\n        fire: function(type, data, propagate) {\n            if (!this.listens(type, propagate)) {\n                return this;\n            }\n            var event = extend({}, data, {\n                type: type,\n                target: this,\n                sourceTarget: data && data.sourceTarget || this\n            });\n            if (this._events) {\n                var listeners = this._events[type];\n                if (listeners) {\n                    this._firingCount = this._firingCount + 1 || 1;\n                    for(var i = 0, len = listeners.length; i < len; i++){\n                        var l = listeners[i];\n                        // off overwrites l.fn, so we need to copy fn to a var\n                        var fn = l.fn;\n                        if (l.once) {\n                            this.off(type, fn, l.ctx);\n                        }\n                        fn.call(l.ctx || this, event);\n                    }\n                    this._firingCount--;\n                }\n            }\n            if (propagate) {\n                // propagate the event to parents (set with addEventParent)\n                this._propagateEvent(event);\n            }\n            return this;\n        },\n        // @method listens(type: String, propagate?: Boolean): Boolean\n        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean\n        // Returns `true` if a particular event type has any listeners attached to it.\n        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\n        listens: function(type, fn, context, propagate) {\n            if (typeof type !== \"string\") {\n                console.warn('\"string\" type argument expected');\n            }\n            // we don't overwrite the input `fn` value, because we need to use it for propagation\n            var _fn = fn;\n            if (typeof fn !== \"function\") {\n                propagate = !!fn;\n                _fn = undefined;\n                context = undefined;\n            }\n            var listeners = this._events && this._events[type];\n            if (listeners && listeners.length) {\n                if (this._listens(type, _fn, context) !== false) {\n                    return true;\n                }\n            }\n            if (propagate) {\n                // also check parents for listeners if event propagates\n                for(var id in this._eventParents){\n                    if (this._eventParents[id].listens(type, fn, context, propagate)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        // returns the index (number) or false\n        _listens: function(type, fn, context) {\n            if (!this._events) {\n                return false;\n            }\n            var listeners = this._events[type] || [];\n            if (!fn) {\n                return !!listeners.length;\n            }\n            if (context === this) {\n                // Less memory footprint.\n                context = undefined;\n            }\n            for(var i = 0, len = listeners.length; i < len; i++){\n                if (listeners[i].fn === fn && listeners[i].ctx === context) {\n                    return i;\n                }\n            }\n            return false;\n        },\n        // @method once(…): this\n        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.\n        once: function(types, fn, context) {\n            // types can be a map of types/handlers\n            if (typeof types === \"object\") {\n                for(var type in types){\n                    // we don't process space-separated events here for performance;\n                    // it's a hot path since Layer uses the on(obj) syntax\n                    this._on(type, types[type], fn, true);\n                }\n            } else {\n                // types can be a string of space-separated words\n                types = splitWords(types);\n                for(var i = 0, len = types.length; i < len; i++){\n                    this._on(types[i], fn, context, true);\n                }\n            }\n            return this;\n        },\n        // @method addEventParent(obj: Evented): this\n        // Adds an event parent - an `Evented` that will receive propagated events\n        addEventParent: function(obj) {\n            this._eventParents = this._eventParents || {};\n            this._eventParents[stamp(obj)] = obj;\n            return this;\n        },\n        // @method removeEventParent(obj: Evented): this\n        // Removes an event parent, so it will stop receiving propagated events\n        removeEventParent: function(obj) {\n            if (this._eventParents) {\n                delete this._eventParents[stamp(obj)];\n            }\n            return this;\n        },\n        _propagateEvent: function(e) {\n            for(var id in this._eventParents){\n                this._eventParents[id].fire(e.type, extend({\n                    layer: e.target,\n                    propagatedFrom: e.target\n                }, e), true);\n            }\n        }\n    };\n    // aliases; we should ditch those eventually\n    // @method addEventListener(…): this\n    // Alias to [`on(…)`](#evented-on)\n    Events.addEventListener = Events.on;\n    // @method removeEventListener(…): this\n    // Alias to [`off(…)`](#evented-off)\n    // @method clearAllEventListeners(…): this\n    // Alias to [`off()`](#evented-off)\n    Events.removeEventListener = Events.clearAllEventListeners = Events.off;\n    // @method addOneTimeEventListener(…): this\n    // Alias to [`once(…)`](#evented-once)\n    Events.addOneTimeEventListener = Events.once;\n    // @method fireEvent(…): this\n    // Alias to [`fire(…)`](#evented-fire)\n    Events.fireEvent = Events.fire;\n    // @method hasEventListeners(…): Boolean\n    // Alias to [`listens(…)`](#evented-listens)\n    Events.hasEventListeners = Events.listens;\n    var Evented = Class.extend(Events);\n    /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */ function Point(x, y, round) {\n        // @property x: Number; The `x` coordinate of the point\n        this.x = round ? Math.round(x) : x;\n        // @property y: Number; The `y` coordinate of the point\n        this.y = round ? Math.round(y) : y;\n    }\n    var trunc = Math.trunc || function(v) {\n        return v > 0 ? Math.floor(v) : Math.ceil(v);\n    };\n    Point.prototype = {\n        // @method clone(): Point\n        // Returns a copy of the current point.\n        clone: function() {\n            return new Point(this.x, this.y);\n        },\n        // @method add(otherPoint: Point): Point\n        // Returns the result of addition of the current and the given points.\n        add: function(point) {\n            // non-destructive, returns a new point\n            return this.clone()._add(toPoint(point));\n        },\n        _add: function(point) {\n            // destructive, used directly for performance in situations where it's safe to modify existing point\n            this.x += point.x;\n            this.y += point.y;\n            return this;\n        },\n        // @method subtract(otherPoint: Point): Point\n        // Returns the result of subtraction of the given point from the current.\n        subtract: function(point) {\n            return this.clone()._subtract(toPoint(point));\n        },\n        _subtract: function(point) {\n            this.x -= point.x;\n            this.y -= point.y;\n            return this;\n        },\n        // @method divideBy(num: Number): Point\n        // Returns the result of division of the current point by the given number.\n        divideBy: function(num) {\n            return this.clone()._divideBy(num);\n        },\n        _divideBy: function(num) {\n            this.x /= num;\n            this.y /= num;\n            return this;\n        },\n        // @method multiplyBy(num: Number): Point\n        // Returns the result of multiplication of the current point by the given number.\n        multiplyBy: function(num) {\n            return this.clone()._multiplyBy(num);\n        },\n        _multiplyBy: function(num) {\n            this.x *= num;\n            this.y *= num;\n            return this;\n        },\n        // @method scaleBy(scale: Point): Point\n        // Multiply each coordinate of the current point by each coordinate of\n        // `scale`. In linear algebra terms, multiply the point by the\n        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n        // defined by `scale`.\n        scaleBy: function(point) {\n            return new Point(this.x * point.x, this.y * point.y);\n        },\n        // @method unscaleBy(scale: Point): Point\n        // Inverse of `scaleBy`. Divide each coordinate of the current point by\n        // each coordinate of `scale`.\n        unscaleBy: function(point) {\n            return new Point(this.x / point.x, this.y / point.y);\n        },\n        // @method round(): Point\n        // Returns a copy of the current point with rounded coordinates.\n        round: function() {\n            return this.clone()._round();\n        },\n        _round: function() {\n            this.x = Math.round(this.x);\n            this.y = Math.round(this.y);\n            return this;\n        },\n        // @method floor(): Point\n        // Returns a copy of the current point with floored coordinates (rounded down).\n        floor: function() {\n            return this.clone()._floor();\n        },\n        _floor: function() {\n            this.x = Math.floor(this.x);\n            this.y = Math.floor(this.y);\n            return this;\n        },\n        // @method ceil(): Point\n        // Returns a copy of the current point with ceiled coordinates (rounded up).\n        ceil: function() {\n            return this.clone()._ceil();\n        },\n        _ceil: function() {\n            this.x = Math.ceil(this.x);\n            this.y = Math.ceil(this.y);\n            return this;\n        },\n        // @method trunc(): Point\n        // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n        trunc: function() {\n            return this.clone()._trunc();\n        },\n        _trunc: function() {\n            this.x = trunc(this.x);\n            this.y = trunc(this.y);\n            return this;\n        },\n        // @method distanceTo(otherPoint: Point): Number\n        // Returns the cartesian distance between the current and the given points.\n        distanceTo: function(point) {\n            point = toPoint(point);\n            var x = point.x - this.x, y = point.y - this.y;\n            return Math.sqrt(x * x + y * y);\n        },\n        // @method equals(otherPoint: Point): Boolean\n        // Returns `true` if the given point has the same coordinates.\n        equals: function(point) {\n            point = toPoint(point);\n            return point.x === this.x && point.y === this.y;\n        },\n        // @method contains(otherPoint: Point): Boolean\n        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n        contains: function(point) {\n            point = toPoint(point);\n            return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n        },\n        // @method toString(): String\n        // Returns a string representation of the point for debugging purposes.\n        toString: function() {\n            return \"Point(\" + formatNum(this.x) + \", \" + formatNum(this.y) + \")\";\n        }\n    };\n    // @factory L.point(x: Number, y: Number, round?: Boolean)\n    // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n    // @alternative\n    // @factory L.point(coords: Number[])\n    // Expects an array of the form `[x, y]` instead.\n    // @alternative\n    // @factory L.point(coords: Object)\n    // Expects a plain object of the form `{x: Number, y: Number}` instead.\n    function toPoint(x, y, round) {\n        if (x instanceof Point) {\n            return x;\n        }\n        if (isArray(x)) {\n            return new Point(x[0], x[1]);\n        }\n        if (x === undefined || x === null) {\n            return x;\n        }\n        if (typeof x === \"object\" && \"x\" in x && \"y\" in x) {\n            return new Point(x.x, x.y);\n        }\n        return new Point(x, y, round);\n    }\n    /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */ function Bounds(a, b) {\n        if (!a) {\n            return;\n        }\n        var points = b ? [\n            a,\n            b\n        ] : a;\n        for(var i = 0, len = points.length; i < len; i++){\n            this.extend(points[i]);\n        }\n    }\n    Bounds.prototype = {\n        // @method extend(point: Point): this\n        // Extends the bounds to contain the given point.\n        // @alternative\n        // @method extend(otherBounds: Bounds): this\n        // Extend the bounds to contain the given bounds\n        extend: function(obj) {\n            var min2, max2;\n            if (!obj) {\n                return this;\n            }\n            if (obj instanceof Point || typeof obj[0] === \"number\" || \"x\" in obj) {\n                min2 = max2 = toPoint(obj);\n            } else {\n                obj = toBounds(obj);\n                min2 = obj.min;\n                max2 = obj.max;\n                if (!min2 || !max2) {\n                    return this;\n                }\n            }\n            // @property min: Point\n            // The top left corner of the rectangle.\n            // @property max: Point\n            // The bottom right corner of the rectangle.\n            if (!this.min && !this.max) {\n                this.min = min2.clone();\n                this.max = max2.clone();\n            } else {\n                this.min.x = Math.min(min2.x, this.min.x);\n                this.max.x = Math.max(max2.x, this.max.x);\n                this.min.y = Math.min(min2.y, this.min.y);\n                this.max.y = Math.max(max2.y, this.max.y);\n            }\n            return this;\n        },\n        // @method getCenter(round?: Boolean): Point\n        // Returns the center point of the bounds.\n        getCenter: function(round) {\n            return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n        },\n        // @method getBottomLeft(): Point\n        // Returns the bottom-left point of the bounds.\n        getBottomLeft: function() {\n            return toPoint(this.min.x, this.max.y);\n        },\n        // @method getTopRight(): Point\n        // Returns the top-right point of the bounds.\n        getTopRight: function() {\n            return toPoint(this.max.x, this.min.y);\n        },\n        // @method getTopLeft(): Point\n        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\n        getTopLeft: function() {\n            return this.min; // left, top\n        },\n        // @method getBottomRight(): Point\n        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\n        getBottomRight: function() {\n            return this.max; // right, bottom\n        },\n        // @method getSize(): Point\n        // Returns the size of the given bounds\n        getSize: function() {\n            return this.max.subtract(this.min);\n        },\n        // @method contains(otherBounds: Bounds): Boolean\n        // Returns `true` if the rectangle contains the given one.\n        // @alternative\n        // @method contains(point: Point): Boolean\n        // Returns `true` if the rectangle contains the given point.\n        contains: function(obj) {\n            var min, max;\n            if (typeof obj[0] === \"number\" || obj instanceof Point) {\n                obj = toPoint(obj);\n            } else {\n                obj = toBounds(obj);\n            }\n            if (obj instanceof Bounds) {\n                min = obj.min;\n                max = obj.max;\n            } else {\n                min = max = obj;\n            }\n            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n        },\n        // @method intersects(otherBounds: Bounds): Boolean\n        // Returns `true` if the rectangle intersects the given bounds. Two bounds\n        // intersect if they have at least one point in common.\n        intersects: function(bounds) {\n            bounds = toBounds(bounds);\n            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;\n            return xIntersects && yIntersects;\n        },\n        // @method overlaps(otherBounds: Bounds): Boolean\n        // Returns `true` if the rectangle overlaps the given bounds. Two bounds\n        // overlap if their intersection is an area.\n        overlaps: function(bounds) {\n            bounds = toBounds(bounds);\n            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;\n            return xOverlaps && yOverlaps;\n        },\n        // @method isValid(): Boolean\n        // Returns `true` if the bounds are properly initialized.\n        isValid: function() {\n            return !!(this.min && this.max);\n        },\n        // @method pad(bufferRatio: Number): Bounds\n        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n        // Negative values will retract the bounds.\n        pad: function(bufferRatio) {\n            var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;\n            return toBounds(toPoint(min.x - heightBuffer, min.y - widthBuffer), toPoint(max.x + heightBuffer, max.y + widthBuffer));\n        },\n        // @method equals(otherBounds: Bounds): Boolean\n        // Returns `true` if the rectangle is equivalent to the given bounds.\n        equals: function(bounds) {\n            if (!bounds) {\n                return false;\n            }\n            bounds = toBounds(bounds);\n            return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());\n        }\n    };\n    // @factory L.bounds(corner1: Point, corner2: Point)\n    // Creates a Bounds object from two corners coordinate pairs.\n    // @alternative\n    // @factory L.bounds(points: Point[])\n    // Creates a Bounds object from the given array of points.\n    function toBounds(a, b) {\n        if (!a || a instanceof Bounds) {\n            return a;\n        }\n        return new Bounds(a, b);\n    }\n    /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */ function LatLngBounds(corner1, corner2) {\n        if (!corner1) {\n            return;\n        }\n        var latlngs = corner2 ? [\n            corner1,\n            corner2\n        ] : corner1;\n        for(var i = 0, len = latlngs.length; i < len; i++){\n            this.extend(latlngs[i]);\n        }\n    }\n    LatLngBounds.prototype = {\n        // @method extend(latlng: LatLng): this\n        // Extend the bounds to contain the given point\n        // @alternative\n        // @method extend(otherBounds: LatLngBounds): this\n        // Extend the bounds to contain the given bounds\n        extend: function(obj) {\n            var sw = this._southWest, ne = this._northEast, sw2, ne2;\n            if (obj instanceof LatLng) {\n                sw2 = obj;\n                ne2 = obj;\n            } else if (obj instanceof LatLngBounds) {\n                sw2 = obj._southWest;\n                ne2 = obj._northEast;\n                if (!sw2 || !ne2) {\n                    return this;\n                }\n            } else {\n                return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\n            }\n            if (!sw && !ne) {\n                this._southWest = new LatLng(sw2.lat, sw2.lng);\n                this._northEast = new LatLng(ne2.lat, ne2.lng);\n            } else {\n                sw.lat = Math.min(sw2.lat, sw.lat);\n                sw.lng = Math.min(sw2.lng, sw.lng);\n                ne.lat = Math.max(ne2.lat, ne.lat);\n                ne.lng = Math.max(ne2.lng, ne.lng);\n            }\n            return this;\n        },\n        // @method pad(bufferRatio: Number): LatLngBounds\n        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\n        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.\n        // Negative values will retract the bounds.\n        pad: function(bufferRatio) {\n            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n            return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n        },\n        // @method getCenter(): LatLng\n        // Returns the center point of the bounds.\n        getCenter: function() {\n            return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n        },\n        // @method getSouthWest(): LatLng\n        // Returns the south-west point of the bounds.\n        getSouthWest: function() {\n            return this._southWest;\n        },\n        // @method getNorthEast(): LatLng\n        // Returns the north-east point of the bounds.\n        getNorthEast: function() {\n            return this._northEast;\n        },\n        // @method getNorthWest(): LatLng\n        // Returns the north-west point of the bounds.\n        getNorthWest: function() {\n            return new LatLng(this.getNorth(), this.getWest());\n        },\n        // @method getSouthEast(): LatLng\n        // Returns the south-east point of the bounds.\n        getSouthEast: function() {\n            return new LatLng(this.getSouth(), this.getEast());\n        },\n        // @method getWest(): Number\n        // Returns the west longitude of the bounds\n        getWest: function() {\n            return this._southWest.lng;\n        },\n        // @method getSouth(): Number\n        // Returns the south latitude of the bounds\n        getSouth: function() {\n            return this._southWest.lat;\n        },\n        // @method getEast(): Number\n        // Returns the east longitude of the bounds\n        getEast: function() {\n            return this._northEast.lng;\n        },\n        // @method getNorth(): Number\n        // Returns the north latitude of the bounds\n        getNorth: function() {\n            return this._northEast.lat;\n        },\n        // @method contains(otherBounds: LatLngBounds): Boolean\n        // Returns `true` if the rectangle contains the given one.\n        // @alternative\n        // @method contains (latlng: LatLng): Boolean\n        // Returns `true` if the rectangle contains the given point.\n        contains: function(obj) {\n            if (typeof obj[0] === \"number\" || obj instanceof LatLng || \"lat\" in obj) {\n                obj = toLatLng(obj);\n            } else {\n                obj = toLatLngBounds(obj);\n            }\n            var sw = this._southWest, ne = this._northEast, sw2, ne2;\n            if (obj instanceof LatLngBounds) {\n                sw2 = obj.getSouthWest();\n                ne2 = obj.getNorthEast();\n            } else {\n                sw2 = ne2 = obj;\n            }\n            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;\n        },\n        // @method intersects(otherBounds: LatLngBounds): Boolean\n        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\n        intersects: function(bounds) {\n            bounds = toLatLngBounds(bounds);\n            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;\n            return latIntersects && lngIntersects;\n        },\n        // @method overlaps(otherBounds: LatLngBounds): Boolean\n        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\n        overlaps: function(bounds) {\n            bounds = toLatLngBounds(bounds);\n            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;\n            return latOverlaps && lngOverlaps;\n        },\n        // @method toBBoxString(): String\n        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\n        toBBoxString: function() {\n            return [\n                this.getWest(),\n                this.getSouth(),\n                this.getEast(),\n                this.getNorth()\n            ].join(\",\");\n        },\n        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\n        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\n        equals: function(bounds, maxMargin) {\n            if (!bounds) {\n                return false;\n            }\n            bounds = toLatLngBounds(bounds);\n            return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);\n        },\n        // @method isValid(): Boolean\n        // Returns `true` if the bounds are properly initialized.\n        isValid: function() {\n            return !!(this._southWest && this._northEast);\n        }\n    };\n    // TODO International date line?\n    // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\n    // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\n    // @alternative\n    // @factory L.latLngBounds(latlngs: LatLng[])\n    // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\n    function toLatLngBounds(a, b) {\n        if (a instanceof LatLngBounds) {\n            return a;\n        }\n        return new LatLngBounds(a, b);\n    }\n    /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */ function LatLng(lat, lng, alt) {\n        if (isNaN(lat) || isNaN(lng)) {\n            throw new Error(\"Invalid LatLng object: (\" + lat + \", \" + lng + \")\");\n        }\n        // @property lat: Number\n        // Latitude in degrees\n        this.lat = +lat;\n        // @property lng: Number\n        // Longitude in degrees\n        this.lng = +lng;\n        // @property alt: Number\n        // Altitude in meters (optional)\n        if (alt !== undefined) {\n            this.alt = +alt;\n        }\n    }\n    LatLng.prototype = {\n        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\n        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\n        equals: function(obj, maxMargin) {\n            if (!obj) {\n                return false;\n            }\n            obj = toLatLng(obj);\n            var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));\n            return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\n        },\n        // @method toString(): String\n        // Returns a string representation of the point (for debugging purposes).\n        toString: function(precision) {\n            return \"LatLng(\" + formatNum(this.lat, precision) + \", \" + formatNum(this.lng, precision) + \")\";\n        },\n        // @method distanceTo(otherLatLng: LatLng): Number\n        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\n        distanceTo: function(other) {\n            return Earth.distance(this, toLatLng(other));\n        },\n        // @method wrap(): LatLng\n        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\n        wrap: function() {\n            return Earth.wrapLatLng(this);\n        },\n        // @method toBounds(sizeInMeters: Number): LatLngBounds\n        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\n        toBounds: function(sizeInMeters) {\n            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);\n            return toLatLngBounds([\n                this.lat - latAccuracy,\n                this.lng - lngAccuracy\n            ], [\n                this.lat + latAccuracy,\n                this.lng + lngAccuracy\n            ]);\n        },\n        clone: function() {\n            return new LatLng(this.lat, this.lng, this.alt);\n        }\n    };\n    // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\n    // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\n    // @alternative\n    // @factory L.latLng(coords: Array): LatLng\n    // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\n    // @alternative\n    // @factory L.latLng(coords: Object): LatLng\n    // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\n    function toLatLng(a, b, c) {\n        if (a instanceof LatLng) {\n            return a;\n        }\n        if (isArray(a) && typeof a[0] !== \"object\") {\n            if (a.length === 3) {\n                return new LatLng(a[0], a[1], a[2]);\n            }\n            if (a.length === 2) {\n                return new LatLng(a[0], a[1]);\n            }\n            return null;\n        }\n        if (a === undefined || a === null) {\n            return a;\n        }\n        if (typeof a === \"object\" && \"lat\" in a) {\n            return new LatLng(a.lat, \"lng\" in a ? a.lng : a.lon, a.alt);\n        }\n        if (b === undefined) {\n            return null;\n        }\n        return new LatLng(a, b, c);\n    }\n    /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */ var CRS = {\n        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point\n        // Projects geographical coordinates into pixel coordinates for a given zoom.\n        latLngToPoint: function(latlng, zoom) {\n            var projectedPoint = this.projection.project(latlng), scale = this.scale(zoom);\n            return this.transformation._transform(projectedPoint, scale);\n        },\n        // @method pointToLatLng(point: Point, zoom: Number): LatLng\n        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given\n        // zoom into geographical coordinates.\n        pointToLatLng: function(point, zoom) {\n            var scale = this.scale(zoom), untransformedPoint = this.transformation.untransform(point, scale);\n            return this.projection.unproject(untransformedPoint);\n        },\n        // @method project(latlng: LatLng): Point\n        // Projects geographical coordinates into coordinates in units accepted for\n        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\n        project: function(latlng) {\n            return this.projection.project(latlng);\n        },\n        // @method unproject(point: Point): LatLng\n        // Given a projected coordinate returns the corresponding LatLng.\n        // The inverse of `project`.\n        unproject: function(point) {\n            return this.projection.unproject(point);\n        },\n        // @method scale(zoom: Number): Number\n        // Returns the scale used when transforming projected coordinates into\n        // pixel coordinates for a particular zoom. For example, it returns\n        // `256 * 2^zoom` for Mercator-based CRS.\n        scale: function(zoom) {\n            return 256 * Math.pow(2, zoom);\n        },\n        // @method zoom(scale: Number): Number\n        // Inverse of `scale()`, returns the zoom level corresponding to a scale\n        // factor of `scale`.\n        zoom: function(scale) {\n            return Math.log(scale / 256) / Math.LN2;\n        },\n        // @method getProjectedBounds(zoom: Number): Bounds\n        // Returns the projection's bounds scaled and transformed for the provided `zoom`.\n        getProjectedBounds: function(zoom) {\n            if (this.infinite) {\n                return null;\n            }\n            var b = this.projection.bounds, s = this.scale(zoom), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);\n            return new Bounds(min, max);\n        },\n        // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n        // Returns the distance between two geographical coordinates.\n        // @property code: String\n        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\n        //\n        // @property wrapLng: Number[]\n        // An array of two numbers defining whether the longitude (horizontal) coordinate\n        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most\n        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.\n        //\n        // @property wrapLat: Number[]\n        // Like `wrapLng`, but for the latitude (vertical) axis.\n        // wrapLng: [min, max],\n        // wrapLat: [min, max],\n        // @property infinite: Boolean\n        // If true, the coordinate space will be unbounded (infinite in both axes)\n        infinite: false,\n        // @method wrapLatLng(latlng: LatLng): LatLng\n        // Returns a `LatLng` where lat and lng has been wrapped according to the\n        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\n        wrapLatLng: function(latlng) {\n            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;\n            return new LatLng(lat, lng, alt);\n        },\n        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n        // Returns a `LatLngBounds` with the same size as the given one, ensuring\n        // that its center is within the CRS's bounds.\n        // Only accepts actual `L.LatLngBounds` instances, not arrays.\n        wrapLatLngBounds: function(bounds) {\n            var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;\n            if (latShift === 0 && lngShift === 0) {\n                return bounds;\n            }\n            var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\n            return new LatLngBounds(newSw, newNe);\n        }\n    };\n    /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */ var Earth = extend({}, CRS, {\n        wrapLng: [\n            -180,\n            180\n        ],\n        // Mean Earth Radius, as recommended for use by\n        // the International Union of Geodesy and Geophysics,\n        // see https://rosettacode.org/wiki/Haversine_formula\n        R: 6371000,\n        // distance between two geographical points using spherical law of cosines approximation\n        distance: function(latlng1, latlng2) {\n            var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n            return this.R * c;\n        }\n    });\n    /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection — the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */ var earthRadius = 6378137;\n    var SphericalMercator = {\n        R: earthRadius,\n        MAX_LATITUDE: 85.0511287798,\n        project: function(latlng) {\n            var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);\n            return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);\n        },\n        unproject: function(point) {\n            var d = 180 / Math.PI;\n            return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);\n        },\n        bounds: function() {\n            var d = earthRadius * Math.PI;\n            return new Bounds([\n                -d,\n                -d\n            ], [\n                d,\n                d\n            ]);\n        }()\n    };\n    /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */ // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\n    // Creates a `Transformation` object with the given coefficients.\n    function Transformation(a, b, c, d) {\n        if (isArray(a)) {\n            // use array properties\n            this._a = a[0];\n            this._b = a[1];\n            this._c = a[2];\n            this._d = a[3];\n            return;\n        }\n        this._a = a;\n        this._b = b;\n        this._c = c;\n        this._d = d;\n    }\n    Transformation.prototype = {\n        // @method transform(point: Point, scale?: Number): Point\n        // Returns a transformed point, optionally multiplied by the given scale.\n        // Only accepts actual `L.Point` instances, not arrays.\n        transform: function(point, scale) {\n            return this._transform(point.clone(), scale);\n        },\n        // destructive transform (faster)\n        _transform: function(point, scale) {\n            scale = scale || 1;\n            point.x = scale * (this._a * point.x + this._b);\n            point.y = scale * (this._c * point.y + this._d);\n            return point;\n        },\n        // @method untransform(point: Point, scale?: Number): Point\n        // Returns the reverse transformation of the given point, optionally divided\n        // by the given scale. Only accepts actual `L.Point` instances, not arrays.\n        untransform: function(point, scale) {\n            scale = scale || 1;\n            return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);\n        }\n    };\n    // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n    // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\n    // Instantiates a Transformation object with the given coefficients.\n    // @alternative\n    // @factory L.transformation(coefficients: Array): Transformation\n    // Expects an coefficients array of the form\n    // `[a: Number, b: Number, c: Number, d: Number]`.\n    function toTransformation(a, b, c, d) {\n        return new Transformation(a, b, c, d);\n    }\n    /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */ var EPSG3857 = extend({}, Earth, {\n        code: \"EPSG:3857\",\n        projection: SphericalMercator,\n        transformation: function() {\n            var scale = 0.5 / (Math.PI * SphericalMercator.R);\n            return toTransformation(scale, 0.5, -scale, 0.5);\n        }()\n    });\n    var EPSG900913 = extend({}, EPSG3857, {\n        code: \"EPSG:900913\"\n    });\n    // @namespace SVG; @section\n    // There are several static functions which can be called without instantiating L.SVG:\n    // @function create(name: String): SVGElement\n    // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n    // corresponding to the class name passed. For example, using 'line' will return\n    // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n    function svgCreate(name) {\n        return document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n    }\n    // @function pointsToPath(rings: Point[], closed: Boolean): String\n    // Generates a SVG path string for multiple rings, with each ring turning\n    // into \"M..L..L..\" instructions\n    function pointsToPath(rings, closed) {\n        var str = \"\", i, j, len, len2, points, p;\n        for(i = 0, len = rings.length; i < len; i++){\n            points = rings[i];\n            for(j = 0, len2 = points.length; j < len2; j++){\n                p = points[j];\n                str += (j ? \"L\" : \"M\") + p.x + \" \" + p.y;\n            }\n            // closes the ring for polygons; \"x\" is VML syntax\n            str += closed ? Browser.svg ? \"z\" : \"x\" : \"\";\n        }\n        // SVG complains about empty path strings\n        return str || \"M0 0\";\n    }\n    /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */ var style = document.documentElement.style;\n    // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\n    var ie = \"ActiveXObject\" in window;\n    // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\n    var ielt9 = ie && !document.addEventListener;\n    // @property edge: Boolean; `true` for the Edge web browser.\n    var edge = \"msLaunchUri\" in navigator && !(\"documentMode\" in document);\n    // @property webkit: Boolean;\n    // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\n    var webkit = userAgentContains(\"webkit\");\n    // @property android: Boolean\n    // **Deprecated.** `true` for any browser running on an Android platform.\n    var android = userAgentContains(\"android\");\n    // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.\n    var android23 = userAgentContains(\"android 2\") || userAgentContains(\"android 3\");\n    /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */ var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\n    // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)\n    var androidStock = android && userAgentContains(\"Google\") && webkitVer < 537 && !(\"AudioNode\" in window);\n    // @property opera: Boolean; `true` for the Opera browser\n    var opera = !!window.opera;\n    // @property chrome: Boolean; `true` for the Chrome browser.\n    var chrome = !edge && userAgentContains(\"chrome\");\n    // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\n    var gecko = userAgentContains(\"gecko\") && !webkit && !opera && !ie;\n    // @property safari: Boolean; `true` for the Safari browser.\n    var safari = !chrome && userAgentContains(\"safari\");\n    var phantom = userAgentContains(\"phantom\");\n    // @property opera12: Boolean\n    // `true` for the Opera browser supporting CSS transforms (version 12 or later).\n    var opera12 = \"OTransition\" in style;\n    // @property win: Boolean; `true` when the browser is running in a Windows platform\n    var win = navigator.platform.indexOf(\"Win\") === 0;\n    // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\n    var ie3d = ie && \"transition\" in style;\n    // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\n    var webkit3d = \"WebKitCSSMatrix\" in window && \"m11\" in new window.WebKitCSSMatrix() && !android23;\n    // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\n    var gecko3d = \"MozPerspective\" in style;\n    // @property any3d: Boolean\n    // `true` for all browsers supporting CSS transforms.\n    var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;\n    // @property mobile: Boolean; `true` for all browsers running in a mobile device.\n    var mobile = typeof orientation !== \"undefined\" || userAgentContains(\"mobile\");\n    // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\n    var mobileWebkit = mobile && webkit;\n    // @property mobileWebkit3d: Boolean\n    // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\n    var mobileWebkit3d = mobile && webkit3d;\n    // @property msPointer: Boolean\n    // `true` for browsers implementing the Microsoft touch events model (notably IE10).\n    var msPointer = !window.PointerEvent && window.MSPointerEvent;\n    // @property pointer: Boolean\n    // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\n    var pointer = !!(window.PointerEvent || msPointer);\n    // @property touchNative: Boolean\n    // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\n    // **This does not necessarily mean** that the browser is running in a computer with\n    // a touchscreen, it only means that the browser is capable of understanding\n    // touch events.\n    var touchNative = \"ontouchstart\" in window || !!window.TouchEvent;\n    // @property touch: Boolean\n    // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.\n    // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.\n    var touch = !window.L_NO_TOUCH && (touchNative || pointer);\n    // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\n    var mobileOpera = mobile && opera;\n    // @property mobileGecko: Boolean\n    // `true` for gecko-based browsers running in a mobile device.\n    var mobileGecko = mobile && gecko;\n    // @property retina: Boolean\n    // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\n    var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;\n    // @property passiveEvents: Boolean\n    // `true` for browsers that support passive events.\n    var passiveEvents = function() {\n        var supportsPassiveOption = false;\n        try {\n            var opts = Object.defineProperty({}, \"passive\", {\n                get: function() {\n                    supportsPassiveOption = true;\n                }\n            });\n            window.addEventListener(\"testPassiveEventSupport\", falseFn, opts);\n            window.removeEventListener(\"testPassiveEventSupport\", falseFn, opts);\n        } catch (e) {\n        // Errors can safely be ignored since this is only a browser support test.\n        }\n        return supportsPassiveOption;\n    }();\n    // @property canvas: Boolean\n    // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n    var canvas$1 = function() {\n        return !!document.createElement(\"canvas\").getContext;\n    }();\n    // @property svg: Boolean\n    // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\n    var svg$1 = !!(document.createElementNS && svgCreate(\"svg\").createSVGRect);\n    var inlineSvg = !!svg$1 && function() {\n        var div = document.createElement(\"div\");\n        div.innerHTML = \"<svg/>\";\n        return (div.firstChild && div.firstChild.namespaceURI) === \"http://www.w3.org/2000/svg\";\n    }();\n    // @property vml: Boolean\n    // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\n    var vml = !svg$1 && function() {\n        try {\n            var div = document.createElement(\"div\");\n            div.innerHTML = '<v:shape adj=\"1\"/>';\n            var shape = div.firstChild;\n            shape.style.behavior = \"url(#default#VML)\";\n            return shape && typeof shape.adj === \"object\";\n        } catch (e) {\n            return false;\n        }\n    }();\n    // @property mac: Boolean; `true` when the browser is running in a Mac platform\n    var mac = navigator.platform.indexOf(\"Mac\") === 0;\n    // @property mac: Boolean; `true` when the browser is running in a Linux platform\n    var linux = navigator.platform.indexOf(\"Linux\") === 0;\n    function userAgentContains(str) {\n        return navigator.userAgent.toLowerCase().indexOf(str) >= 0;\n    }\n    var Browser = {\n        ie: ie,\n        ielt9: ielt9,\n        edge: edge,\n        webkit: webkit,\n        android: android,\n        android23: android23,\n        androidStock: androidStock,\n        opera: opera,\n        chrome: chrome,\n        gecko: gecko,\n        safari: safari,\n        phantom: phantom,\n        opera12: opera12,\n        win: win,\n        ie3d: ie3d,\n        webkit3d: webkit3d,\n        gecko3d: gecko3d,\n        any3d: any3d,\n        mobile: mobile,\n        mobileWebkit: mobileWebkit,\n        mobileWebkit3d: mobileWebkit3d,\n        msPointer: msPointer,\n        pointer: pointer,\n        touch: touch,\n        touchNative: touchNative,\n        mobileOpera: mobileOpera,\n        mobileGecko: mobileGecko,\n        retina: retina,\n        passiveEvents: passiveEvents,\n        canvas: canvas$1,\n        svg: svg$1,\n        vml: vml,\n        inlineSvg: inlineSvg,\n        mac: mac,\n        linux: linux\n    };\n    /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */ var POINTER_DOWN = Browser.msPointer ? \"MSPointerDown\" : \"pointerdown\";\n    var POINTER_MOVE = Browser.msPointer ? \"MSPointerMove\" : \"pointermove\";\n    var POINTER_UP = Browser.msPointer ? \"MSPointerUp\" : \"pointerup\";\n    var POINTER_CANCEL = Browser.msPointer ? \"MSPointerCancel\" : \"pointercancel\";\n    var pEvent = {\n        touchstart: POINTER_DOWN,\n        touchmove: POINTER_MOVE,\n        touchend: POINTER_UP,\n        touchcancel: POINTER_CANCEL\n    };\n    var handle = {\n        touchstart: _onPointerStart,\n        touchmove: _handlePointer,\n        touchend: _handlePointer,\n        touchcancel: _handlePointer\n    };\n    var _pointers = {};\n    var _pointerDocListener = false;\n    // Provides a touch events wrapper for (ms)pointer events.\n    // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n    function addPointerListener(obj, type, handler) {\n        if (type === \"touchstart\") {\n            _addPointerDocListener();\n        }\n        if (!handle[type]) {\n            console.warn(\"wrong event specified:\", type);\n            return falseFn;\n        }\n        handler = handle[type].bind(this, handler);\n        obj.addEventListener(pEvent[type], handler, false);\n        return handler;\n    }\n    function removePointerListener(obj, type, handler) {\n        if (!pEvent[type]) {\n            console.warn(\"wrong event specified:\", type);\n            return;\n        }\n        obj.removeEventListener(pEvent[type], handler, false);\n    }\n    function _globalPointerDown(e) {\n        _pointers[e.pointerId] = e;\n    }\n    function _globalPointerMove(e) {\n        if (_pointers[e.pointerId]) {\n            _pointers[e.pointerId] = e;\n        }\n    }\n    function _globalPointerUp(e) {\n        delete _pointers[e.pointerId];\n    }\n    function _addPointerDocListener() {\n        // need to keep track of what pointers and how many are active to provide e.touches emulation\n        if (!_pointerDocListener) {\n            // we listen document as any drags that end by moving the touch off the screen get fired there\n            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n            document.addEventListener(POINTER_UP, _globalPointerUp, true);\n            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n            _pointerDocListener = true;\n        }\n    }\n    function _handlePointer(handler, e) {\n        if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || \"mouse\")) {\n            return;\n        }\n        e.touches = [];\n        for(var i in _pointers){\n            e.touches.push(_pointers[i]);\n        }\n        e.changedTouches = [\n            e\n        ];\n        handler(e);\n    }\n    function _onPointerStart(handler, e) {\n        // IE10 specific: MsTouch needs preventDefault. See #2000\n        if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {\n            preventDefault(e);\n        }\n        _handlePointer(handler, e);\n    }\n    /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   *\r\n   * Note: currently most browsers fire native dblclick, with only a few exceptions\r\n   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)\r\n   */ function makeDblclick(event) {\n        // in modern browsers `type` cannot be just overridden:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only\n        var newEvent = {}, prop, i;\n        for(i in event){\n            prop = event[i];\n            newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;\n        }\n        event = newEvent;\n        newEvent.type = \"dblclick\";\n        newEvent.detail = 2;\n        newEvent.isTrusted = false;\n        newEvent._simulated = true; // for debug purposes\n        return newEvent;\n    }\n    var delay = 200;\n    function addDoubleTapListener(obj, handler) {\n        // Most browsers handle double tap natively\n        obj.addEventListener(\"dblclick\", handler);\n        // On some platforms the browser doesn't fire native dblclicks for touch events.\n        // It seems that in all such cases `detail` property of `click` event is always `1`.\n        // So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.\n        var last = 0, detail;\n        function simDblclick(e) {\n            if (e.detail !== 1) {\n                detail = e.detail; // keep in sync to avoid false dblclick in some cases\n                return;\n            }\n            if (e.pointerType === \"mouse\" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {\n                return;\n            }\n            // When clicking on an <input>, the browser generates a click on its\n            // <label> (and vice versa) triggering two clicks in quick succession.\n            // This ignores clicks on elements which are a label with a 'for'\n            // attribute (or children of such a label), but not children of\n            // a <input>.\n            var path = getPropagationPath(e);\n            if (path.some(function(el) {\n                return el instanceof HTMLLabelElement && el.attributes.for;\n            }) && !path.some(function(el) {\n                return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;\n            })) {\n                return;\n            }\n            var now = Date.now();\n            if (now - last <= delay) {\n                detail++;\n                if (detail === 2) {\n                    handler(makeDblclick(e));\n                }\n            } else {\n                detail = 1;\n            }\n            last = now;\n        }\n        obj.addEventListener(\"click\", simDblclick);\n        return {\n            dblclick: handler,\n            simDblclick: simDblclick\n        };\n    }\n    function removeDoubleTapListener(obj, handlers) {\n        obj.removeEventListener(\"dblclick\", handlers.dblclick);\n        obj.removeEventListener(\"click\", handlers.simDblclick);\n    }\n    /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */ // @property TRANSFORM: String\n    // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\n    var TRANSFORM = testProp([\n        \"transform\",\n        \"webkitTransform\",\n        \"OTransform\",\n        \"MozTransform\",\n        \"msTransform\"\n    ]);\n    // webkitTransition comes first because some browser versions that drop vendor prefix don't do\n    // the same for the transitionend event, in particular the Android 4.1 stock browser\n    // @property TRANSITION: String\n    // Vendor-prefixed transition style name.\n    var TRANSITION = testProp([\n        \"webkitTransition\",\n        \"transition\",\n        \"OTransition\",\n        \"MozTransition\",\n        \"msTransition\"\n    ]);\n    // @property TRANSITION_END: String\n    // Vendor-prefixed transitionend event name.\n    var TRANSITION_END = TRANSITION === \"webkitTransition\" || TRANSITION === \"OTransition\" ? TRANSITION + \"End\" : \"transitionend\";\n    // @function get(id: String|HTMLElement): HTMLElement\n    // Returns an element given its DOM id, or returns the element itself\n    // if it was passed directly.\n    function get(id) {\n        return typeof id === \"string\" ? document.getElementById(id) : id;\n    }\n    // @function getStyle(el: HTMLElement, styleAttrib: String): String\n    // Returns the value for a certain style attribute on an element,\n    // including computed values or values set through CSS.\n    function getStyle(el, style) {\n        var value = el.style[style] || el.currentStyle && el.currentStyle[style];\n        if ((!value || value === \"auto\") && document.defaultView) {\n            var css = document.defaultView.getComputedStyle(el, null);\n            value = css ? css[style] : null;\n        }\n        return value === \"auto\" ? null : value;\n    }\n    // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\n    // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\n    function create$1(tagName, className, container) {\n        var el = document.createElement(tagName);\n        el.className = className || \"\";\n        if (container) {\n            container.appendChild(el);\n        }\n        return el;\n    }\n    // @function remove(el: HTMLElement)\n    // Removes `el` from its parent element\n    function remove(el) {\n        var parent = el.parentNode;\n        if (parent) {\n            parent.removeChild(el);\n        }\n    }\n    // @function empty(el: HTMLElement)\n    // Removes all of `el`'s children elements from `el`\n    function empty(el) {\n        while(el.firstChild){\n            el.removeChild(el.firstChild);\n        }\n    }\n    // @function toFront(el: HTMLElement)\n    // Makes `el` the last child of its parent, so it renders in front of the other children.\n    function toFront(el) {\n        var parent = el.parentNode;\n        if (parent && parent.lastChild !== el) {\n            parent.appendChild(el);\n        }\n    }\n    // @function toBack(el: HTMLElement)\n    // Makes `el` the first child of its parent, so it renders behind the other children.\n    function toBack(el) {\n        var parent = el.parentNode;\n        if (parent && parent.firstChild !== el) {\n            parent.insertBefore(el, parent.firstChild);\n        }\n    }\n    // @function hasClass(el: HTMLElement, name: String): Boolean\n    // Returns `true` if the element's class attribute contains `name`.\n    function hasClass(el, name) {\n        if (el.classList !== undefined) {\n            return el.classList.contains(name);\n        }\n        var className = getClass(el);\n        return className.length > 0 && new RegExp(\"(^|\\\\s)\" + name + \"(\\\\s|$)\").test(className);\n    }\n    // @function addClass(el: HTMLElement, name: String)\n    // Adds `name` to the element's class attribute.\n    function addClass(el, name) {\n        if (el.classList !== undefined) {\n            var classes = splitWords(name);\n            for(var i = 0, len = classes.length; i < len; i++){\n                el.classList.add(classes[i]);\n            }\n        } else if (!hasClass(el, name)) {\n            var className = getClass(el);\n            setClass(el, (className ? className + \" \" : \"\") + name);\n        }\n    }\n    // @function removeClass(el: HTMLElement, name: String)\n    // Removes `name` from the element's class attribute.\n    function removeClass(el, name) {\n        if (el.classList !== undefined) {\n            el.classList.remove(name);\n        } else {\n            setClass(el, trim((\" \" + getClass(el) + \" \").replace(\" \" + name + \" \", \" \")));\n        }\n    }\n    // @function setClass(el: HTMLElement, name: String)\n    // Sets the element's class.\n    function setClass(el, name) {\n        if (el.className.baseVal === undefined) {\n            el.className = name;\n        } else {\n            // in case of SVG element\n            el.className.baseVal = name;\n        }\n    }\n    // @function getClass(el: HTMLElement): String\n    // Returns the element's class.\n    function getClass(el) {\n        // Check if the element is an SVGElementInstance and use the correspondingElement instead\n        // (Required for linked SVG elements in IE11.)\n        if (el.correspondingElement) {\n            el = el.correspondingElement;\n        }\n        return el.className.baseVal === undefined ? el.className : el.className.baseVal;\n    }\n    // @function setOpacity(el: HTMLElement, opacity: Number)\n    // Set the opacity of an element (including old IE support).\n    // `opacity` must be a number from `0` to `1`.\n    function setOpacity(el, value) {\n        if (\"opacity\" in el.style) {\n            el.style.opacity = value;\n        } else if (\"filter\" in el.style) {\n            _setOpacityIE(el, value);\n        }\n    }\n    function _setOpacityIE(el, value) {\n        var filter = false, filterName = \"DXImageTransform.Microsoft.Alpha\";\n        // filters collection throws an error if we try to retrieve a filter that doesn't exist\n        try {\n            filter = el.filters.item(filterName);\n        } catch (e) {\n            // don't set opacity to 1 if we haven't already set an opacity,\n            // it isn't needed and breaks transparent pngs.\n            if (value === 1) {\n                return;\n            }\n        }\n        value = Math.round(value * 100);\n        if (filter) {\n            filter.Enabled = value !== 100;\n            filter.Opacity = value;\n        } else {\n            el.style.filter += \" progid:\" + filterName + \"(opacity=\" + value + \")\";\n        }\n    }\n    // @function testProp(props: String[]): String|false\n    // Goes through the array of style names and returns the first name\n    // that is a valid style name for an element. If no such name is found,\n    // it returns false. Useful for vendor-prefixed styles like `transform`.\n    function testProp(props) {\n        var style = document.documentElement.style;\n        for(var i = 0; i < props.length; i++){\n            if (props[i] in style) {\n                return props[i];\n            }\n        }\n        return false;\n    }\n    // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\n    // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\n    // and optionally scaled by `scale`. Does not have an effect if the\n    // browser doesn't support 3D CSS transforms.\n    function setTransform(el, offset, scale) {\n        var pos = offset || new Point(0, 0);\n        el.style[TRANSFORM] = (Browser.ie3d ? \"translate(\" + pos.x + \"px,\" + pos.y + \"px)\" : \"translate3d(\" + pos.x + \"px,\" + pos.y + \"px,0)\") + (scale ? \" scale(\" + scale + \")\" : \"\");\n    }\n    // @function setPosition(el: HTMLElement, position: Point)\n    // Sets the position of `el` to coordinates specified by `position`,\n    // using CSS translate or top/left positioning depending on the browser\n    // (used by Leaflet internally to position its layers).\n    function setPosition(el, point) {\n        /*eslint-disable */ el._leaflet_pos = point;\n        /* eslint-enable */ if (Browser.any3d) {\n            setTransform(el, point);\n        } else {\n            el.style.left = point.x + \"px\";\n            el.style.top = point.y + \"px\";\n        }\n    }\n    // @function getPosition(el: HTMLElement): Point\n    // Returns the coordinates of an element previously positioned with setPosition.\n    function getPosition(el) {\n        // this method is only used for elements previously positioned using setPosition,\n        // so it's safe to cache the position for performance\n        return el._leaflet_pos || new Point(0, 0);\n    }\n    // @function disableTextSelection()\n    // Prevents the user from generating `selectstart` DOM events, usually generated\n    // when the user drags the mouse through a page with text. Used internally\n    // by Leaflet to override the behaviour of any click-and-drag interaction on\n    // the map. Affects drag interactions on the whole document.\n    // @function enableTextSelection()\n    // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\n    var disableTextSelection;\n    var enableTextSelection;\n    var _userSelect;\n    if (\"onselectstart\" in document) {\n        disableTextSelection = function() {\n            on(window, \"selectstart\", preventDefault);\n        };\n        enableTextSelection = function() {\n            off(window, \"selectstart\", preventDefault);\n        };\n    } else {\n        var userSelectProperty = testProp([\n            \"userSelect\",\n            \"WebkitUserSelect\",\n            \"OUserSelect\",\n            \"MozUserSelect\",\n            \"msUserSelect\"\n        ]);\n        disableTextSelection = function() {\n            if (userSelectProperty) {\n                var style = document.documentElement.style;\n                _userSelect = style[userSelectProperty];\n                style[userSelectProperty] = \"none\";\n            }\n        };\n        enableTextSelection = function() {\n            if (userSelectProperty) {\n                document.documentElement.style[userSelectProperty] = _userSelect;\n                _userSelect = undefined;\n            }\n        };\n    }\n    // @function disableImageDrag()\n    // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\n    // for `dragstart` DOM events, usually generated when the user drags an image.\n    function disableImageDrag() {\n        on(window, \"dragstart\", preventDefault);\n    }\n    // @function enableImageDrag()\n    // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\n    function enableImageDrag() {\n        off(window, \"dragstart\", preventDefault);\n    }\n    var _outlineElement, _outlineStyle;\n    // @function preventOutline(el: HTMLElement)\n    // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\n    // of the element `el` invisible. Used internally by Leaflet to prevent\n    // focusable elements from displaying an outline when the user performs a\n    // drag interaction on them.\n    function preventOutline(element) {\n        while(element.tabIndex === -1){\n            element = element.parentNode;\n        }\n        if (!element.style) {\n            return;\n        }\n        restoreOutline();\n        _outlineElement = element;\n        _outlineStyle = element.style.outlineStyle;\n        element.style.outlineStyle = \"none\";\n        on(window, \"keydown\", restoreOutline);\n    }\n    // @function restoreOutline()\n    // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\n    function restoreOutline() {\n        if (!_outlineElement) {\n            return;\n        }\n        _outlineElement.style.outlineStyle = _outlineStyle;\n        _outlineElement = undefined;\n        _outlineStyle = undefined;\n        off(window, \"keydown\", restoreOutline);\n    }\n    // @function getSizedParentNode(el: HTMLElement): HTMLElement\n    // Finds the closest parent node which size (width and height) is not null.\n    function getSizedParentNode(element) {\n        do {\n            element = element.parentNode;\n        }while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\n        return element;\n    }\n    // @function getScale(el: HTMLElement): Object\n    // Computes the CSS scale currently applied on the element.\n    // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\n    // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n    function getScale(element) {\n        var rect = element.getBoundingClientRect(); // Read-only in old browsers.\n        return {\n            x: rect.width / element.offsetWidth || 1,\n            y: rect.height / element.offsetHeight || 1,\n            boundingClientRect: rect\n        };\n    }\n    var DomUtil = {\n        __proto__: null,\n        TRANSFORM: TRANSFORM,\n        TRANSITION: TRANSITION,\n        TRANSITION_END: TRANSITION_END,\n        get: get,\n        getStyle: getStyle,\n        create: create$1,\n        remove: remove,\n        empty: empty,\n        toFront: toFront,\n        toBack: toBack,\n        hasClass: hasClass,\n        addClass: addClass,\n        removeClass: removeClass,\n        setClass: setClass,\n        getClass: getClass,\n        setOpacity: setOpacity,\n        testProp: testProp,\n        setTransform: setTransform,\n        setPosition: setPosition,\n        getPosition: getPosition,\n        get disableTextSelection () {\n            return disableTextSelection;\n        },\n        get enableTextSelection () {\n            return enableTextSelection;\n        },\n        disableImageDrag: disableImageDrag,\n        enableImageDrag: enableImageDrag,\n        preventOutline: preventOutline,\n        restoreOutline: restoreOutline,\n        getSizedParentNode: getSizedParentNode,\n        getScale: getScale\n    };\n    /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */ // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\n    // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\n    // Adds a listener function (`fn`) to a particular DOM event type of the\n    // element `el`. You can optionally specify the context of the listener\n    // (object the `this` keyword will point to). You can also pass several\n    // space-separated types (e.g. `'click dblclick'`).\n    // @alternative\n    // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\n    // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n    function on(obj, types, fn, context) {\n        if (types && typeof types === \"object\") {\n            for(var type in types){\n                addOne(obj, type, types[type], fn);\n            }\n        } else {\n            types = splitWords(types);\n            for(var i = 0, len = types.length; i < len; i++){\n                addOne(obj, types[i], fn, context);\n            }\n        }\n        return this;\n    }\n    var eventsKey = \"_leaflet_events\";\n    // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\n    // Removes a previously added listener function.\n    // Note that if you passed a custom context to on, you must pass the same\n    // context to `off` in order to remove the listener.\n    // @alternative\n    // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\n    // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\n    // @alternative\n    // @function off(el: HTMLElement, types: String): this\n    // Removes all previously added listeners of given types.\n    // @alternative\n    // @function off(el: HTMLElement): this\n    // Removes all previously added listeners from given HTMLElement\n    function off(obj, types, fn, context) {\n        if (arguments.length === 1) {\n            batchRemove(obj);\n            delete obj[eventsKey];\n        } else if (types && typeof types === \"object\") {\n            for(var type in types){\n                removeOne(obj, type, types[type], fn);\n            }\n        } else {\n            types = splitWords(types);\n            if (arguments.length === 2) {\n                batchRemove(obj, function(type) {\n                    return indexOf(types, type) !== -1;\n                });\n            } else {\n                for(var i = 0, len = types.length; i < len; i++){\n                    removeOne(obj, types[i], fn, context);\n                }\n            }\n        }\n        return this;\n    }\n    function batchRemove(obj, filterFn) {\n        for(var id in obj[eventsKey]){\n            var type = id.split(/\\d/)[0];\n            if (!filterFn || filterFn(type)) {\n                removeOne(obj, type, null, null, id);\n            }\n        }\n    }\n    var mouseSubst = {\n        mouseenter: \"mouseover\",\n        mouseleave: \"mouseout\",\n        wheel: !(\"onwheel\" in window) && \"mousewheel\"\n    };\n    function addOne(obj, type, fn, context) {\n        var id = type + stamp(fn) + (context ? \"_\" + stamp(context) : \"\");\n        if (obj[eventsKey] && obj[eventsKey][id]) {\n            return this;\n        }\n        var handler = function(e) {\n            return fn.call(context || obj, e || window.event);\n        };\n        var originalHandler = handler;\n        if (!Browser.touchNative && Browser.pointer && type.indexOf(\"touch\") === 0) {\n            // Needs DomEvent.Pointer.js\n            handler = addPointerListener(obj, type, handler);\n        } else if (Browser.touch && type === \"dblclick\") {\n            handler = addDoubleTapListener(obj, handler);\n        } else if (\"addEventListener\" in obj) {\n            if (type === \"touchstart\" || type === \"touchmove\" || type === \"wheel\" || type === \"mousewheel\") {\n                obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {\n                    passive: false\n                } : false);\n            } else if (type === \"mouseenter\" || type === \"mouseleave\") {\n                handler = function(e) {\n                    e = e || window.event;\n                    if (isExternalTarget(obj, e)) {\n                        originalHandler(e);\n                    }\n                };\n                obj.addEventListener(mouseSubst[type], handler, false);\n            } else {\n                obj.addEventListener(type, originalHandler, false);\n            }\n        } else {\n            obj.attachEvent(\"on\" + type, handler);\n        }\n        obj[eventsKey] = obj[eventsKey] || {};\n        obj[eventsKey][id] = handler;\n    }\n    function removeOne(obj, type, fn, context, id) {\n        id = id || type + stamp(fn) + (context ? \"_\" + stamp(context) : \"\");\n        var handler = obj[eventsKey] && obj[eventsKey][id];\n        if (!handler) {\n            return this;\n        }\n        if (!Browser.touchNative && Browser.pointer && type.indexOf(\"touch\") === 0) {\n            removePointerListener(obj, type, handler);\n        } else if (Browser.touch && type === \"dblclick\") {\n            removeDoubleTapListener(obj, handler);\n        } else if (\"removeEventListener\" in obj) {\n            obj.removeEventListener(mouseSubst[type] || type, handler, false);\n        } else {\n            obj.detachEvent(\"on\" + type, handler);\n        }\n        obj[eventsKey][id] = null;\n    }\n    // @function stopPropagation(ev: DOMEvent): this\n    // Stop the given event from propagation to parent elements. Used inside the listener functions:\n    // ```js\n    // L.DomEvent.on(div, 'click', function (ev) {\n    // \tL.DomEvent.stopPropagation(ev);\n    // });\n    // ```\n    function stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n        } else if (e.originalEvent) {\n            e.originalEvent._stopped = true;\n        } else {\n            e.cancelBubble = true;\n        }\n        return this;\n    }\n    // @function disableScrollPropagation(el: HTMLElement): this\n    // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\n    function disableScrollPropagation(el) {\n        addOne(el, \"wheel\", stopPropagation);\n        return this;\n    }\n    // @function disableClickPropagation(el: HTMLElement): this\n    // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,\n    // `'mousedown'` and `'touchstart'` events (plus browser variants).\n    function disableClickPropagation(el) {\n        on(el, \"mousedown touchstart dblclick contextmenu\", stopPropagation);\n        el[\"_leaflet_disable_click\"] = true;\n        return this;\n    }\n    // @function preventDefault(ev: DOMEvent): this\n    // Prevents the default action of the DOM Event `ev` from happening (such as\n    // following a link in the href of the a element, or doing a POST request\n    // with page reload when a `<form>` is submitted).\n    // Use it inside listener functions.\n    function preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            e.returnValue = false;\n        }\n        return this;\n    }\n    // @function stop(ev: DOMEvent): this\n    // Does `stopPropagation` and `preventDefault` at the same time.\n    function stop(e) {\n        preventDefault(e);\n        stopPropagation(e);\n        return this;\n    }\n    // @function getPropagationPath(ev: DOMEvent): Array\n    // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).\n    // Returns an array containing the `HTMLElement`s that the given DOM event\n    // should propagate to (if not stopped).\n    function getPropagationPath(ev) {\n        if (ev.composedPath) {\n            return ev.composedPath();\n        }\n        var path = [];\n        var el = ev.target;\n        while(el){\n            path.push(el);\n            el = el.parentNode;\n        }\n        return path;\n    }\n    // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\n    // Gets normalized mouse position from a DOM event relative to the\n    // `container` (border excluded) or to the whole page if not specified.\n    function getMousePosition(e, container) {\n        if (!container) {\n            return new Point(e.clientX, e.clientY);\n        }\n        var scale = getScale(container), offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\n        return new Point(// offset.left/top values are in page scale (like clientX/Y),\n        // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\n        (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);\n    }\n    //  except , Safari and\n    // We need double the scroll pixels (see #7403 and #4538) for all Browsers\n    // except OSX (Mac) -> 3x, Chrome running on Linux 1x\n    var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;\n    // @function getWheelDelta(ev: DOMEvent): Number\n    // Gets normalized wheel delta from a wheel DOM event, in vertical\n    // pixels scrolled (negative if scrolling down).\n    // Events from pointing devices without precise scrolling are mapped to\n    // a best guess of 60 pixels.\n    function getWheelDelta(e) {\n        return Browser.edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;\n    }\n    // check if element really left/entered the event target (for mouseenter/mouseleave)\n    function isExternalTarget(el, e) {\n        var related = e.relatedTarget;\n        if (!related) {\n            return true;\n        }\n        try {\n            while(related && related !== el){\n                related = related.parentNode;\n            }\n        } catch (err) {\n            return false;\n        }\n        return related !== el;\n    }\n    var DomEvent = {\n        __proto__: null,\n        on: on,\n        off: off,\n        stopPropagation: stopPropagation,\n        disableScrollPropagation: disableScrollPropagation,\n        disableClickPropagation: disableClickPropagation,\n        preventDefault: preventDefault,\n        stop: stop,\n        getPropagationPath: getPropagationPath,\n        getMousePosition: getMousePosition,\n        getWheelDelta: getWheelDelta,\n        isExternalTarget: isExternalTarget,\n        addListener: on,\n        removeListener: off\n    };\n    /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);\n   *\n   * myPositionMarker.on(\"click\", function() {\n   * \tvar pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());\n   * \tpos.y -= 25;\n   * \tvar fx = new L.PosAnimation();\n   *\n   * \tfx.once('end',function() {\n   * \t\tpos.y += 25;\n   * \t\tfx.run(myPositionMarker._icon, pos, 0.8);\n   * \t});\n   *\n   * \tfx.run(myPositionMarker._icon, pos, 0.3);\n   * });\n   *\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */ var PosAnimation = Evented.extend({\n        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n        // Run an animation of a given element to a new position, optionally setting\n        // duration in seconds (`0.25` by default) and easing linearity factor (3rd\n        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),\n        // `0.5` by default).\n        run: function(el, newPos, duration, easeLinearity) {\n            this.stop();\n            this._el = el;\n            this._inProgress = true;\n            this._duration = duration || 0.25;\n            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n            this._startPos = getPosition(el);\n            this._offset = newPos.subtract(this._startPos);\n            this._startTime = +new Date();\n            // @event start: Event\n            // Fired when the animation starts\n            this.fire(\"start\");\n            this._animate();\n        },\n        // @method stop()\n        // Stops the animation (if currently running).\n        stop: function() {\n            if (!this._inProgress) {\n                return;\n            }\n            this._step(true);\n            this._complete();\n        },\n        _animate: function() {\n            // animation loop\n            this._animId = requestAnimFrame(this._animate, this);\n            this._step();\n        },\n        _step: function(round) {\n            var elapsed = +new Date() - this._startTime, duration = this._duration * 1000;\n            if (elapsed < duration) {\n                this._runFrame(this._easeOut(elapsed / duration), round);\n            } else {\n                this._runFrame(1);\n                this._complete();\n            }\n        },\n        _runFrame: function(progress, round) {\n            var pos = this._startPos.add(this._offset.multiplyBy(progress));\n            if (round) {\n                pos._round();\n            }\n            setPosition(this._el, pos);\n            // @event step: Event\n            // Fired continuously during the animation.\n            this.fire(\"step\");\n        },\n        _complete: function() {\n            cancelAnimFrame(this._animId);\n            this._inProgress = false;\n            // @event end: Event\n            // Fired when the animation ends.\n            this.fire(\"end\");\n        },\n        _easeOut: function(t) {\n            return 1 - Math.pow(1 - t, this._easeOutPower);\n        }\n    });\n    /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API — it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */ var Map = Evented.extend({\n        options: {\n            // @section Map State Options\n            // @option crs: CRS = L.CRS.EPSG3857\n            // The [Coordinate Reference System](#crs) to use. Don't change this if you're not\n            // sure what it means.\n            crs: EPSG3857,\n            // @option center: LatLng = undefined\n            // Initial geographic center of the map\n            center: undefined,\n            // @option zoom: Number = undefined\n            // Initial map zoom level\n            zoom: undefined,\n            // @option minZoom: Number = *\n            // Minimum zoom level of the map.\n            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n            // the lowest of their `minZoom` options will be used instead.\n            minZoom: undefined,\n            // @option maxZoom: Number = *\n            // Maximum zoom level of the map.\n            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,\n            // the highest of their `maxZoom` options will be used instead.\n            maxZoom: undefined,\n            // @option layers: Layer[] = []\n            // Array of layers that will be added to the map initially\n            layers: [],\n            // @option maxBounds: LatLngBounds = null\n            // When this option is set, the map restricts the view to the given\n            // geographical bounds, bouncing the user back if the user tries to pan\n            // outside the view. To set the restriction dynamically, use\n            // [`setMaxBounds`](#map-setmaxbounds) method.\n            maxBounds: undefined,\n            // @option renderer: Renderer = *\n            // The default method for drawing vector layers on the map. `L.SVG`\n            // or `L.Canvas` by default depending on browser support.\n            renderer: undefined,\n            // @section Animation Options\n            // @option zoomAnimation: Boolean = true\n            // Whether the map zoom animation is enabled. By default it's enabled\n            // in all browsers that support CSS3 Transitions except Android.\n            zoomAnimation: true,\n            // @option zoomAnimationThreshold: Number = 4\n            // Won't animate zoom if the zoom difference exceeds this value.\n            zoomAnimationThreshold: 4,\n            // @option fadeAnimation: Boolean = true\n            // Whether the tile fade animation is enabled. By default it's enabled\n            // in all browsers that support CSS3 Transitions except Android.\n            fadeAnimation: true,\n            // @option markerZoomAnimation: Boolean = true\n            // Whether markers animate their zoom with the zoom animation, if disabled\n            // they will disappear for the length of the animation. By default it's\n            // enabled in all browsers that support CSS3 Transitions except Android.\n            markerZoomAnimation: true,\n            // @option transform3DLimit: Number = 2^23\n            // Defines the maximum size of a CSS translation transform. The default\n            // value should not be changed unless a web browser positions layers in\n            // the wrong place after doing a large `panBy`.\n            transform3DLimit: 8388608,\n            // @section Interaction Options\n            // @option zoomSnap: Number = 1\n            // Forces the map's zoom level to always be a multiple of this, particularly\n            // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\n            // By default, the zoom level snaps to the nearest integer; lower values\n            // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\n            // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\n            zoomSnap: 1,\n            // @option zoomDelta: Number = 1\n            // Controls how much the map's zoom level will change after a\n            // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\n            // or `-` on the keyboard, or using the [zoom controls](#control-zoom).\n            // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\n            zoomDelta: 1,\n            // @option trackResize: Boolean = true\n            // Whether the map automatically handles browser window resize to update itself.\n            trackResize: true\n        },\n        initialize: function(id, options) {\n            options = setOptions(this, options);\n            // Make sure to assign internal flags at the beginning,\n            // to avoid inconsistent state in some edge cases.\n            this._handlers = [];\n            this._layers = {};\n            this._zoomBoundLayers = {};\n            this._sizeChanged = true;\n            this._initContainer(id);\n            this._initLayout();\n            // hack for https://github.com/Leaflet/Leaflet/issues/1980\n            this._onResize = bind(this._onResize, this);\n            this._initEvents();\n            if (options.maxBounds) {\n                this.setMaxBounds(options.maxBounds);\n            }\n            if (options.zoom !== undefined) {\n                this._zoom = this._limitZoom(options.zoom);\n            }\n            if (options.center && options.zoom !== undefined) {\n                this.setView(toLatLng(options.center), options.zoom, {\n                    reset: true\n                });\n            }\n            this.callInitHooks();\n            // don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n            this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;\n            // zoom transitions run with the same duration for all layers, so if one of transitionend events\n            // happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n            if (this._zoomAnimated) {\n                this._createAnimProxy();\n                on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\n            }\n            this._addLayers(this.options.layers);\n        },\n        // @section Methods for modifying map state\n        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\n        // Sets the view of the map (geographical center and zoom) with the given\n        // animation options.\n        setView: function(center, zoom, options) {\n            zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n            center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\n            options = options || {};\n            this._stop();\n            if (this._loaded && !options.reset && options !== true) {\n                if (options.animate !== undefined) {\n                    options.zoom = extend({\n                        animate: options.animate\n                    }, options.zoom);\n                    options.pan = extend({\n                        animate: options.animate,\n                        duration: options.duration\n                    }, options.pan);\n                }\n                // try animating pan or zoom\n                var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);\n                if (moved) {\n                    // prevent resize handler call, the view will refresh after animation anyway\n                    clearTimeout(this._sizeTimer);\n                    return this;\n                }\n            }\n            // animation didn't start, just reset the map view\n            this._resetView(center, zoom, options.pan && options.pan.noMoveStart);\n            return this;\n        },\n        // @method setZoom(zoom: Number, options?: Zoom/pan options): this\n        // Sets the zoom of the map.\n        setZoom: function(zoom, options) {\n            if (!this._loaded) {\n                this._zoom = zoom;\n                return this;\n            }\n            return this.setView(this.getCenter(), zoom, {\n                zoom: options\n            });\n        },\n        // @method zoomIn(delta?: Number, options?: Zoom options): this\n        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n        zoomIn: function(delta, options) {\n            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n            return this.setZoom(this._zoom + delta, options);\n        },\n        // @method zoomOut(delta?: Number, options?: Zoom options): this\n        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\n        zoomOut: function(delta, options) {\n            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\n            return this.setZoom(this._zoom - delta, options);\n        },\n        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\n        // Zooms the map while keeping a specified geographical point on the map\n        // stationary (e.g. used internally for scroll zoom and double-click zoom).\n        // @alternative\n        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\n        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\n        setZoomAround: function(latlng, zoom, options) {\n            var scale = this.getZoomScale(zoom), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n            return this.setView(newCenter, zoom, {\n                zoom: options\n            });\n        },\n        _getBoundsCenterZoom: function(bounds, options) {\n            options = options || {};\n            bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [\n                0,\n                0\n            ]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [\n                0,\n                0\n            ]), zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n            zoom = typeof options.maxZoom === \"number\" ? Math.min(options.maxZoom, zoom) : zoom;\n            if (zoom === Infinity) {\n                return {\n                    center: bounds.getCenter(),\n                    zoom: zoom\n                };\n            }\n            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom), nePoint = this.project(bounds.getNorthEast(), zoom), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n            return {\n                center: center,\n                zoom: zoom\n            };\n        },\n        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\n        // Sets a map view that contains the given geographical bounds with the\n        // maximum zoom level possible.\n        fitBounds: function(bounds, options) {\n            bounds = toLatLngBounds(bounds);\n            if (!bounds.isValid()) {\n                throw new Error(\"Bounds are not valid.\");\n            }\n            var target = this._getBoundsCenterZoom(bounds, options);\n            return this.setView(target.center, target.zoom, options);\n        },\n        // @method fitWorld(options?: fitBounds options): this\n        // Sets a map view that mostly contains the whole world with the maximum\n        // zoom level possible.\n        fitWorld: function(options) {\n            return this.fitBounds([\n                [\n                    -90,\n                    -180\n                ],\n                [\n                    90,\n                    180\n                ]\n            ], options);\n        },\n        // @method panTo(latlng: LatLng, options?: Pan options): this\n        // Pans the map to a given center.\n        panTo: function(center, options) {\n            return this.setView(center, this._zoom, {\n                pan: options\n            });\n        },\n        // @method panBy(offset: Point, options?: Pan options): this\n        // Pans the map by a given number of pixels (animated).\n        panBy: function(offset, options) {\n            offset = toPoint(offset).round();\n            options = options || {};\n            if (!offset.x && !offset.y) {\n                return this.fire(\"moveend\");\n            }\n            // If we pan too far, Chrome gets issues with tiles\n            // and makes them disappear or appear in the wrong place (slightly offset) #2602\n            if (options.animate !== true && !this.getSize().contains(offset)) {\n                this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\n                return this;\n            }\n            if (!this._panAnim) {\n                this._panAnim = new PosAnimation();\n                this._panAnim.on({\n                    \"step\": this._onPanTransitionStep,\n                    \"end\": this._onPanTransitionEnd\n                }, this);\n            }\n            // don't fire movestart if animating inertia\n            if (!options.noMoveStart) {\n                this.fire(\"movestart\");\n            }\n            // animate pan unless animate: false specified\n            if (options.animate !== false) {\n                addClass(this._mapPane, \"leaflet-pan-anim\");\n                var newPos = this._getMapPanePos().subtract(offset).round();\n                this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n            } else {\n                this._rawPanBy(offset);\n                this.fire(\"move\").fire(\"moveend\");\n            }\n            return this;\n        },\n        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\n        // Sets the view of the map (geographical center and zoom) performing a smooth\n        // pan-zoom animation.\n        flyTo: function(targetCenter, targetZoom, options) {\n            options = options || {};\n            if (options.animate === false || !Browser.any3d) {\n                return this.setView(targetCenter, targetZoom, options);\n            }\n            this._stop();\n            var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;\n            targetCenter = toLatLng(targetCenter);\n            targetZoom = targetZoom === undefined ? startZoom : targetZoom;\n            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;\n            function r(i) {\n                var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;\n                // workaround for floating point precision bug when sq = 0, log = -Infinite,\n                // thus triggering an infinite loop in flyTo\n                var log = sq < 0.000000001 ? -18 : Math.log(sq);\n                return log;\n            }\n            function sinh(n) {\n                return (Math.exp(n) - Math.exp(-n)) / 2;\n            }\n            function cosh(n) {\n                return (Math.exp(n) + Math.exp(-n)) / 2;\n            }\n            function tanh(n) {\n                return sinh(n) / cosh(n);\n            }\n            var r0 = r(0);\n            function w(s) {\n                return w0 * (cosh(r0) / cosh(r0 + rho * s));\n            }\n            function u(s) {\n                return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;\n            }\n            function easeOut(t) {\n                return 1 - Math.pow(1 - t, 1.5);\n            }\n            var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\n            function frame() {\n                var t = (Date.now() - start) / duration, s = easeOut(t) * S;\n                if (t <= 1) {\n                    this._flyToFrame = requestAnimFrame(frame, this);\n                    this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {\n                        flyTo: true\n                    });\n                } else {\n                    this._move(targetCenter, targetZoom)._moveEnd(true);\n                }\n            }\n            this._moveStart(true, options.noMoveStart);\n            frame.call(this);\n            return this;\n        },\n        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n        flyToBounds: function(bounds, options) {\n            var target = this._getBoundsCenterZoom(bounds, options);\n            return this.flyTo(target.center, target.zoom, options);\n        },\n        // @method setMaxBounds(bounds: LatLngBounds): this\n        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\n        setMaxBounds: function(bounds) {\n            bounds = toLatLngBounds(bounds);\n            if (this.listens(\"moveend\", this._panInsideMaxBounds)) {\n                this.off(\"moveend\", this._panInsideMaxBounds);\n            }\n            if (!bounds.isValid()) {\n                this.options.maxBounds = null;\n                return this;\n            }\n            this.options.maxBounds = bounds;\n            if (this._loaded) {\n                this._panInsideMaxBounds();\n            }\n            return this.on(\"moveend\", this._panInsideMaxBounds);\n        },\n        // @method setMinZoom(zoom: Number): this\n        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\n        setMinZoom: function(zoom) {\n            var oldZoom = this.options.minZoom;\n            this.options.minZoom = zoom;\n            if (this._loaded && oldZoom !== zoom) {\n                this.fire(\"zoomlevelschange\");\n                if (this.getZoom() < this.options.minZoom) {\n                    return this.setZoom(zoom);\n                }\n            }\n            return this;\n        },\n        // @method setMaxZoom(zoom: Number): this\n        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\n        setMaxZoom: function(zoom) {\n            var oldZoom = this.options.maxZoom;\n            this.options.maxZoom = zoom;\n            if (this._loaded && oldZoom !== zoom) {\n                this.fire(\"zoomlevelschange\");\n                if (this.getZoom() > this.options.maxZoom) {\n                    return this.setZoom(zoom);\n                }\n            }\n            return this;\n        },\n        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\n        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\n        panInsideBounds: function(bounds, options) {\n            this._enforcingBounds = true;\n            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\n            if (!center.equals(newCenter)) {\n                this.panTo(newCenter, options);\n            }\n            this._enforcingBounds = false;\n            return this;\n        },\n        // @method panInside(latlng: LatLng, options?: padding options): this\n        // Pans the map the minimum amount to make the `latlng` visible. Use\n        // padding options to fit the display to more restricted bounds.\n        // If `latlng` is already within the (optionally padded) display bounds,\n        // the map will not be panned.\n        panInside: function(latlng, options) {\n            options = options || {};\n            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [\n                0,\n                0\n            ]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [\n                0,\n                0\n            ]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([\n                pixelBounds.min.add(paddingTL),\n                pixelBounds.max.subtract(paddingBR)\n            ]), paddedSize = paddedBounds.getSize();\n            if (!paddedBounds.contains(pixelPoint)) {\n                this._enforcingBounds = true;\n                var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\n                var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\n                pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\n                pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\n                this.panTo(this.unproject(pixelCenter), options);\n                this._enforcingBounds = false;\n            }\n            return this;\n        },\n        // @method invalidateSize(options: Zoom/pan options): this\n        // Checks if the map container size changed and updates the map if so —\n        // call it after you've changed the map size dynamically, also animating\n        // pan by default. If `options.pan` is `false`, panning will not occur.\n        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so\n        // that it doesn't happen often even if the method is called many\n        // times in a row.\n        // @alternative\n        // @method invalidateSize(animate: Boolean): this\n        // Checks if the map container size changed and updates the map if so —\n        // call it after you've changed the map size dynamically, also animating\n        // pan by default.\n        invalidateSize: function(options) {\n            if (!this._loaded) {\n                return this;\n            }\n            options = extend({\n                animate: false,\n                pan: true\n            }, options === true ? {\n                animate: true\n            } : options);\n            var oldSize = this.getSize();\n            this._sizeChanged = true;\n            this._lastCenter = null;\n            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);\n            if (!offset.x && !offset.y) {\n                return this;\n            }\n            if (options.animate && options.pan) {\n                this.panBy(offset);\n            } else {\n                if (options.pan) {\n                    this._rawPanBy(offset);\n                }\n                this.fire(\"move\");\n                if (options.debounceMoveend) {\n                    clearTimeout(this._sizeTimer);\n                    this._sizeTimer = setTimeout(bind(this.fire, this, \"moveend\"), 200);\n                } else {\n                    this.fire(\"moveend\");\n                }\n            }\n            // @section Map state change events\n            // @event resize: ResizeEvent\n            // Fired when the map is resized.\n            return this.fire(\"resize\", {\n                oldSize: oldSize,\n                newSize: newSize\n            });\n        },\n        // @section Methods for modifying map state\n        // @method stop(): this\n        // Stops the currently running `panTo` or `flyTo` animation, if any.\n        stop: function() {\n            this.setZoom(this._limitZoom(this._zoom));\n            if (!this.options.zoomSnap) {\n                this.fire(\"viewreset\");\n            }\n            return this._stop();\n        },\n        // @section Geolocation methods\n        // @method locate(options?: Locate options): this\n        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\n        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\n        // and optionally sets the map view to the user's location with respect to\n        // detection accuracy (or to the world view if geolocation failed).\n        // Note that, if your page doesn't use HTTPS, this method will fail in\n        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\n        // See `Locate options` for more details.\n        locate: function(options) {\n            options = this._locateOptions = extend({\n                timeout: 10000,\n                watch: false\n            }, options);\n            if (!(\"geolocation\" in navigator)) {\n                this._handleGeolocationError({\n                    code: 0,\n                    message: \"Geolocation not supported.\"\n                });\n                return this;\n            }\n            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);\n            if (options.watch) {\n                this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);\n            } else {\n                navigator.geolocation.getCurrentPosition(onResponse, onError, options);\n            }\n            return this;\n        },\n        // @method stopLocate(): this\n        // Stops watching location previously initiated by `map.locate({watch: true})`\n        // and aborts resetting the map view if map.locate was called with\n        // `{setView: true}`.\n        stopLocate: function() {\n            if (navigator.geolocation && navigator.geolocation.clearWatch) {\n                navigator.geolocation.clearWatch(this._locationWatchId);\n            }\n            if (this._locateOptions) {\n                this._locateOptions.setView = false;\n            }\n            return this;\n        },\n        _handleGeolocationError: function(error) {\n            if (!this._container._leaflet_id) {\n                return;\n            }\n            var c = error.code, message = error.message || (c === 1 ? \"permission denied\" : c === 2 ? \"position unavailable\" : \"timeout\");\n            if (this._locateOptions.setView && !this._loaded) {\n                this.fitWorld();\n            }\n            // @section Location events\n            // @event locationerror: ErrorEvent\n            // Fired when geolocation (using the [`locate`](#map-locate) method) failed.\n            this.fire(\"locationerror\", {\n                code: c,\n                message: \"Geolocation error: \" + message + \".\"\n            });\n        },\n        _handleGeolocationResponse: function(pos) {\n            if (!this._container._leaflet_id) {\n                return;\n            }\n            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;\n            if (options.setView) {\n                var zoom = this.getBoundsZoom(bounds);\n                this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n            }\n            var data = {\n                latlng: latlng,\n                bounds: bounds,\n                timestamp: pos.timestamp\n            };\n            for(var i in pos.coords){\n                if (typeof pos.coords[i] === \"number\") {\n                    data[i] = pos.coords[i];\n                }\n            }\n            // @event locationfound: LocationEvent\n            // Fired when geolocation (using the [`locate`](#map-locate) method)\n            // went successfully.\n            this.fire(\"locationfound\", data);\n        },\n        // TODO Appropriate docs section?\n        // @section Other Methods\n        // @method addHandler(name: String, HandlerClass: Function): this\n        // Adds a new `Handler` to the map, given its name and constructor function.\n        addHandler: function(name, HandlerClass) {\n            if (!HandlerClass) {\n                return this;\n            }\n            var handler = this[name] = new HandlerClass(this);\n            this._handlers.push(handler);\n            if (this.options[name]) {\n                handler.enable();\n            }\n            return this;\n        },\n        // @method remove(): this\n        // Destroys the map and clears all related event listeners.\n        remove: function() {\n            this._initEvents(true);\n            if (this.options.maxBounds) {\n                this.off(\"moveend\", this._panInsideMaxBounds);\n            }\n            if (this._containerId !== this._container._leaflet_id) {\n                throw new Error(\"Map container is being reused by another instance\");\n            }\n            try {\n                // throws error in IE6-8\n                delete this._container._leaflet_id;\n                delete this._containerId;\n            } catch (e) {\n                /*eslint-disable */ this._container._leaflet_id = undefined;\n                /* eslint-enable */ this._containerId = undefined;\n            }\n            if (this._locationWatchId !== undefined) {\n                this.stopLocate();\n            }\n            this._stop();\n            remove(this._mapPane);\n            if (this._clearControlPos) {\n                this._clearControlPos();\n            }\n            if (this._resizeRequest) {\n                cancelAnimFrame(this._resizeRequest);\n                this._resizeRequest = null;\n            }\n            this._clearHandlers();\n            if (this._loaded) {\n                // @section Map state change events\n                // @event unload: Event\n                // Fired when the map is destroyed with [remove](#map-remove) method.\n                this.fire(\"unload\");\n            }\n            var i;\n            for(i in this._layers){\n                this._layers[i].remove();\n            }\n            for(i in this._panes){\n                remove(this._panes[i]);\n            }\n            this._layers = [];\n            this._panes = [];\n            delete this._mapPane;\n            delete this._renderer;\n            return this;\n        },\n        // @section Other Methods\n        // @method createPane(name: String, container?: HTMLElement): HTMLElement\n        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\n        // then returns it. The pane is created as a child of `container`, or\n        // as a child of the main map pane if not set.\n        createPane: function(name, container) {\n            var className = \"leaflet-pane\" + (name ? \" leaflet-\" + name.replace(\"Pane\", \"\") + \"-pane\" : \"\"), pane = create$1(\"div\", className, container || this._mapPane);\n            if (name) {\n                this._panes[name] = pane;\n            }\n            return pane;\n        },\n        // @section Methods for Getting Map State\n        // @method getCenter(): LatLng\n        // Returns the geographical center of the map view\n        getCenter: function() {\n            this._checkIfLoaded();\n            if (this._lastCenter && !this._moved()) {\n                return this._lastCenter.clone();\n            }\n            return this.layerPointToLatLng(this._getCenterLayerPoint());\n        },\n        // @method getZoom(): Number\n        // Returns the current zoom level of the map view\n        getZoom: function() {\n            return this._zoom;\n        },\n        // @method getBounds(): LatLngBounds\n        // Returns the geographical bounds visible in the current map view\n        getBounds: function() {\n            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());\n            return new LatLngBounds(sw, ne);\n        },\n        // @method getMinZoom(): Number\n        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\n        getMinZoom: function() {\n            return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\n        },\n        // @method getMaxZoom(): Number\n        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\n        getMaxZoom: function() {\n            return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;\n        },\n        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\n        // Returns the maximum zoom level on which the given bounds fit to the map\n        // view in its entirety. If `inside` (optional) is set to `true`, the method\n        // instead returns the minimum zoom level on which the map view fits into\n        // the given bounds in its entirety.\n        getBoundsZoom: function(bounds, inside, padding) {\n            bounds = toLatLngBounds(bounds);\n            padding = toPoint(padding || [\n                0,\n                0\n            ]);\n            var zoom = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n            zoom = this.getScaleZoom(scale, zoom);\n            if (snap) {\n                zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n                zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n            }\n            return Math.max(min, Math.min(max, zoom));\n        },\n        // @method getSize(): Point\n        // Returns the current size of the map container (in pixels).\n        getSize: function() {\n            if (!this._size || this._sizeChanged) {\n                this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);\n                this._sizeChanged = false;\n            }\n            return this._size.clone();\n        },\n        // @method getPixelBounds(): Bounds\n        // Returns the bounds of the current map view in projected pixel\n        // coordinates (sometimes useful in layer and overlay implementations).\n        getPixelBounds: function(center, zoom) {\n            var topLeftPoint = this._getTopLeftPoint(center, zoom);\n            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n        },\n        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\n        // the map pane? \"left point of the map layer\" can be confusing, specially\n        // since there can be negative offsets.\n        // @method getPixelOrigin(): Point\n        // Returns the projected pixel coordinates of the top left point of\n        // the map layer (useful in custom layer and overlay implementations).\n        getPixelOrigin: function() {\n            this._checkIfLoaded();\n            return this._pixelOrigin;\n        },\n        // @method getPixelWorldBounds(zoom?: Number): Bounds\n        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.\n        // If `zoom` is omitted, the map's current zoom level is used.\n        getPixelWorldBounds: function(zoom) {\n            return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\n        },\n        // @section Other Methods\n        // @method getPane(pane: String|HTMLElement): HTMLElement\n        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\n        getPane: function(pane) {\n            return typeof pane === \"string\" ? this._panes[pane] : pane;\n        },\n        // @method getPanes(): Object\n        // Returns a plain object containing the names of all [panes](#map-pane) as keys and\n        // the panes as values.\n        getPanes: function() {\n            return this._panes;\n        },\n        // @method getContainer: HTMLElement\n        // Returns the HTML element that contains the map.\n        getContainer: function() {\n            return this._container;\n        },\n        // @section Conversion Methods\n        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number\n        // Returns the scale factor to be applied to a map transition from zoom level\n        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.\n        getZoomScale: function(toZoom, fromZoom) {\n            // TODO replace with universal implementation after refactoring projections\n            var crs = this.options.crs;\n            fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n            return crs.scale(toZoom) / crs.scale(fromZoom);\n        },\n        // @method getScaleZoom(scale: Number, fromZoom: Number): Number\n        // Returns the zoom level that the map would end up at, if it is at `fromZoom`\n        // level and everything is scaled by a factor of `scale`. Inverse of\n        // [`getZoomScale`](#map-getZoomScale).\n        getScaleZoom: function(scale, fromZoom) {\n            var crs = this.options.crs;\n            fromZoom = fromZoom === undefined ? this._zoom : fromZoom;\n            var zoom = crs.zoom(scale * crs.scale(fromZoom));\n            return isNaN(zoom) ? Infinity : zoom;\n        },\n        // @method project(latlng: LatLng, zoom: Number): Point\n        // Projects a geographical coordinate `LatLng` according to the projection\n        // of the map's CRS, then scales it according to `zoom` and the CRS's\n        // `Transformation`. The result is pixel coordinate relative to\n        // the CRS origin.\n        project: function(latlng, zoom) {\n            zoom = zoom === undefined ? this._zoom : zoom;\n            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\n        },\n        // @method unproject(point: Point, zoom: Number): LatLng\n        // Inverse of [`project`](#map-project).\n        unproject: function(point, zoom) {\n            zoom = zoom === undefined ? this._zoom : zoom;\n            return this.options.crs.pointToLatLng(toPoint(point), zoom);\n        },\n        // @method layerPointToLatLng(point: Point): LatLng\n        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n        // returns the corresponding geographical coordinate (for the current zoom level).\n        layerPointToLatLng: function(point) {\n            var projectedPoint = toPoint(point).add(this.getPixelOrigin());\n            return this.unproject(projectedPoint);\n        },\n        // @method latLngToLayerPoint(latlng: LatLng): Point\n        // Given a geographical coordinate, returns the corresponding pixel coordinate\n        // relative to the [origin pixel](#map-getpixelorigin).\n        latLngToLayerPoint: function(latlng) {\n            var projectedPoint = this.project(toLatLng(latlng))._round();\n            return projectedPoint._subtract(this.getPixelOrigin());\n        },\n        // @method wrapLatLng(latlng: LatLng): LatLng\n        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\n        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\n        // CRS's bounds.\n        // By default this means longitude is wrapped around the dateline so its\n        // value is between -180 and +180 degrees.\n        wrapLatLng: function(latlng) {\n            return this.options.crs.wrapLatLng(toLatLng(latlng));\n        },\n        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\n        // Returns a `LatLngBounds` with the same size as the given one, ensuring that\n        // its center is within the CRS's bounds.\n        // By default this means the center longitude is wrapped around the dateline so its\n        // value is between -180 and +180 degrees, and the majority of the bounds\n        // overlaps the CRS's bounds.\n        wrapLatLngBounds: function(latlng) {\n            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\n        },\n        // @method distance(latlng1: LatLng, latlng2: LatLng): Number\n        // Returns the distance between two geographical coordinates according to\n        // the map's CRS. By default this measures distance in meters.\n        distance: function(latlng1, latlng2) {\n            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\n        },\n        // @method containerPointToLayerPoint(point: Point): Point\n        // Given a pixel coordinate relative to the map container, returns the corresponding\n        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\n        containerPointToLayerPoint: function(point) {\n            return toPoint(point).subtract(this._getMapPanePos());\n        },\n        // @method layerPointToContainerPoint(point: Point): Point\n        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n        // returns the corresponding pixel coordinate relative to the map container.\n        layerPointToContainerPoint: function(point) {\n            return toPoint(point).add(this._getMapPanePos());\n        },\n        // @method containerPointToLatLng(point: Point): LatLng\n        // Given a pixel coordinate relative to the map container, returns\n        // the corresponding geographical coordinate (for the current zoom level).\n        containerPointToLatLng: function(point) {\n            var layerPoint = this.containerPointToLayerPoint(toPoint(point));\n            return this.layerPointToLatLng(layerPoint);\n        },\n        // @method latLngToContainerPoint(latlng: LatLng): Point\n        // Given a geographical coordinate, returns the corresponding pixel coordinate\n        // relative to the map container.\n        latLngToContainerPoint: function(latlng) {\n            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n        },\n        // @method mouseEventToContainerPoint(ev: MouseEvent): Point\n        // Given a MouseEvent object, returns the pixel coordinate relative to the\n        // map container where the event took place.\n        mouseEventToContainerPoint: function(e) {\n            return getMousePosition(e, this._container);\n        },\n        // @method mouseEventToLayerPoint(ev: MouseEvent): Point\n        // Given a MouseEvent object, returns the pixel coordinate relative to\n        // the [origin pixel](#map-getpixelorigin) where the event took place.\n        mouseEventToLayerPoint: function(e) {\n            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n        },\n        // @method mouseEventToLatLng(ev: MouseEvent): LatLng\n        // Given a MouseEvent object, returns geographical coordinate where the\n        // event took place.\n        mouseEventToLatLng: function(e) {\n            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n        },\n        // map initialization methods\n        _initContainer: function(id) {\n            var container = this._container = get(id);\n            if (!container) {\n                throw new Error(\"Map container not found.\");\n            } else if (container._leaflet_id) {\n                throw new Error(\"Map container is already initialized.\");\n            }\n            on(container, \"scroll\", this._onScroll, this);\n            this._containerId = stamp(container);\n        },\n        _initLayout: function() {\n            var container = this._container;\n            this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\n            addClass(container, \"leaflet-container\" + (Browser.touch ? \" leaflet-touch\" : \"\") + (Browser.retina ? \" leaflet-retina\" : \"\") + (Browser.ielt9 ? \" leaflet-oldie\" : \"\") + (Browser.safari ? \" leaflet-safari\" : \"\") + (this._fadeAnimated ? \" leaflet-fade-anim\" : \"\"));\n            var position = getStyle(container, \"position\");\n            if (position !== \"absolute\" && position !== \"relative\" && position !== \"fixed\" && position !== \"sticky\") {\n                container.style.position = \"relative\";\n            }\n            this._initPanes();\n            if (this._initControlPos) {\n                this._initControlPos();\n            }\n        },\n        _initPanes: function() {\n            var panes = this._panes = {};\n            this._paneRenderers = {};\n            // @section\n            //\n            // Panes are DOM elements used to control the ordering of layers on the map. You\n            // can access panes with [`map.getPane`](#map-getpane) or\n            // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n            // [`map.createPane`](#map-createpane) method.\n            //\n            // Every map has the following default panes that differ only in zIndex.\n            //\n            // @pane mapPane: HTMLElement = 'auto'\n            // Pane that contains all other map panes\n            this._mapPane = this.createPane(\"mapPane\", this._container);\n            setPosition(this._mapPane, new Point(0, 0));\n            // @pane tilePane: HTMLElement = 200\n            // Pane for `GridLayer`s and `TileLayer`s\n            this.createPane(\"tilePane\");\n            // @pane overlayPane: HTMLElement = 400\n            // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\n            this.createPane(\"overlayPane\");\n            // @pane shadowPane: HTMLElement = 500\n            // Pane for overlay shadows (e.g. `Marker` shadows)\n            this.createPane(\"shadowPane\");\n            // @pane markerPane: HTMLElement = 600\n            // Pane for `Icon`s of `Marker`s\n            this.createPane(\"markerPane\");\n            // @pane tooltipPane: HTMLElement = 650\n            // Pane for `Tooltip`s.\n            this.createPane(\"tooltipPane\");\n            // @pane popupPane: HTMLElement = 700\n            // Pane for `Popup`s.\n            this.createPane(\"popupPane\");\n            if (!this.options.markerZoomAnimation) {\n                addClass(panes.markerPane, \"leaflet-zoom-hide\");\n                addClass(panes.shadowPane, \"leaflet-zoom-hide\");\n            }\n        },\n        // private methods that modify map state\n        // @section Map state change events\n        _resetView: function(center, zoom, noMoveStart) {\n            setPosition(this._mapPane, new Point(0, 0));\n            var loading = !this._loaded;\n            this._loaded = true;\n            zoom = this._limitZoom(zoom);\n            this.fire(\"viewprereset\");\n            var zoomChanged = this._zoom !== zoom;\n            this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);\n            // @event viewreset: Event\n            // Fired when the map needs to redraw its content (this usually happens\n            // on map zoom or load). Very useful for creating custom overlays.\n            this.fire(\"viewreset\");\n            // @event load: Event\n            // Fired when the map is initialized (when its center and zoom are set\n            // for the first time).\n            if (loading) {\n                this.fire(\"load\");\n            }\n        },\n        _moveStart: function(zoomChanged, noMoveStart) {\n            // @event zoomstart: Event\n            // Fired when the map zoom is about to change (e.g. before zoom animation).\n            // @event movestart: Event\n            // Fired when the view of the map starts changing (e.g. user starts dragging the map).\n            if (zoomChanged) {\n                this.fire(\"zoomstart\");\n            }\n            if (!noMoveStart) {\n                this.fire(\"movestart\");\n            }\n            return this;\n        },\n        _move: function(center, zoom, data, supressEvent) {\n            if (zoom === undefined) {\n                zoom = this._zoom;\n            }\n            var zoomChanged = this._zoom !== zoom;\n            this._zoom = zoom;\n            this._lastCenter = center;\n            this._pixelOrigin = this._getNewPixelOrigin(center);\n            if (!supressEvent) {\n                // @event zoom: Event\n                // Fired repeatedly during any change in zoom level,\n                // including zoom and fly animations.\n                if (zoomChanged || data && data.pinch) {\n                    this.fire(\"zoom\", data);\n                }\n                // @event move: Event\n                // Fired repeatedly during any movement of the map,\n                // including pan and fly animations.\n                this.fire(\"move\", data);\n            } else if (data && data.pinch) {\n                this.fire(\"zoom\", data);\n            }\n            return this;\n        },\n        _moveEnd: function(zoomChanged) {\n            // @event zoomend: Event\n            // Fired when the map zoom changed, after any animations.\n            if (zoomChanged) {\n                this.fire(\"zoomend\");\n            }\n            // @event moveend: Event\n            // Fired when the center of the map stops changing\n            // (e.g. user stopped dragging the map or after non-centered zoom).\n            return this.fire(\"moveend\");\n        },\n        _stop: function() {\n            cancelAnimFrame(this._flyToFrame);\n            if (this._panAnim) {\n                this._panAnim.stop();\n            }\n            return this;\n        },\n        _rawPanBy: function(offset) {\n            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n        },\n        _getZoomSpan: function() {\n            return this.getMaxZoom() - this.getMinZoom();\n        },\n        _panInsideMaxBounds: function() {\n            if (!this._enforcingBounds) {\n                this.panInsideBounds(this.options.maxBounds);\n            }\n        },\n        _checkIfLoaded: function() {\n            if (!this._loaded) {\n                throw new Error(\"Set map center and zoom first.\");\n            }\n        },\n        // DOM event handling\n        // @section Interaction events\n        _initEvents: function(remove) {\n            this._targets = {};\n            this._targets[stamp(this._container)] = this;\n            var onOff = remove ? off : on;\n            // @event click: MouseEvent\n            // Fired when the user clicks (or taps) the map.\n            // @event dblclick: MouseEvent\n            // Fired when the user double-clicks (or double-taps) the map.\n            // @event mousedown: MouseEvent\n            // Fired when the user pushes the mouse button on the map.\n            // @event mouseup: MouseEvent\n            // Fired when the user releases the mouse button on the map.\n            // @event mouseover: MouseEvent\n            // Fired when the mouse enters the map.\n            // @event mouseout: MouseEvent\n            // Fired when the mouse leaves the map.\n            // @event mousemove: MouseEvent\n            // Fired while the mouse moves over the map.\n            // @event contextmenu: MouseEvent\n            // Fired when the user pushes the right mouse button on the map, prevents\n            // default browser context menu from showing if there are listeners on\n            // this event. Also fired on mobile when the user holds a single touch\n            // for a second (also called long press).\n            // @event keypress: KeyboardEvent\n            // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\n            // @event keydown: KeyboardEvent\n            // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\n            // the `keydown` event is fired for keys that produce a character value and for keys\n            // that do not produce a character value.\n            // @event keyup: KeyboardEvent\n            // Fired when the user releases a key from the keyboard while the map is focused.\n            onOff(this._container, \"click dblclick mousedown mouseup \" + \"mouseover mouseout mousemove contextmenu keypress keydown keyup\", this._handleDOMEvent, this);\n            if (this.options.trackResize) {\n                onOff(window, \"resize\", this._onResize, this);\n            }\n            if (Browser.any3d && this.options.transform3DLimit) {\n                (remove ? this.off : this.on).call(this, \"moveend\", this._onMoveEnd);\n            }\n        },\n        _onResize: function() {\n            cancelAnimFrame(this._resizeRequest);\n            this._resizeRequest = requestAnimFrame(function() {\n                this.invalidateSize({\n                    debounceMoveend: true\n                });\n            }, this);\n        },\n        _onScroll: function() {\n            this._container.scrollTop = 0;\n            this._container.scrollLeft = 0;\n        },\n        _onMoveEnd: function() {\n            var pos = this._getMapPanePos();\n            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\n                // a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\n                this._resetView(this.getCenter(), this.getZoom());\n            }\n        },\n        _findEventTargets: function(e, type) {\n            var targets = [], target, isHover = type === \"mouseout\" || type === \"mouseover\", src = e.target || e.srcElement, dragging = false;\n            while(src){\n                target = this._targets[stamp(src)];\n                if (target && (type === \"click\" || type === \"preclick\") && this._draggableMoved(target)) {\n                    // Prevent firing click after you just dragged an object.\n                    dragging = true;\n                    break;\n                }\n                if (target && target.listens(type, true)) {\n                    if (isHover && !isExternalTarget(src, e)) {\n                        break;\n                    }\n                    targets.push(target);\n                    if (isHover) {\n                        break;\n                    }\n                }\n                if (src === this._container) {\n                    break;\n                }\n                src = src.parentNode;\n            }\n            if (!targets.length && !dragging && !isHover && this.listens(type, true)) {\n                targets = [\n                    this\n                ];\n            }\n            return targets;\n        },\n        _isClickDisabled: function(el) {\n            while(el && el !== this._container){\n                if (el[\"_leaflet_disable_click\"]) {\n                    return true;\n                }\n                el = el.parentNode;\n            }\n        },\n        _handleDOMEvent: function(e) {\n            var el = e.target || e.srcElement;\n            if (!this._loaded || el[\"_leaflet_disable_events\"] || e.type === \"click\" && this._isClickDisabled(el)) {\n                return;\n            }\n            var type = e.type;\n            if (type === \"mousedown\") {\n                // prevents outline when clicking on keyboard-focusable element\n                preventOutline(el);\n            }\n            this._fireDOMEvent(e, type);\n        },\n        _mouseEvents: [\n            \"click\",\n            \"dblclick\",\n            \"mouseover\",\n            \"mouseout\",\n            \"contextmenu\"\n        ],\n        _fireDOMEvent: function(e, type, canvasTargets) {\n            if (e.type === \"click\") {\n                // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\n                // @event preclick: MouseEvent\n                // Fired before mouse click on the map (sometimes useful when you\n                // want something to happen on click before any existing click\n                // handlers start running).\n                var synth = extend({}, e);\n                synth.type = \"preclick\";\n                this._fireDOMEvent(synth, synth.type, canvasTargets);\n            }\n            // Find the layer the event is propagating from and its parents.\n            var targets = this._findEventTargets(e, type);\n            if (canvasTargets) {\n                var filtered = []; // pick only targets with listeners\n                for(var i = 0; i < canvasTargets.length; i++){\n                    if (canvasTargets[i].listens(type, true)) {\n                        filtered.push(canvasTargets[i]);\n                    }\n                }\n                targets = filtered.concat(targets);\n            }\n            if (!targets.length) {\n                return;\n            }\n            if (type === \"contextmenu\") {\n                preventDefault(e);\n            }\n            var target = targets[0];\n            var data = {\n                originalEvent: e\n            };\n            if (e.type !== \"keypress\" && e.type !== \"keydown\" && e.type !== \"keyup\") {\n                var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\n                data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\n                data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\n                data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\n            }\n            for(i = 0; i < targets.length; i++){\n                targets[i].fire(type, data, true);\n                if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {\n                    return;\n                }\n            }\n        },\n        _draggableMoved: function(obj) {\n            obj = obj.dragging && obj.dragging.enabled() ? obj : this;\n            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n        },\n        _clearHandlers: function() {\n            for(var i = 0, len = this._handlers.length; i < len; i++){\n                this._handlers[i].disable();\n            }\n        },\n        // @section Other Methods\n        // @method whenReady(fn: Function, context?: Object): this\n        // Runs the given function `fn` when the map gets initialized with\n        // a view (center and zoom) and at least one layer, or immediately\n        // if it's already initialized, optionally passing a function context.\n        whenReady: function(callback, context) {\n            if (this._loaded) {\n                callback.call(context || this, {\n                    target: this\n                });\n            } else {\n                this.on(\"load\", callback, context);\n            }\n            return this;\n        },\n        // private methods for getting map state\n        _getMapPanePos: function() {\n            return getPosition(this._mapPane) || new Point(0, 0);\n        },\n        _moved: function() {\n            var pos = this._getMapPanePos();\n            return pos && !pos.equals([\n                0,\n                0\n            ]);\n        },\n        _getTopLeftPoint: function(center, zoom) {\n            var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();\n            return pixelOrigin.subtract(this._getMapPanePos());\n        },\n        _getNewPixelOrigin: function(center, zoom) {\n            var viewHalf = this.getSize()._divideBy(2);\n            return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\n        },\n        _latLngToNewLayerPoint: function(latlng, zoom, center) {\n            var topLeft = this._getNewPixelOrigin(center, zoom);\n            return this.project(latlng, zoom)._subtract(topLeft);\n        },\n        _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom, center) {\n            var topLeft = this._getNewPixelOrigin(center, zoom);\n            return toBounds([\n                this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),\n                this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),\n                this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),\n                this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)\n            ]);\n        },\n        // layer point of the current center\n        _getCenterLayerPoint: function() {\n            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n        },\n        // offset of the specified place to the current center in pixels\n        _getCenterOffset: function(latlng) {\n            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n        },\n        // adjust center for view to get inside bounds\n        _limitCenter: function(center, zoom, bounds) {\n            if (!bounds) {\n                return center;\n            }\n            var centerPoint = this.project(center, zoom), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n            // If offset is less than a pixel, ignore.\n            // This prevents unstable projections from getting into\n            // an infinite loop of tiny offsets.\n            if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\n                return center;\n            }\n            return this.unproject(centerPoint.add(offset), zoom);\n        },\n        // adjust offset for view to get inside bounds\n        _limitOffset: function(offset, bounds) {\n            if (!bounds) {\n                return offset;\n            }\n            var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n            return offset.add(this._getBoundsOffset(newBounds, bounds));\n        },\n        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n        _getBoundsOffset: function(pxBounds, maxBounds, zoom) {\n            var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);\n            return new Point(dx, dy);\n        },\n        _rebound: function(left, right) {\n            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n        },\n        _limitZoom: function(zoom) {\n            var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;\n            if (snap) {\n                zoom = Math.round(zoom / snap) * snap;\n            }\n            return Math.max(min, Math.min(max, zoom));\n        },\n        _onPanTransitionStep: function() {\n            this.fire(\"move\");\n        },\n        _onPanTransitionEnd: function() {\n            removeClass(this._mapPane, \"leaflet-pan-anim\");\n            this.fire(\"moveend\");\n        },\n        _tryAnimatedPan: function(center, options) {\n            // difference between the new and current centers in pixels\n            var offset = this._getCenterOffset(center)._trunc();\n            // don't animate too far unless animate: true specified in options\n            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {\n                return false;\n            }\n            this.panBy(offset, options);\n            return true;\n        },\n        _createAnimProxy: function() {\n            var proxy = this._proxy = create$1(\"div\", \"leaflet-proxy leaflet-zoom-animated\");\n            this._panes.mapPane.appendChild(proxy);\n            this.on(\"zoomanim\", function(e) {\n                var prop = TRANSFORM, transform = this._proxy.style[prop];\n                setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\n                // workaround for case when transform is the same and so transitionend event is not fired\n                if (transform === this._proxy.style[prop] && this._animatingZoom) {\n                    this._onZoomTransitionEnd();\n                }\n            }, this);\n            this.on(\"load moveend\", this._animMoveEnd, this);\n            this._on(\"unload\", this._destroyAnimProxy, this);\n        },\n        _destroyAnimProxy: function() {\n            remove(this._proxy);\n            this.off(\"load moveend\", this._animMoveEnd, this);\n            delete this._proxy;\n        },\n        _animMoveEnd: function() {\n            var c = this.getCenter(), z = this.getZoom();\n            setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\n        },\n        _catchTransitionEnd: function(e) {\n            if (this._animatingZoom && e.propertyName.indexOf(\"transform\") >= 0) {\n                this._onZoomTransitionEnd();\n            }\n        },\n        _nothingToAnimate: function() {\n            return !this._container.getElementsByClassName(\"leaflet-zoom-animated\").length;\n        },\n        _tryAnimatedZoom: function(center, zoom, options) {\n            if (this._animatingZoom) {\n                return true;\n            }\n            options = options || {};\n            // don't animate if disabled, not supported or zoom difference is too large\n            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {\n                return false;\n            }\n            // offset is the pixel coords of the zoom origin relative to the current center\n            var scale = this.getZoomScale(zoom), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\n            // don't animate if the zoom origin isn't within one screen from the current center, unless forced\n            if (options.animate !== true && !this.getSize().contains(offset)) {\n                return false;\n            }\n            requestAnimFrame(function() {\n                this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom, true);\n            }, this);\n            return true;\n        },\n        _animateZoom: function(center, zoom, startAnim, noUpdate) {\n            if (!this._mapPane) {\n                return;\n            }\n            if (startAnim) {\n                this._animatingZoom = true;\n                // remember what center/zoom to set after animation\n                this._animateToCenter = center;\n                this._animateToZoom = zoom;\n                addClass(this._mapPane, \"leaflet-zoom-anim\");\n            }\n            // @section Other Events\n            // @event zoomanim: ZoomAnimEvent\n            // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\n            this.fire(\"zoomanim\", {\n                center: center,\n                zoom: zoom,\n                noUpdate: noUpdate\n            });\n            if (!this._tempFireZoomEvent) {\n                this._tempFireZoomEvent = this._zoom !== this._animateToZoom;\n            }\n            this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n            // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\n            setTimeout(bind(this._onZoomTransitionEnd, this), 250);\n        },\n        _onZoomTransitionEnd: function() {\n            if (!this._animatingZoom) {\n                return;\n            }\n            if (this._mapPane) {\n                removeClass(this._mapPane, \"leaflet-zoom-anim\");\n            }\n            this._animatingZoom = false;\n            this._move(this._animateToCenter, this._animateToZoom, undefined, true);\n            if (this._tempFireZoomEvent) {\n                this.fire(\"zoom\");\n            }\n            delete this._tempFireZoomEvent;\n            this.fire(\"move\");\n            this._moveEnd(true);\n        }\n    });\n    // @section\n    // @factory L.map(id: String, options?: Map options)\n    // Instantiates a map object given the DOM ID of a `<div>` element\n    // and optionally an object literal with `Map options`.\n    //\n    // @alternative\n    // @factory L.map(el: HTMLElement, options?: Map options)\n    // Instantiates a map object given an instance of a `<div>` HTML element\n    // and optionally an object literal with `Map options`.\n    function createMap(id, options) {\n        return new Map(id, options);\n    }\n    /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */ var Control = Class.extend({\n        // @section\n        // @aka Control Options\n        options: {\n            // @option position: String = 'topright'\n            // The position of the control (one of the map corners). Possible values are `'topleft'`,\n            // `'topright'`, `'bottomleft'` or `'bottomright'`\n            position: \"topright\"\n        },\n        initialize: function(options) {\n            setOptions(this, options);\n        },\n        /* @section\r\n  \t * Classes extending L.Control will inherit the following methods:\r\n  \t *\r\n  \t * @method getPosition: string\r\n  \t * Returns the position of the control.\r\n  \t */ getPosition: function() {\n            return this.options.position;\n        },\n        // @method setPosition(position: string): this\n        // Sets the position of the control.\n        setPosition: function(position) {\n            var map = this._map;\n            if (map) {\n                map.removeControl(this);\n            }\n            this.options.position = position;\n            if (map) {\n                map.addControl(this);\n            }\n            return this;\n        },\n        // @method getContainer: HTMLElement\n        // Returns the HTMLElement that contains the control.\n        getContainer: function() {\n            return this._container;\n        },\n        // @method addTo(map: Map): this\n        // Adds the control to the given map.\n        addTo: function(map) {\n            this.remove();\n            this._map = map;\n            var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];\n            addClass(container, \"leaflet-control\");\n            if (pos.indexOf(\"bottom\") !== -1) {\n                corner.insertBefore(container, corner.firstChild);\n            } else {\n                corner.appendChild(container);\n            }\n            this._map.on(\"unload\", this.remove, this);\n            return this;\n        },\n        // @method remove: this\n        // Removes the control from the map it is currently active on.\n        remove: function() {\n            if (!this._map) {\n                return this;\n            }\n            remove(this._container);\n            if (this.onRemove) {\n                this.onRemove(this._map);\n            }\n            this._map.off(\"unload\", this.remove, this);\n            this._map = null;\n            return this;\n        },\n        _refocusOnMap: function(e) {\n            // if map exists and event is not a keyboard event\n            if (this._map && e && e.screenX > 0 && e.screenY > 0) {\n                this._map.getContainer().focus();\n            }\n        }\n    });\n    var control = function(options) {\n        return new Control(options);\n    };\n    /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */ /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */ Map.include({\n        // @method addControl(control: Control): this\n        // Adds the given control to the map\n        addControl: function(control) {\n            control.addTo(this);\n            return this;\n        },\n        // @method removeControl(control: Control): this\n        // Removes the given control from the map\n        removeControl: function(control) {\n            control.remove();\n            return this;\n        },\n        _initControlPos: function() {\n            var corners = this._controlCorners = {}, l = \"leaflet-\", container = this._controlContainer = create$1(\"div\", l + \"control-container\", this._container);\n            function createCorner(vSide, hSide) {\n                var className = l + vSide + \" \" + l + hSide;\n                corners[vSide + hSide] = create$1(\"div\", className, container);\n            }\n            createCorner(\"top\", \"left\");\n            createCorner(\"top\", \"right\");\n            createCorner(\"bottom\", \"left\");\n            createCorner(\"bottom\", \"right\");\n        },\n        _clearControlPos: function() {\n            for(var i in this._controlCorners){\n                remove(this._controlCorners[i]);\n            }\n            remove(this._controlContainer);\n            delete this._controlCorners;\n            delete this._controlContainer;\n        }\n    });\n    /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */ var Layers = Control.extend({\n        // @section\n        // @aka Control.Layers options\n        options: {\n            // @option collapsed: Boolean = true\n            // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.\n            collapsed: true,\n            position: \"topright\",\n            // @option autoZIndex: Boolean = true\n            // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\n            autoZIndex: true,\n            // @option hideSingleBase: Boolean = false\n            // If `true`, the base layers in the control will be hidden when there is only one.\n            hideSingleBase: false,\n            // @option sortLayers: Boolean = false\n            // Whether to sort the layers. When `false`, layers will keep the order\n            // in which they were added to the control.\n            sortLayers: false,\n            // @option sortFunction: Function = *\n            // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n            // that will be used for sorting the layers, when `sortLayers` is `true`.\n            // The function receives both the `L.Layer` instances and their names, as in\n            // `sortFunction(layerA, layerB, nameA, nameB)`.\n            // By default, it sorts layers alphabetically by their name.\n            sortFunction: function(layerA, layerB, nameA, nameB) {\n                return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;\n            }\n        },\n        initialize: function(baseLayers, overlays, options) {\n            setOptions(this, options);\n            this._layerControlInputs = [];\n            this._layers = [];\n            this._lastZIndex = 0;\n            this._handlingClick = false;\n            this._preventClick = false;\n            for(var i in baseLayers){\n                this._addLayer(baseLayers[i], i);\n            }\n            for(i in overlays){\n                this._addLayer(overlays[i], i, true);\n            }\n        },\n        onAdd: function(map) {\n            this._initLayout();\n            this._update();\n            this._map = map;\n            map.on(\"zoomend\", this._checkDisabledLayers, this);\n            for(var i = 0; i < this._layers.length; i++){\n                this._layers[i].layer.on(\"add remove\", this._onLayerChange, this);\n            }\n            return this._container;\n        },\n        addTo: function(map) {\n            Control.prototype.addTo.call(this, map);\n            // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\n            return this._expandIfNotCollapsed();\n        },\n        onRemove: function() {\n            this._map.off(\"zoomend\", this._checkDisabledLayers, this);\n            for(var i = 0; i < this._layers.length; i++){\n                this._layers[i].layer.off(\"add remove\", this._onLayerChange, this);\n            }\n        },\n        // @method addBaseLayer(layer: Layer, name: String): this\n        // Adds a base layer (radio button entry) with the given name to the control.\n        addBaseLayer: function(layer, name) {\n            this._addLayer(layer, name);\n            return this._map ? this._update() : this;\n        },\n        // @method addOverlay(layer: Layer, name: String): this\n        // Adds an overlay (checkbox entry) with the given name to the control.\n        addOverlay: function(layer, name) {\n            this._addLayer(layer, name, true);\n            return this._map ? this._update() : this;\n        },\n        // @method removeLayer(layer: Layer): this\n        // Remove the given layer from the control.\n        removeLayer: function(layer) {\n            layer.off(\"add remove\", this._onLayerChange, this);\n            var obj = this._getLayer(stamp(layer));\n            if (obj) {\n                this._layers.splice(this._layers.indexOf(obj), 1);\n            }\n            return this._map ? this._update() : this;\n        },\n        // @method expand(): this\n        // Expand the control container if collapsed.\n        expand: function() {\n            addClass(this._container, \"leaflet-control-layers-expanded\");\n            this._section.style.height = null;\n            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\n            if (acceptableHeight < this._section.clientHeight) {\n                addClass(this._section, \"leaflet-control-layers-scrollbar\");\n                this._section.style.height = acceptableHeight + \"px\";\n            } else {\n                removeClass(this._section, \"leaflet-control-layers-scrollbar\");\n            }\n            this._checkDisabledLayers();\n            return this;\n        },\n        // @method collapse(): this\n        // Collapse the control container if expanded.\n        collapse: function() {\n            removeClass(this._container, \"leaflet-control-layers-expanded\");\n            return this;\n        },\n        _initLayout: function() {\n            var className = \"leaflet-control-layers\", container = this._container = create$1(\"div\", className), collapsed = this.options.collapsed;\n            // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\n            container.setAttribute(\"aria-haspopup\", true);\n            disableClickPropagation(container);\n            disableScrollPropagation(container);\n            var section = this._section = create$1(\"section\", className + \"-list\");\n            if (collapsed) {\n                this._map.on(\"click\", this.collapse, this);\n                on(container, {\n                    mouseenter: this._expandSafely,\n                    mouseleave: this.collapse\n                }, this);\n            }\n            var link = this._layersLink = create$1(\"a\", className + \"-toggle\", container);\n            link.href = \"#\";\n            link.title = \"Layers\";\n            link.setAttribute(\"role\", \"button\");\n            on(link, {\n                keydown: function(e) {\n                    if (e.keyCode === 13) {\n                        this._expandSafely();\n                    }\n                },\n                // Certain screen readers intercept the key event and instead send a click event\n                click: function(e) {\n                    preventDefault(e);\n                    this._expandSafely();\n                }\n            }, this);\n            if (!collapsed) {\n                this.expand();\n            }\n            this._baseLayersList = create$1(\"div\", className + \"-base\", section);\n            this._separator = create$1(\"div\", className + \"-separator\", section);\n            this._overlaysList = create$1(\"div\", className + \"-overlays\", section);\n            container.appendChild(section);\n        },\n        _getLayer: function(id) {\n            for(var i = 0; i < this._layers.length; i++){\n                if (this._layers[i] && stamp(this._layers[i].layer) === id) {\n                    return this._layers[i];\n                }\n            }\n        },\n        _addLayer: function(layer, name, overlay) {\n            if (this._map) {\n                layer.on(\"add remove\", this._onLayerChange, this);\n            }\n            this._layers.push({\n                layer: layer,\n                name: name,\n                overlay: overlay\n            });\n            if (this.options.sortLayers) {\n                this._layers.sort(bind(function(a, b) {\n                    return this.options.sortFunction(a.layer, b.layer, a.name, b.name);\n                }, this));\n            }\n            if (this.options.autoZIndex && layer.setZIndex) {\n                this._lastZIndex++;\n                layer.setZIndex(this._lastZIndex);\n            }\n            this._expandIfNotCollapsed();\n        },\n        _update: function() {\n            if (!this._container) {\n                return this;\n            }\n            empty(this._baseLayersList);\n            empty(this._overlaysList);\n            this._layerControlInputs = [];\n            var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;\n            for(i = 0; i < this._layers.length; i++){\n                obj = this._layers[i];\n                this._addItem(obj);\n                overlaysPresent = overlaysPresent || obj.overlay;\n                baseLayersPresent = baseLayersPresent || !obj.overlay;\n                baseLayersCount += !obj.overlay ? 1 : 0;\n            }\n            // Hide base layers section if there's only one layer.\n            if (this.options.hideSingleBase) {\n                baseLayersPresent = baseLayersPresent && baseLayersCount > 1;\n                this._baseLayersList.style.display = baseLayersPresent ? \"\" : \"none\";\n            }\n            this._separator.style.display = overlaysPresent && baseLayersPresent ? \"\" : \"none\";\n            return this;\n        },\n        _onLayerChange: function(e) {\n            if (!this._handlingClick) {\n                this._update();\n            }\n            var obj = this._getLayer(stamp(e.target));\n            // @namespace Map\n            // @section Layer events\n            // @event baselayerchange: LayersControlEvent\n            // Fired when the base layer is changed through the [layers control](#control-layers).\n            // @event overlayadd: LayersControlEvent\n            // Fired when an overlay is selected through the [layers control](#control-layers).\n            // @event overlayremove: LayersControlEvent\n            // Fired when an overlay is deselected through the [layers control](#control-layers).\n            // @namespace Control.Layers\n            var type = obj.overlay ? e.type === \"add\" ? \"overlayadd\" : \"overlayremove\" : e.type === \"add\" ? \"baselayerchange\" : null;\n            if (type) {\n                this._map.fire(type, obj);\n            }\n        },\n        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)\n        _createRadioElement: function(name, checked) {\n            var radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"' + (checked ? ' checked=\"checked\"' : \"\") + \"/>\";\n            var radioFragment = document.createElement(\"div\");\n            radioFragment.innerHTML = radioHtml;\n            return radioFragment.firstChild;\n        },\n        _addItem: function(obj) {\n            var label = document.createElement(\"label\"), checked = this._map.hasLayer(obj.layer), input;\n            if (obj.overlay) {\n                input = document.createElement(\"input\");\n                input.type = \"checkbox\";\n                input.className = \"leaflet-control-layers-selector\";\n                input.defaultChecked = checked;\n            } else {\n                input = this._createRadioElement(\"leaflet-base-layers_\" + stamp(this), checked);\n            }\n            this._layerControlInputs.push(input);\n            input.layerId = stamp(obj.layer);\n            on(input, \"click\", this._onInputClick, this);\n            var name = document.createElement(\"span\");\n            name.innerHTML = \" \" + obj.name;\n            // Helps from preventing layer control flicker when checkboxes are disabled\n            // https://github.com/Leaflet/Leaflet/issues/2771\n            var holder = document.createElement(\"span\");\n            label.appendChild(holder);\n            holder.appendChild(input);\n            holder.appendChild(name);\n            var container = obj.overlay ? this._overlaysList : this._baseLayersList;\n            container.appendChild(label);\n            this._checkDisabledLayers();\n            return label;\n        },\n        _onInputClick: function() {\n            // expanding the control on mobile with a click can cause adding a layer - we don't want this\n            if (this._preventClick) {\n                return;\n            }\n            var inputs = this._layerControlInputs, input, layer;\n            var addedLayers = [], removedLayers = [];\n            this._handlingClick = true;\n            for(var i = inputs.length - 1; i >= 0; i--){\n                input = inputs[i];\n                layer = this._getLayer(input.layerId).layer;\n                if (input.checked) {\n                    addedLayers.push(layer);\n                } else if (!input.checked) {\n                    removedLayers.push(layer);\n                }\n            }\n            // Bugfix issue 2318: Should remove all old layers before readding new ones\n            for(i = 0; i < removedLayers.length; i++){\n                if (this._map.hasLayer(removedLayers[i])) {\n                    this._map.removeLayer(removedLayers[i]);\n                }\n            }\n            for(i = 0; i < addedLayers.length; i++){\n                if (!this._map.hasLayer(addedLayers[i])) {\n                    this._map.addLayer(addedLayers[i]);\n                }\n            }\n            this._handlingClick = false;\n            this._refocusOnMap();\n        },\n        _checkDisabledLayers: function() {\n            var inputs = this._layerControlInputs, input, layer, zoom = this._map.getZoom();\n            for(var i = inputs.length - 1; i >= 0; i--){\n                input = inputs[i];\n                layer = this._getLayer(input.layerId).layer;\n                input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;\n            }\n        },\n        _expandIfNotCollapsed: function() {\n            if (this._map && !this.options.collapsed) {\n                this.expand();\n            }\n            return this;\n        },\n        _expandSafely: function() {\n            var section = this._section;\n            this._preventClick = true;\n            on(section, \"click\", preventDefault);\n            this.expand();\n            var that = this;\n            setTimeout(function() {\n                off(section, \"click\", preventDefault);\n                that._preventClick = false;\n            });\n        }\n    });\n    // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\n    // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\n    var layers = function(baseLayers, overlays, options) {\n        return new Layers(baseLayers, overlays, options);\n    };\n    /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */ var Zoom = Control.extend({\n        // @section\n        // @aka Control.Zoom options\n        options: {\n            position: \"topleft\",\n            // @option zoomInText: String = '<span aria-hidden=\"true\">+</span>'\n            // The text set on the 'zoom in' button.\n            zoomInText: '<span aria-hidden=\"true\">+</span>',\n            // @option zoomInTitle: String = 'Zoom in'\n            // The title set on the 'zoom in' button.\n            zoomInTitle: \"Zoom in\",\n            // @option zoomOutText: String = '<span aria-hidden=\"true\">&#x2212;</span>'\n            // The text set on the 'zoom out' button.\n            zoomOutText: '<span aria-hidden=\"true\">&#x2212;</span>',\n            // @option zoomOutTitle: String = 'Zoom out'\n            // The title set on the 'zoom out' button.\n            zoomOutTitle: \"Zoom out\"\n        },\n        onAdd: function(map) {\n            var zoomName = \"leaflet-control-zoom\", container = create$1(\"div\", zoomName + \" leaflet-bar\"), options = this.options;\n            this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + \"-in\", container, this._zoomIn);\n            this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + \"-out\", container, this._zoomOut);\n            this._updateDisabled();\n            map.on(\"zoomend zoomlevelschange\", this._updateDisabled, this);\n            return container;\n        },\n        onRemove: function(map) {\n            map.off(\"zoomend zoomlevelschange\", this._updateDisabled, this);\n        },\n        disable: function() {\n            this._disabled = true;\n            this._updateDisabled();\n            return this;\n        },\n        enable: function() {\n            this._disabled = false;\n            this._updateDisabled();\n            return this;\n        },\n        _zoomIn: function(e) {\n            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\n                this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n            }\n        },\n        _zoomOut: function(e) {\n            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\n                this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\n            }\n        },\n        _createButton: function(html, title, className, container, fn) {\n            var link = create$1(\"a\", className, container);\n            link.innerHTML = html;\n            link.href = \"#\";\n            link.title = title;\n            /*\r\n  \t\t * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n  \t\t */ link.setAttribute(\"role\", \"button\");\n            link.setAttribute(\"aria-label\", title);\n            disableClickPropagation(link);\n            on(link, \"click\", stop);\n            on(link, \"click\", fn, this);\n            on(link, \"click\", this._refocusOnMap, this);\n            return link;\n        },\n        _updateDisabled: function() {\n            var map = this._map, className = \"leaflet-disabled\";\n            removeClass(this._zoomInButton, className);\n            removeClass(this._zoomOutButton, className);\n            this._zoomInButton.setAttribute(\"aria-disabled\", \"false\");\n            this._zoomOutButton.setAttribute(\"aria-disabled\", \"false\");\n            if (this._disabled || map._zoom === map.getMinZoom()) {\n                addClass(this._zoomOutButton, className);\n                this._zoomOutButton.setAttribute(\"aria-disabled\", \"true\");\n            }\n            if (this._disabled || map._zoom === map.getMaxZoom()) {\n                addClass(this._zoomInButton, className);\n                this._zoomInButton.setAttribute(\"aria-disabled\", \"true\");\n            }\n        }\n    });\n    // @namespace Map\n    // @section Control options\n    // @option zoomControl: Boolean = true\n    // Whether a [zoom control](#control-zoom) is added to the map by default.\n    Map.mergeOptions({\n        zoomControl: true\n    });\n    Map.addInitHook(function() {\n        if (this.options.zoomControl) {\n            // @section Controls\n            // @property zoomControl: Control.Zoom\n            // The default zoom control (only available if the\n            // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\n            this.zoomControl = new Zoom();\n            this.addControl(this.zoomControl);\n        }\n    });\n    // @namespace Control.Zoom\n    // @factory L.control.zoom(options: Control.Zoom options)\n    // Creates a zoom control\n    var zoom = function(options) {\n        return new Zoom(options);\n    };\n    /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */ var Scale = Control.extend({\n        // @section\n        // @aka Control.Scale options\n        options: {\n            position: \"bottomleft\",\n            // @option maxWidth: Number = 100\n            // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n            maxWidth: 100,\n            // @option metric: Boolean = True\n            // Whether to show the metric scale line (m/km).\n            metric: true,\n            // @option imperial: Boolean = True\n            // Whether to show the imperial scale line (mi/ft).\n            imperial: true\n        },\n        onAdd: function(map) {\n            var className = \"leaflet-control-scale\", container = create$1(\"div\", className), options = this.options;\n            this._addScales(options, className + \"-line\", container);\n            map.on(options.updateWhenIdle ? \"moveend\" : \"move\", this._update, this);\n            map.whenReady(this._update, this);\n            return container;\n        },\n        onRemove: function(map) {\n            map.off(this.options.updateWhenIdle ? \"moveend\" : \"move\", this._update, this);\n        },\n        _addScales: function(options, className, container) {\n            if (options.metric) {\n                this._mScale = create$1(\"div\", className, container);\n            }\n            if (options.imperial) {\n                this._iScale = create$1(\"div\", className, container);\n            }\n        },\n        _update: function() {\n            var map = this._map, y = map.getSize().y / 2;\n            var maxMeters = map.distance(map.containerPointToLatLng([\n                0,\n                y\n            ]), map.containerPointToLatLng([\n                this.options.maxWidth,\n                y\n            ]));\n            this._updateScales(maxMeters);\n        },\n        _updateScales: function(maxMeters) {\n            if (this.options.metric && maxMeters) {\n                this._updateMetric(maxMeters);\n            }\n            if (this.options.imperial && maxMeters) {\n                this._updateImperial(maxMeters);\n            }\n        },\n        _updateMetric: function(maxMeters) {\n            var meters = this._getRoundNum(maxMeters), label = meters < 1000 ? meters + \" m\" : meters / 1000 + \" km\";\n            this._updateScale(this._mScale, label, meters / maxMeters);\n        },\n        _updateImperial: function(maxMeters) {\n            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;\n            if (maxFeet > 5280) {\n                maxMiles = maxFeet / 5280;\n                miles = this._getRoundNum(maxMiles);\n                this._updateScale(this._iScale, miles + \" mi\", miles / maxMiles);\n            } else {\n                feet = this._getRoundNum(maxFeet);\n                this._updateScale(this._iScale, feet + \" ft\", feet / maxFeet);\n            }\n        },\n        _updateScale: function(scale, text, ratio) {\n            scale.style.width = Math.round(this.options.maxWidth * ratio) + \"px\";\n            scale.innerHTML = text;\n        },\n        _getRoundNum: function(num) {\n            var pow10 = Math.pow(10, (Math.floor(num) + \"\").length - 1), d = num / pow10;\n            d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n            return pow10 * d;\n        }\n    });\n    // @factory L.control.scale(options?: Control.Scale options)\n    // Creates an scale control with the given options.\n    var scale = function(options) {\n        return new Scale(options);\n    };\n    var ukrainianFlag = '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"8\" viewBox=\"0 0 12 8\" class=\"leaflet-attribution-flag\"><path fill=\"#4C7BE1\" d=\"M0 0h12v4H0z\"/><path fill=\"#FFD500\" d=\"M0 4h12v3H0z\"/><path fill=\"#E0BC00\" d=\"M0 7h12v1H0z\"/></svg>';\n    /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */ var Attribution = Control.extend({\n        // @section\n        // @aka Control.Attribution options\n        options: {\n            position: \"bottomright\",\n            // @option prefix: String|false = 'Leaflet'\n            // The HTML text shown before the attributions. Pass `false` to disable.\n            prefix: '<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">' + (Browser.inlineSvg ? ukrainianFlag + \" \" : \"\") + \"Leaflet</a>\"\n        },\n        initialize: function(options) {\n            setOptions(this, options);\n            this._attributions = {};\n        },\n        onAdd: function(map) {\n            map.attributionControl = this;\n            this._container = create$1(\"div\", \"leaflet-control-attribution\");\n            disableClickPropagation(this._container);\n            // TODO ugly, refactor\n            for(var i in map._layers){\n                if (map._layers[i].getAttribution) {\n                    this.addAttribution(map._layers[i].getAttribution());\n                }\n            }\n            this._update();\n            map.on(\"layeradd\", this._addAttribution, this);\n            return this._container;\n        },\n        onRemove: function(map) {\n            map.off(\"layeradd\", this._addAttribution, this);\n        },\n        _addAttribution: function(ev) {\n            if (ev.layer.getAttribution) {\n                this.addAttribution(ev.layer.getAttribution());\n                ev.layer.once(\"remove\", function() {\n                    this.removeAttribution(ev.layer.getAttribution());\n                }, this);\n            }\n        },\n        // @method setPrefix(prefix: String|false): this\n        // The HTML text shown before the attributions. Pass `false` to disable.\n        setPrefix: function(prefix) {\n            this.options.prefix = prefix;\n            this._update();\n            return this;\n        },\n        // @method addAttribution(text: String): this\n        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).\n        addAttribution: function(text) {\n            if (!text) {\n                return this;\n            }\n            if (!this._attributions[text]) {\n                this._attributions[text] = 0;\n            }\n            this._attributions[text]++;\n            this._update();\n            return this;\n        },\n        // @method removeAttribution(text: String): this\n        // Removes an attribution text.\n        removeAttribution: function(text) {\n            if (!text) {\n                return this;\n            }\n            if (this._attributions[text]) {\n                this._attributions[text]--;\n                this._update();\n            }\n            return this;\n        },\n        _update: function() {\n            if (!this._map) {\n                return;\n            }\n            var attribs = [];\n            for(var i in this._attributions){\n                if (this._attributions[i]) {\n                    attribs.push(i);\n                }\n            }\n            var prefixAndAttribs = [];\n            if (this.options.prefix) {\n                prefixAndAttribs.push(this.options.prefix);\n            }\n            if (attribs.length) {\n                prefixAndAttribs.push(attribs.join(\", \"));\n            }\n            this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden=\"true\">|</span> ');\n        }\n    });\n    // @namespace Map\n    // @section Control options\n    // @option attributionControl: Boolean = true\n    // Whether a [attribution control](#control-attribution) is added to the map by default.\n    Map.mergeOptions({\n        attributionControl: true\n    });\n    Map.addInitHook(function() {\n        if (this.options.attributionControl) {\n            new Attribution().addTo(this);\n        }\n    });\n    // @namespace Control.Attribution\n    // @factory L.control.attribution(options: Control.Attribution options)\n    // Creates an attribution control.\n    var attribution = function(options) {\n        return new Attribution(options);\n    };\n    Control.Layers = Layers;\n    Control.Zoom = Zoom;\n    Control.Scale = Scale;\n    Control.Attribution = Attribution;\n    control.layers = layers;\n    control.zoom = zoom;\n    control.scale = scale;\n    control.attribution = attribution;\n    /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */ // @class Handler\n    // @aka L.Handler\n    // Abstract class for map interaction handlers\n    var Handler = Class.extend({\n        initialize: function(map) {\n            this._map = map;\n        },\n        // @method enable(): this\n        // Enables the handler\n        enable: function() {\n            if (this._enabled) {\n                return this;\n            }\n            this._enabled = true;\n            this.addHooks();\n            return this;\n        },\n        // @method disable(): this\n        // Disables the handler\n        disable: function() {\n            if (!this._enabled) {\n                return this;\n            }\n            this._enabled = false;\n            this.removeHooks();\n            return this;\n        },\n        // @method enabled(): Boolean\n        // Returns `true` if the handler is enabled\n        enabled: function() {\n            return !!this._enabled;\n        }\n    });\n    // @section There is static function which can be called without instantiating L.Handler:\n    // @function addTo(map: Map, name: String): this\n    // Adds a new Handler to the given map with the given name.\n    Handler.addTo = function(map, name) {\n        map.addHandler(name, this);\n        return this;\n    };\n    var Mixin = {\n        Events: Events\n    };\n    /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */ var START = Browser.touch ? \"touchstart mousedown\" : \"mousedown\";\n    var Draggable = Evented.extend({\n        options: {\n            // @section\n            // @aka Draggable options\n            // @option clickTolerance: Number = 3\n            // The max number of pixels a user can shift the mouse pointer during a click\n            // for it to be considered a valid click (as opposed to a mouse drag).\n            clickTolerance: 3\n        },\n        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\n        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\n        initialize: function(element, dragStartTarget, preventOutline, options) {\n            setOptions(this, options);\n            this._element = element;\n            this._dragStartTarget = dragStartTarget || element;\n            this._preventOutline = preventOutline;\n        },\n        // @method enable()\n        // Enables the dragging ability\n        enable: function() {\n            if (this._enabled) {\n                return;\n            }\n            on(this._dragStartTarget, START, this._onDown, this);\n            this._enabled = true;\n        },\n        // @method disable()\n        // Disables the dragging ability\n        disable: function() {\n            if (!this._enabled) {\n                return;\n            }\n            // If we're currently dragging this draggable,\n            // disabling it counts as first ending the drag.\n            if (Draggable._dragging === this) {\n                this.finishDrag(true);\n            }\n            off(this._dragStartTarget, START, this._onDown, this);\n            this._enabled = false;\n            this._moved = false;\n        },\n        _onDown: function(e) {\n            // Ignore the event if disabled; this happens in IE11\n            // under some circumstances, see #3666.\n            if (!this._enabled) {\n                return;\n            }\n            this._moved = false;\n            if (hasClass(this._element, \"leaflet-zoom-anim\")) {\n                return;\n            }\n            if (e.touches && e.touches.length !== 1) {\n                // Finish dragging to avoid conflict with touchZoom\n                if (Draggable._dragging === this) {\n                    this.finishDrag();\n                }\n                return;\n            }\n            if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {\n                return;\n            }\n            Draggable._dragging = this; // Prevent dragging multiple objects at once.\n            if (this._preventOutline) {\n                preventOutline(this._element);\n            }\n            disableImageDrag();\n            disableTextSelection();\n            if (this._moving) {\n                return;\n            }\n            // @event down: Event\n            // Fired when a drag is about to start.\n            this.fire(\"down\");\n            var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);\n            this._startPoint = new Point(first.clientX, first.clientY);\n            this._startPos = getPosition(this._element);\n            // Cache the scale, so that we can continuously compensate for it during drag (_onMove).\n            this._parentScale = getScale(sizedParent);\n            var mouseevent = e.type === \"mousedown\";\n            on(document, mouseevent ? \"mousemove\" : \"touchmove\", this._onMove, this);\n            on(document, mouseevent ? \"mouseup\" : \"touchend touchcancel\", this._onUp, this);\n        },\n        _onMove: function(e) {\n            // Ignore the event if disabled; this happens in IE11\n            // under some circumstances, see #3666.\n            if (!this._enabled) {\n                return;\n            }\n            if (e.touches && e.touches.length > 1) {\n                this._moved = true;\n                return;\n            }\n            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\n            if (!offset.x && !offset.y) {\n                return;\n            }\n            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {\n                return;\n            }\n            // We assume that the parent container's position, border and scale do not change for the duration of the drag.\n            // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\n            // and we can use the cached value for the scale.\n            offset.x /= this._parentScale.x;\n            offset.y /= this._parentScale.y;\n            preventDefault(e);\n            if (!this._moved) {\n                // @event dragstart: Event\n                // Fired when a drag starts\n                this.fire(\"dragstart\");\n                this._moved = true;\n                addClass(document.body, \"leaflet-dragging\");\n                this._lastTarget = e.target || e.srcElement;\n                // IE and Edge do not give the <use> element, so fetch it\n                // if necessary\n                if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\n                    this._lastTarget = this._lastTarget.correspondingUseElement;\n                }\n                addClass(this._lastTarget, \"leaflet-drag-target\");\n            }\n            this._newPos = this._startPos.add(offset);\n            this._moving = true;\n            this._lastEvent = e;\n            this._updatePosition();\n        },\n        _updatePosition: function() {\n            var e = {\n                originalEvent: this._lastEvent\n            };\n            // @event predrag: Event\n            // Fired continuously during dragging *before* each corresponding\n            // update of the element's position.\n            this.fire(\"predrag\", e);\n            setPosition(this._element, this._newPos);\n            // @event drag: Event\n            // Fired continuously during dragging.\n            this.fire(\"drag\", e);\n        },\n        _onUp: function() {\n            // Ignore the event if disabled; this happens in IE11\n            // under some circumstances, see #3666.\n            if (!this._enabled) {\n                return;\n            }\n            this.finishDrag();\n        },\n        finishDrag: function(noInertia) {\n            removeClass(document.body, \"leaflet-dragging\");\n            if (this._lastTarget) {\n                removeClass(this._lastTarget, \"leaflet-drag-target\");\n                this._lastTarget = null;\n            }\n            off(document, \"mousemove touchmove\", this._onMove, this);\n            off(document, \"mouseup touchend touchcancel\", this._onUp, this);\n            enableImageDrag();\n            enableTextSelection();\n            var fireDragend = this._moved && this._moving;\n            this._moving = false;\n            Draggable._dragging = false;\n            if (fireDragend) {\n                // @event dragend: DragEndEvent\n                // Fired when the drag ends.\n                this.fire(\"dragend\", {\n                    noInertia: noInertia,\n                    distance: this._newPos.distanceTo(this._startPos)\n                });\n            }\n        }\n    });\n    /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */ /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */ function clipPolygon(points, bounds, round) {\n        var clippedPoints, edges = [\n            1,\n            4,\n            2,\n            8\n        ], i, j, k, a, b, len, edge, p;\n        for(i = 0, len = points.length; i < len; i++){\n            points[i]._code = _getBitCode(points[i], bounds);\n        }\n        // for each edge (left, bottom, right, top)\n        for(k = 0; k < 4; k++){\n            edge = edges[k];\n            clippedPoints = [];\n            for(i = 0, len = points.length, j = len - 1; i < len; j = i++){\n                a = points[i];\n                b = points[j];\n                // if a is inside the clip window\n                if (!(a._code & edge)) {\n                    // if b is outside the clip window (a->b goes out of screen)\n                    if (b._code & edge) {\n                        p = _getEdgeIntersection(b, a, edge, bounds, round);\n                        p._code = _getBitCode(p, bounds);\n                        clippedPoints.push(p);\n                    }\n                    clippedPoints.push(a);\n                // else if b is inside the clip window (a->b enters the screen)\n                } else if (!(b._code & edge)) {\n                    p = _getEdgeIntersection(b, a, edge, bounds, round);\n                    p._code = _getBitCode(p, bounds);\n                    clippedPoints.push(p);\n                }\n            }\n            points = clippedPoints;\n        }\n        return points;\n    }\n    /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.\r\n   */ function polygonCenter(latlngs, crs) {\n        var i, j, p1, p2, f, area, x, y, center;\n        if (!latlngs || latlngs.length === 0) {\n            throw new Error(\"latlngs not passed\");\n        }\n        if (!isFlat(latlngs)) {\n            console.warn(\"latlngs are not flat! Only the first ring will be used\");\n            latlngs = latlngs[0];\n        }\n        var centroidLatLng = toLatLng([\n            0,\n            0\n        ]);\n        var bounds = toLatLngBounds(latlngs);\n        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n        // tests showed that below 1700 rounding errors are happening\n        if (areaBounds < 1700) {\n            // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n            centroidLatLng = centroid(latlngs);\n        }\n        var len = latlngs.length;\n        var points = [];\n        for(i = 0; i < len; i++){\n            var latlng = toLatLng(latlngs[i]);\n            points.push(crs.project(toLatLng([\n                latlng.lat - centroidLatLng.lat,\n                latlng.lng - centroidLatLng.lng\n            ])));\n        }\n        area = x = y = 0;\n        // polygon centroid algorithm;\n        for(i = 0, j = len - 1; i < len; j = i++){\n            p1 = points[i];\n            p2 = points[j];\n            f = p1.y * p2.x - p2.y * p1.x;\n            x += (p1.x + p2.x) * f;\n            y += (p1.y + p2.y) * f;\n            area += f * 3;\n        }\n        if (area === 0) {\n            // Polygon is so small that all points are on same pixel.\n            center = points[0];\n        } else {\n            center = [\n                x / area,\n                y / area\n            ];\n        }\n        var latlngCenter = crs.unproject(toPoint(center));\n        return toLatLng([\n            latlngCenter.lat + centroidLatLng.lat,\n            latlngCenter.lng + centroidLatLng.lng\n        ]);\n    }\n    /* @function centroid(latlngs: LatLng[]): LatLng\r\n   * Returns the 'center of mass' of the passed LatLngs.\r\n   */ function centroid(coords) {\n        var latSum = 0;\n        var lngSum = 0;\n        var len = 0;\n        for(var i = 0; i < coords.length; i++){\n            var latlng = toLatLng(coords[i]);\n            latSum += latlng.lat;\n            lngSum += latlng.lng;\n            len++;\n        }\n        return toLatLng([\n            latSum / len,\n            lngSum / len\n        ]);\n    }\n    var PolyUtil = {\n        __proto__: null,\n        clipPolygon: clipPolygon,\n        polygonCenter: polygonCenter,\n        centroid: centroid\n    };\n    /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */ // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n    // Improves rendering performance dramatically by lessening the number of points to draw.\n    // @function simplify(points: Point[], tolerance: Number): Point[]\n    // Dramatically reduces the number of points in a polyline while retaining\n    // its shape and returns a new array of simplified points, using the\n    // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).\n    // Used for a huge performance boost when processing/displaying Leaflet polylines for\n    // each zoom level and also reducing visual noise. tolerance affects the amount of\n    // simplification (lesser value means higher quality but slower and with more points).\n    // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).\n    function simplify(points, tolerance) {\n        if (!tolerance || !points.length) {\n            return points.slice();\n        }\n        var sqTolerance = tolerance * tolerance;\n        // stage 1: vertex reduction\n        points = _reducePoints(points, sqTolerance);\n        // stage 2: Douglas-Peucker simplification\n        points = _simplifyDP(points, sqTolerance);\n        return points;\n    }\n    // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\n    // Returns the distance between point `p` and segment `p1` to `p2`.\n    function pointToSegmentDistance(p, p1, p2) {\n        return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\n    }\n    // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\n    // Returns the closest point from a point `p` on a segment `p1` to `p2`.\n    function closestPointOnSegment(p, p1, p2) {\n        return _sqClosestPointOnSegment(p, p1, p2);\n    }\n    // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n    function _simplifyDP(points, sqTolerance) {\n        var len = points.length, ArrayConstructor = typeof Uint8Array !== undefined + \"\" ? Uint8Array : Array, markers = new ArrayConstructor(len);\n        markers[0] = markers[len - 1] = 1;\n        _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n        var i, newPoints = [];\n        for(i = 0; i < len; i++){\n            if (markers[i]) {\n                newPoints.push(points[i]);\n            }\n        }\n        return newPoints;\n    }\n    function _simplifyDPStep(points, markers, sqTolerance, first, last) {\n        var maxSqDist = 0, index, i, sqDist;\n        for(i = first + 1; i <= last - 1; i++){\n            sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\n            if (sqDist > maxSqDist) {\n                index = i;\n                maxSqDist = sqDist;\n            }\n        }\n        if (maxSqDist > sqTolerance) {\n            markers[index] = 1;\n            _simplifyDPStep(points, markers, sqTolerance, first, index);\n            _simplifyDPStep(points, markers, sqTolerance, index, last);\n        }\n    }\n    // reduce points that are too close to each other to a single point\n    function _reducePoints(points, sqTolerance) {\n        var reducedPoints = [\n            points[0]\n        ];\n        for(var i = 1, prev = 0, len = points.length; i < len; i++){\n            if (_sqDist(points[i], points[prev]) > sqTolerance) {\n                reducedPoints.push(points[i]);\n                prev = i;\n            }\n        }\n        if (prev < len - 1) {\n            reducedPoints.push(points[len - 1]);\n        }\n        return reducedPoints;\n    }\n    var _lastCode;\n    // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\n    // Clips the segment a to b by rectangular bounds with the\n    // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\n    // (modifying the segment points directly!). Used by Leaflet to only show polyline\n    // points that are on the screen or near, increasing performance.\n    function clipSegment(a, b, bounds, useLastCode, round) {\n        var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;\n        // save 2nd code to avoid calculating it on the next segment\n        _lastCode = codeB;\n        while(true){\n            // if a,b is inside the clip window (trivial accept)\n            if (!(codeA | codeB)) {\n                return [\n                    a,\n                    b\n                ];\n            }\n            // if a,b is outside the clip window (trivial reject)\n            if (codeA & codeB) {\n                return false;\n            }\n            // other cases\n            codeOut = codeA || codeB;\n            p = _getEdgeIntersection(a, b, codeOut, bounds, round);\n            newCode = _getBitCode(p, bounds);\n            if (codeOut === codeA) {\n                a = p;\n                codeA = newCode;\n            } else {\n                b = p;\n                codeB = newCode;\n            }\n        }\n    }\n    function _getEdgeIntersection(a, b, code, bounds, round) {\n        var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;\n        if (code & 8) {\n            x = a.x + dx * (max.y - a.y) / dy;\n            y = max.y;\n        } else if (code & 4) {\n            x = a.x + dx * (min.y - a.y) / dy;\n            y = min.y;\n        } else if (code & 2) {\n            x = max.x;\n            y = a.y + dy * (max.x - a.x) / dx;\n        } else if (code & 1) {\n            x = min.x;\n            y = a.y + dy * (min.x - a.x) / dx;\n        }\n        return new Point(x, y, round);\n    }\n    function _getBitCode(p, bounds) {\n        var code = 0;\n        if (p.x < bounds.min.x) {\n            code |= 1;\n        } else if (p.x > bounds.max.x) {\n            code |= 2;\n        }\n        if (p.y < bounds.min.y) {\n            code |= 4;\n        } else if (p.y > bounds.max.y) {\n            code |= 8;\n        }\n        return code;\n    }\n    // square distance (to avoid unnecessary Math.sqrt calls)\n    function _sqDist(p1, p2) {\n        var dx = p2.x - p1.x, dy = p2.y - p1.y;\n        return dx * dx + dy * dy;\n    }\n    // return closest point on segment or distance to that point\n    function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\n        var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;\n        if (dot > 0) {\n            t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n            if (t > 1) {\n                x = p2.x;\n                y = p2.y;\n            } else if (t > 0) {\n                x += dx * t;\n                y += dy * t;\n            }\n        }\n        dx = p.x - x;\n        dy = p.y - y;\n        return sqDist ? dx * dx + dy * dy : new Point(x, y);\n    }\n    // @function isFlat(latlngs: LatLng[]): Boolean\n    // Returns true if `latlngs` is a flat array, false is nested.\n    function isFlat(latlngs) {\n        return !isArray(latlngs[0]) || typeof latlngs[0][0] !== \"object\" && typeof latlngs[0][0] !== \"undefined\";\n    }\n    function _flat(latlngs) {\n        console.warn(\"Deprecated use of _flat, please use L.LineUtil.isFlat instead.\");\n        return isFlat(latlngs);\n    }\n    /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.\r\n   */ function polylineCenter(latlngs, crs) {\n        var i, halfDist, segDist, dist, p1, p2, ratio, center;\n        if (!latlngs || latlngs.length === 0) {\n            throw new Error(\"latlngs not passed\");\n        }\n        if (!isFlat(latlngs)) {\n            console.warn(\"latlngs are not flat! Only the first ring will be used\");\n            latlngs = latlngs[0];\n        }\n        var centroidLatLng = toLatLng([\n            0,\n            0\n        ]);\n        var bounds = toLatLngBounds(latlngs);\n        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());\n        // tests showed that below 1700 rounding errors are happening\n        if (areaBounds < 1700) {\n            // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors\n            centroidLatLng = centroid(latlngs);\n        }\n        var len = latlngs.length;\n        var points = [];\n        for(i = 0; i < len; i++){\n            var latlng = toLatLng(latlngs[i]);\n            points.push(crs.project(toLatLng([\n                latlng.lat - centroidLatLng.lat,\n                latlng.lng - centroidLatLng.lng\n            ])));\n        }\n        for(i = 0, halfDist = 0; i < len - 1; i++){\n            halfDist += points[i].distanceTo(points[i + 1]) / 2;\n        }\n        // The line is so small in the current view that all points are on the same pixel.\n        if (halfDist === 0) {\n            center = points[0];\n        } else {\n            for(i = 0, dist = 0; i < len - 1; i++){\n                p1 = points[i];\n                p2 = points[i + 1];\n                segDist = p1.distanceTo(p2);\n                dist += segDist;\n                if (dist > halfDist) {\n                    ratio = (dist - halfDist) / segDist;\n                    center = [\n                        p2.x - ratio * (p2.x - p1.x),\n                        p2.y - ratio * (p2.y - p1.y)\n                    ];\n                    break;\n                }\n            }\n        }\n        var latlngCenter = crs.unproject(toPoint(center));\n        return toLatLng([\n            latlngCenter.lat + centroidLatLng.lat,\n            latlngCenter.lng + centroidLatLng.lng\n        ]);\n    }\n    var LineUtil = {\n        __proto__: null,\n        simplify: simplify,\n        pointToSegmentDistance: pointToSegmentDistance,\n        closestPointOnSegment: closestPointOnSegment,\n        clipSegment: clipSegment,\n        _getEdgeIntersection: _getEdgeIntersection,\n        _getBitCode: _getBitCode,\n        _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n        isFlat: isFlat,\n        _flat: _flat,\n        polylineCenter: polylineCenter\n    };\n    /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection — the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */ var LonLat = {\n        project: function(latlng) {\n            return new Point(latlng.lng, latlng.lat);\n        },\n        unproject: function(point) {\n            return new LatLng(point.y, point.x);\n        },\n        bounds: new Bounds([\n            -180,\n            -90\n        ], [\n            180,\n            90\n        ])\n    };\n    /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */ var Mercator = {\n        R: 6378137,\n        R_MINOR: 6356752.314245179,\n        bounds: new Bounds([\n            -20037508.34279,\n            -15496570.73972\n        ], [\n            20037508.34279,\n            18764656.23138\n        ]),\n        project: function(latlng) {\n            var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);\n            var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\n            y = -r * Math.log(Math.max(ts, 1E-10));\n            return new Point(latlng.lng * d * r, y);\n        },\n        unproject: function(point) {\n            var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);\n            for(var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++){\n                con = e * Math.sin(phi);\n                con = Math.pow((1 - con) / (1 + con), e / 2);\n                dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\n                phi += dphi;\n            }\n            return new LatLng(phi * d, point.x * d / r);\n        }\n    };\n    /*\n   * @class Projection\n\n   * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).\n\n   * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n\n   * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n\n   * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n\n   * Note that the projection instances do not inherit from Leaflet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n\n   */ var index = {\n        __proto__: null,\n        LonLat: LonLat,\n        Mercator: Mercator,\n        SphericalMercator: SphericalMercator\n    };\n    /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */ var EPSG3395 = extend({}, Earth, {\n        code: \"EPSG:3395\",\n        projection: Mercator,\n        transformation: function() {\n            var scale = 0.5 / (Math.PI * Mercator.R);\n            return toTransformation(scale, 0.5, -scale, 0.5);\n        }()\n    });\n    /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */ var EPSG4326 = extend({}, Earth, {\n        code: \"EPSG:4326\",\n        projection: LonLat,\n        transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\n    });\n    /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */ var Simple = extend({}, CRS, {\n        projection: LonLat,\n        transformation: toTransformation(1, 0, -1, 0),\n        scale: function(zoom) {\n            return Math.pow(2, zoom);\n        },\n        zoom: function(scale) {\n            return Math.log(scale) / Math.LN2;\n        },\n        distance: function(latlng1, latlng2) {\n            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;\n            return Math.sqrt(dx * dx + dy * dy);\n        },\n        infinite: true\n    });\n    CRS.Earth = Earth;\n    CRS.EPSG3395 = EPSG3395;\n    CRS.EPSG3857 = EPSG3857;\n    CRS.EPSG900913 = EPSG900913;\n    CRS.EPSG4326 = EPSG4326;\n    CRS.Simple = Simple;\n    /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */ var Layer = Evented.extend({\n        // Classes extending `L.Layer` will inherit the following options:\n        options: {\n            // @option pane: String = 'overlayPane'\n            // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n            pane: \"overlayPane\",\n            // @option attribution: String = null\n            // String to be shown in the attribution control, e.g. \"© OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n            attribution: null,\n            bubblingMouseEvents: true\n        },\n        /* @section\n  \t * Classes extending `L.Layer` will inherit the following methods:\n  \t *\n  \t * @method addTo(map: Map|LayerGroup): this\n  \t * Adds the layer to the given map or layer group.\n  \t */ addTo: function(map) {\n            map.addLayer(this);\n            return this;\n        },\n        // @method remove: this\n        // Removes the layer from the map it is currently active on.\n        remove: function() {\n            return this.removeFrom(this._map || this._mapToAdd);\n        },\n        // @method removeFrom(map: Map): this\n        // Removes the layer from the given map\n        //\n        // @alternative\n        // @method removeFrom(group: LayerGroup): this\n        // Removes the layer from the given `LayerGroup`\n        removeFrom: function(obj) {\n            if (obj) {\n                obj.removeLayer(this);\n            }\n            return this;\n        },\n        // @method getPane(name? : String): HTMLElement\n        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n        getPane: function(name) {\n            return this._map.getPane(name ? this.options[name] || name : this.options.pane);\n        },\n        addInteractiveTarget: function(targetEl) {\n            this._map._targets[stamp(targetEl)] = this;\n            return this;\n        },\n        removeInteractiveTarget: function(targetEl) {\n            delete this._map._targets[stamp(targetEl)];\n            return this;\n        },\n        // @method getAttribution: String\n        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n        getAttribution: function() {\n            return this.options.attribution;\n        },\n        _layerAdd: function(e) {\n            var map = e.target;\n            // check in case layer gets added and then removed before the map is ready\n            if (!map.hasLayer(this)) {\n                return;\n            }\n            this._map = map;\n            this._zoomAnimated = map._zoomAnimated;\n            if (this.getEvents) {\n                var events = this.getEvents();\n                map.on(events, this);\n                this.once(\"remove\", function() {\n                    map.off(events, this);\n                }, this);\n            }\n            this.onAdd(map);\n            this.fire(\"add\");\n            map.fire(\"layeradd\", {\n                layer: this\n            });\n        }\n    });\n    /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */ /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */ Map.include({\n        // @method addLayer(layer: Layer): this\n        // Adds the given layer to the map\n        addLayer: function(layer) {\n            if (!layer._layerAdd) {\n                throw new Error(\"The provided object is not a Layer.\");\n            }\n            var id = stamp(layer);\n            if (this._layers[id]) {\n                return this;\n            }\n            this._layers[id] = layer;\n            layer._mapToAdd = this;\n            if (layer.beforeAdd) {\n                layer.beforeAdd(this);\n            }\n            this.whenReady(layer._layerAdd, layer);\n            return this;\n        },\n        // @method removeLayer(layer: Layer): this\n        // Removes the given layer from the map.\n        removeLayer: function(layer) {\n            var id = stamp(layer);\n            if (!this._layers[id]) {\n                return this;\n            }\n            if (this._loaded) {\n                layer.onRemove(this);\n            }\n            delete this._layers[id];\n            if (this._loaded) {\n                this.fire(\"layerremove\", {\n                    layer: layer\n                });\n                layer.fire(\"remove\");\n            }\n            layer._map = layer._mapToAdd = null;\n            return this;\n        },\n        // @method hasLayer(layer: Layer): Boolean\n        // Returns `true` if the given layer is currently added to the map\n        hasLayer: function(layer) {\n            return stamp(layer) in this._layers;\n        },\n        /* @method eachLayer(fn: Function, context?: Object): this\n  \t * Iterates over the layers of the map, optionally specifying context of the iterator function.\n  \t * ```\n  \t * map.eachLayer(function(layer){\n  \t *     layer.bindPopup('Hello');\n  \t * });\n  \t * ```\n  \t */ eachLayer: function(method, context) {\n            for(var i in this._layers){\n                method.call(context, this._layers[i]);\n            }\n            return this;\n        },\n        _addLayers: function(layers) {\n            layers = layers ? isArray(layers) ? layers : [\n                layers\n            ] : [];\n            for(var i = 0, len = layers.length; i < len; i++){\n                this.addLayer(layers[i]);\n            }\n        },\n        _addZoomLimit: function(layer) {\n            if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n                this._zoomBoundLayers[stamp(layer)] = layer;\n                this._updateZoomLevels();\n            }\n        },\n        _removeZoomLimit: function(layer) {\n            var id = stamp(layer);\n            if (this._zoomBoundLayers[id]) {\n                delete this._zoomBoundLayers[id];\n                this._updateZoomLevels();\n            }\n        },\n        _updateZoomLevels: function() {\n            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();\n            for(var i in this._zoomBoundLayers){\n                var options = this._zoomBoundLayers[i].options;\n                minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n                maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n            }\n            this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n            this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n            // @section Map state change events\n            // @event zoomlevelschange: Event\n            // Fired when the number of zoomlevels on the map is changed due\n            // to adding or removing a layer.\n            if (oldZoomSpan !== this._getZoomSpan()) {\n                this.fire(\"zoomlevelschange\");\n            }\n            if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n                this.setZoom(this._layersMaxZoom);\n            }\n            if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n                this.setZoom(this._layersMinZoom);\n            }\n        }\n    });\n    /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */ var LayerGroup = Layer.extend({\n        initialize: function(layers, options) {\n            setOptions(this, options);\n            this._layers = {};\n            var i, len;\n            if (layers) {\n                for(i = 0, len = layers.length; i < len; i++){\n                    this.addLayer(layers[i]);\n                }\n            }\n        },\n        // @method addLayer(layer: Layer): this\n        // Adds the given layer to the group.\n        addLayer: function(layer) {\n            var id = this.getLayerId(layer);\n            this._layers[id] = layer;\n            if (this._map) {\n                this._map.addLayer(layer);\n            }\n            return this;\n        },\n        // @method removeLayer(layer: Layer): this\n        // Removes the given layer from the group.\n        // @alternative\n        // @method removeLayer(id: Number): this\n        // Removes the layer with the given internal ID from the group.\n        removeLayer: function(layer) {\n            var id = layer in this._layers ? layer : this.getLayerId(layer);\n            if (this._map && this._layers[id]) {\n                this._map.removeLayer(this._layers[id]);\n            }\n            delete this._layers[id];\n            return this;\n        },\n        // @method hasLayer(layer: Layer): Boolean\n        // Returns `true` if the given layer is currently added to the group.\n        // @alternative\n        // @method hasLayer(id: Number): Boolean\n        // Returns `true` if the given internal ID is currently added to the group.\n        hasLayer: function(layer) {\n            var layerId = typeof layer === \"number\" ? layer : this.getLayerId(layer);\n            return layerId in this._layers;\n        },\n        // @method clearLayers(): this\n        // Removes all the layers from the group.\n        clearLayers: function() {\n            return this.eachLayer(this.removeLayer, this);\n        },\n        // @method invoke(methodName: String, …): this\n        // Calls `methodName` on every layer contained in this group, passing any\n        // additional parameters. Has no effect if the layers contained do not\n        // implement `methodName`.\n        invoke: function(methodName) {\n            var args = Array.prototype.slice.call(arguments, 1), i, layer;\n            for(i in this._layers){\n                layer = this._layers[i];\n                if (layer[methodName]) {\n                    layer[methodName].apply(layer, args);\n                }\n            }\n            return this;\n        },\n        onAdd: function(map) {\n            this.eachLayer(map.addLayer, map);\n        },\n        onRemove: function(map) {\n            this.eachLayer(map.removeLayer, map);\n        },\n        // @method eachLayer(fn: Function, context?: Object): this\n        // Iterates over the layers of the group, optionally specifying context of the iterator function.\n        // ```js\n        // group.eachLayer(function (layer) {\n        // \tlayer.bindPopup('Hello');\n        // });\n        // ```\n        eachLayer: function(method, context) {\n            for(var i in this._layers){\n                method.call(context, this._layers[i]);\n            }\n            return this;\n        },\n        // @method getLayer(id: Number): Layer\n        // Returns the layer with the given internal ID.\n        getLayer: function(id) {\n            return this._layers[id];\n        },\n        // @method getLayers(): Layer[]\n        // Returns an array of all the layers added to the group.\n        getLayers: function() {\n            var layers = [];\n            this.eachLayer(layers.push, layers);\n            return layers;\n        },\n        // @method setZIndex(zIndex: Number): this\n        // Calls `setZIndex` on every layer contained in this group, passing the z-index.\n        setZIndex: function(zIndex) {\n            return this.invoke(\"setZIndex\", zIndex);\n        },\n        // @method getLayerId(layer: Layer): Number\n        // Returns the internal ID for a layer\n        getLayerId: function(layer) {\n            return stamp(layer);\n        }\n    });\n    // @factory L.layerGroup(layers?: Layer[], options?: Object)\n    // Create a layer group, optionally given an initial set of layers and an `options` object.\n    var layerGroup = function(layers, options) {\n        return new LayerGroup(layers, options);\n    };\n    /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */ var FeatureGroup = LayerGroup.extend({\n        addLayer: function(layer) {\n            if (this.hasLayer(layer)) {\n                return this;\n            }\n            layer.addEventParent(this);\n            LayerGroup.prototype.addLayer.call(this, layer);\n            // @event layeradd: LayerEvent\n            // Fired when a layer is added to this `FeatureGroup`\n            return this.fire(\"layeradd\", {\n                layer: layer\n            });\n        },\n        removeLayer: function(layer) {\n            if (!this.hasLayer(layer)) {\n                return this;\n            }\n            if (layer in this._layers) {\n                layer = this._layers[layer];\n            }\n            layer.removeEventParent(this);\n            LayerGroup.prototype.removeLayer.call(this, layer);\n            // @event layerremove: LayerEvent\n            // Fired when a layer is removed from this `FeatureGroup`\n            return this.fire(\"layerremove\", {\n                layer: layer\n            });\n        },\n        // @method setStyle(style: Path options): this\n        // Sets the given path options to each layer of the group that has a `setStyle` method.\n        setStyle: function(style) {\n            return this.invoke(\"setStyle\", style);\n        },\n        // @method bringToFront(): this\n        // Brings the layer group to the top of all other layers\n        bringToFront: function() {\n            return this.invoke(\"bringToFront\");\n        },\n        // @method bringToBack(): this\n        // Brings the layer group to the back of all other layers\n        bringToBack: function() {\n            return this.invoke(\"bringToBack\");\n        },\n        // @method getBounds(): LatLngBounds\n        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\n        getBounds: function() {\n            var bounds = new LatLngBounds();\n            for(var id in this._layers){\n                var layer = this._layers[id];\n                bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\n            }\n            return bounds;\n        }\n    });\n    // @factory L.featureGroup(layers?: Layer[], options?: Object)\n    // Create a feature group, optionally given an initial set of layers and an `options` object.\n    var featureGroup = function(layers, options) {\n        return new FeatureGroup(layers, options);\n    };\n    /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */ var Icon = Class.extend({\n        /* @section\r\n  \t * @aka Icon options\r\n  \t *\r\n  \t * @option iconUrl: String = null\r\n  \t * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n  \t *\r\n  \t * @option iconRetinaUrl: String = null\r\n  \t * The URL to a retina sized version of the icon image (absolute or relative to your\r\n  \t * script path). Used for Retina screen devices.\r\n  \t *\r\n  \t * @option iconSize: Point = null\r\n  \t * Size of the icon image in pixels.\r\n  \t *\r\n  \t * @option iconAnchor: Point = null\r\n  \t * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n  \t * will be aligned so that this point is at the marker's geographical location. Centered\r\n  \t * by default if size is specified, also can be set in CSS with negative margins.\r\n  \t *\r\n  \t * @option popupAnchor: Point = [0, 0]\r\n  \t * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n  \t *\r\n  \t * @option tooltipAnchor: Point = [0, 0]\r\n  \t * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n  \t *\r\n  \t * @option shadowUrl: String = null\r\n  \t * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n  \t *\r\n  \t * @option shadowRetinaUrl: String = null\r\n  \t *\r\n  \t * @option shadowSize: Point = null\r\n  \t * Size of the shadow image in pixels.\r\n  \t *\r\n  \t * @option shadowAnchor: Point = null\r\n  \t * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n  \t * as iconAnchor if not specified).\r\n  \t *\r\n  \t * @option className: String = ''\r\n  \t * A custom class name to assign to both icon and shadow images. Empty by default.\r\n  \t */ options: {\n            popupAnchor: [\n                0,\n                0\n            ],\n            tooltipAnchor: [\n                0,\n                0\n            ],\n            // @option crossOrigin: Boolean|String = false\n            // Whether the crossOrigin attribute will be added to the tiles.\n            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n            crossOrigin: false\n        },\n        initialize: function(options) {\n            setOptions(this, options);\n        },\n        // @method createIcon(oldIcon?: HTMLElement): HTMLElement\n        // Called internally when the icon has to be shown, returns a `<img>` HTML element\n        // styled according to the options.\n        createIcon: function(oldIcon) {\n            return this._createIcon(\"icon\", oldIcon);\n        },\n        // @method createShadow(oldIcon?: HTMLElement): HTMLElement\n        // As `createIcon`, but for the shadow beneath it.\n        createShadow: function(oldIcon) {\n            return this._createIcon(\"shadow\", oldIcon);\n        },\n        _createIcon: function(name, oldIcon) {\n            var src = this._getIconUrl(name);\n            if (!src) {\n                if (name === \"icon\") {\n                    throw new Error(\"iconUrl not set in Icon options (see the docs).\");\n                }\n                return null;\n            }\n            var img = this._createImg(src, oldIcon && oldIcon.tagName === \"IMG\" ? oldIcon : null);\n            this._setIconStyles(img, name);\n            if (this.options.crossOrigin || this.options.crossOrigin === \"\") {\n                img.crossOrigin = this.options.crossOrigin === true ? \"\" : this.options.crossOrigin;\n            }\n            return img;\n        },\n        _setIconStyles: function(img, name) {\n            var options = this.options;\n            var sizeOption = options[name + \"Size\"];\n            if (typeof sizeOption === \"number\") {\n                sizeOption = [\n                    sizeOption,\n                    sizeOption\n                ];\n            }\n            var size = toPoint(sizeOption), anchor = toPoint(name === \"shadow\" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));\n            img.className = \"leaflet-marker-\" + name + \" \" + (options.className || \"\");\n            if (anchor) {\n                img.style.marginLeft = -anchor.x + \"px\";\n                img.style.marginTop = -anchor.y + \"px\";\n            }\n            if (size) {\n                img.style.width = size.x + \"px\";\n                img.style.height = size.y + \"px\";\n            }\n        },\n        _createImg: function(src, el) {\n            el = el || document.createElement(\"img\");\n            el.src = src;\n            return el;\n        },\n        _getIconUrl: function(name) {\n            return Browser.retina && this.options[name + \"RetinaUrl\"] || this.options[name + \"Url\"];\n        }\n    });\n    // @factory L.icon(options: Icon options)\n    // Creates an icon instance with the given options.\n    function icon(options) {\n        return new Icon(options);\n    }\n    /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */ var IconDefault = Icon.extend({\n        options: {\n            iconUrl: \"marker-icon.png\",\n            iconRetinaUrl: \"marker-icon-2x.png\",\n            shadowUrl: \"marker-shadow.png\",\n            iconSize: [\n                25,\n                41\n            ],\n            iconAnchor: [\n                12,\n                41\n            ],\n            popupAnchor: [\n                1,\n                -34\n            ],\n            tooltipAnchor: [\n                16,\n                -28\n            ],\n            shadowSize: [\n                41,\n                41\n            ]\n        },\n        _getIconUrl: function(name) {\n            if (typeof IconDefault.imagePath !== \"string\") {\n                IconDefault.imagePath = this._detectIconPath();\n            }\n            // @option imagePath: String\n            // `Icon.Default` will try to auto-detect the location of the\n            // blue icon images. If you are placing these images in a non-standard\n            // way, set this option to point to the right path.\n            return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n        },\n        _stripUrl: function(path) {\n            var strip = function(str, re, idx) {\n                var match = re.exec(str);\n                return match && match[idx];\n            };\n            path = strip(path, /^url\\((['\"])?(.+)\\1\\)$/, 2);\n            return path && strip(path, /^(.*)marker-icon\\.png$/, 1);\n        },\n        _detectIconPath: function() {\n            var el = create$1(\"div\", \"leaflet-default-icon-path\", document.body);\n            var path = getStyle(el, \"background-image\") || getStyle(el, \"backgroundImage\"); // IE8\n            document.body.removeChild(el);\n            path = this._stripUrl(path);\n            if (path) {\n                return path;\n            }\n            var link = document.querySelector('link[href$=\"leaflet.css\"]');\n            if (!link) {\n                return \"\";\n            }\n            return link.href.substring(0, link.href.length - \"leaflet.css\".length - 1);\n        }\n    });\n    /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */ /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */ var MarkerDrag = Handler.extend({\n        initialize: function(marker) {\n            this._marker = marker;\n        },\n        addHooks: function() {\n            var icon = this._marker._icon;\n            if (!this._draggable) {\n                this._draggable = new Draggable(icon, icon, true);\n            }\n            this._draggable.on({\n                dragstart: this._onDragStart,\n                predrag: this._onPreDrag,\n                drag: this._onDrag,\n                dragend: this._onDragEnd\n            }, this).enable();\n            addClass(icon, \"leaflet-marker-draggable\");\n        },\n        removeHooks: function() {\n            this._draggable.off({\n                dragstart: this._onDragStart,\n                predrag: this._onPreDrag,\n                drag: this._onDrag,\n                dragend: this._onDragEnd\n            }, this).disable();\n            if (this._marker._icon) {\n                removeClass(this._marker._icon, \"leaflet-marker-draggable\");\n            }\n        },\n        moved: function() {\n            return this._draggable && this._draggable._moved;\n        },\n        _adjustPan: function(e) {\n            var marker = this._marker, map = marker._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();\n            var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));\n            if (!panBounds.contains(iconPos)) {\n                // Compute incremental movement\n                var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);\n                map.panBy(movement, {\n                    animate: false\n                });\n                this._draggable._newPos._add(movement);\n                this._draggable._startPos._add(movement);\n                setPosition(marker._icon, this._draggable._newPos);\n                this._onDrag(e);\n                this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n            }\n        },\n        _onDragStart: function() {\n            // @section Dragging events\n            // @event dragstart: Event\n            // Fired when the user starts dragging the marker.\n            // @event movestart: Event\n            // Fired when the marker starts moving (because of dragging).\n            this._oldLatLng = this._marker.getLatLng();\n            // When using ES6 imports it could not be set when `Popup` was not imported as well\n            this._marker.closePopup && this._marker.closePopup();\n            this._marker.fire(\"movestart\").fire(\"dragstart\");\n        },\n        _onPreDrag: function(e) {\n            if (this._marker.options.autoPan) {\n                cancelAnimFrame(this._panRequest);\n                this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n            }\n        },\n        _onDrag: function(e) {\n            var marker = this._marker, shadow = marker._shadow, iconPos = getPosition(marker._icon), latlng = marker._map.layerPointToLatLng(iconPos);\n            // update shadow position\n            if (shadow) {\n                setPosition(shadow, iconPos);\n            }\n            marker._latlng = latlng;\n            e.latlng = latlng;\n            e.oldLatLng = this._oldLatLng;\n            // @event drag: Event\n            // Fired repeatedly while the user drags the marker.\n            marker.fire(\"move\", e).fire(\"drag\", e);\n        },\n        _onDragEnd: function(e) {\n            // @event dragend: DragEndEvent\n            // Fired when the user stops dragging the marker.\n            cancelAnimFrame(this._panRequest);\n            // @event moveend: Event\n            // Fired when the marker stops moving (because of dragging).\n            delete this._oldLatLng;\n            this._marker.fire(\"moveend\").fire(\"dragend\", e);\n        }\n    });\n    /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */ var Marker = Layer.extend({\n        // @section\n        // @aka Marker options\n        options: {\n            // @option icon: Icon = *\n            // Icon instance to use for rendering the marker.\n            // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\n            // If not specified, a common instance of `L.Icon.Default` is used.\n            icon: new IconDefault(),\n            // Option inherited from \"Interactive layer\" abstract class\n            interactive: true,\n            // @option keyboard: Boolean = true\n            // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\n            keyboard: true,\n            // @option title: String = ''\n            // Text for the browser tooltip that appear on marker hover (no tooltip by default).\n            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n            title: \"\",\n            // @option alt: String = 'Marker'\n            // Text for the `alt` attribute of the icon image.\n            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\n            alt: \"Marker\",\n            // @option zIndexOffset: Number = 0\n            // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\n            zIndexOffset: 0,\n            // @option opacity: Number = 1.0\n            // The opacity of the marker.\n            opacity: 1,\n            // @option riseOnHover: Boolean = false\n            // If `true`, the marker will get on top of others when you hover the mouse over it.\n            riseOnHover: false,\n            // @option riseOffset: Number = 250\n            // The z-index offset used for the `riseOnHover` feature.\n            riseOffset: 250,\n            // @option pane: String = 'markerPane'\n            // `Map pane` where the markers icon will be added.\n            pane: \"markerPane\",\n            // @option shadowPane: String = 'shadowPane'\n            // `Map pane` where the markers shadow will be added.\n            shadowPane: \"shadowPane\",\n            // @option bubblingMouseEvents: Boolean = false\n            // When `true`, a mouse event on this marker will trigger the same event on the map\n            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n            bubblingMouseEvents: false,\n            // @option autoPanOnFocus: Boolean = true\n            // When `true`, the map will pan whenever the marker is focused (via\n            // e.g. pressing `tab` on the keyboard) to ensure the marker is\n            // visible within the map's bounds\n            autoPanOnFocus: true,\n            // @section Draggable marker options\n            // @option draggable: Boolean = false\n            // Whether the marker is draggable with mouse/touch or not.\n            draggable: false,\n            // @option autoPan: Boolean = false\n            // Whether to pan the map when dragging this marker near its edge or not.\n            autoPan: false,\n            // @option autoPanPadding: Point = Point(50, 50)\n            // Distance (in pixels to the left/right and to the top/bottom) of the\n            // map edge to start panning the map.\n            autoPanPadding: [\n                50,\n                50\n            ],\n            // @option autoPanSpeed: Number = 10\n            // Number of pixels the map should pan by.\n            autoPanSpeed: 10\n        },\n        /* @section\r\n  \t *\r\n  \t * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n  \t */ initialize: function(latlng, options) {\n            setOptions(this, options);\n            this._latlng = toLatLng(latlng);\n        },\n        onAdd: function(map) {\n            this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\n            if (this._zoomAnimated) {\n                map.on(\"zoomanim\", this._animateZoom, this);\n            }\n            this._initIcon();\n            this.update();\n        },\n        onRemove: function(map) {\n            if (this.dragging && this.dragging.enabled()) {\n                this.options.draggable = true;\n                this.dragging.removeHooks();\n            }\n            delete this.dragging;\n            if (this._zoomAnimated) {\n                map.off(\"zoomanim\", this._animateZoom, this);\n            }\n            this._removeIcon();\n            this._removeShadow();\n        },\n        getEvents: function() {\n            return {\n                zoom: this.update,\n                viewreset: this.update\n            };\n        },\n        // @method getLatLng: LatLng\n        // Returns the current geographical position of the marker.\n        getLatLng: function() {\n            return this._latlng;\n        },\n        // @method setLatLng(latlng: LatLng): this\n        // Changes the marker position to the given point.\n        setLatLng: function(latlng) {\n            var oldLatLng = this._latlng;\n            this._latlng = toLatLng(latlng);\n            this.update();\n            // @event move: Event\n            // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n            return this.fire(\"move\", {\n                oldLatLng: oldLatLng,\n                latlng: this._latlng\n            });\n        },\n        // @method setZIndexOffset(offset: Number): this\n        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.\n        setZIndexOffset: function(offset) {\n            this.options.zIndexOffset = offset;\n            return this.update();\n        },\n        // @method getIcon: Icon\n        // Returns the current icon used by the marker\n        getIcon: function() {\n            return this.options.icon;\n        },\n        // @method setIcon(icon: Icon): this\n        // Changes the marker icon.\n        setIcon: function(icon) {\n            this.options.icon = icon;\n            if (this._map) {\n                this._initIcon();\n                this.update();\n            }\n            if (this._popup) {\n                this.bindPopup(this._popup, this._popup.options);\n            }\n            return this;\n        },\n        getElement: function() {\n            return this._icon;\n        },\n        update: function() {\n            if (this._icon && this._map) {\n                var pos = this._map.latLngToLayerPoint(this._latlng).round();\n                this._setPos(pos);\n            }\n            return this;\n        },\n        _initIcon: function() {\n            var options = this.options, classToAdd = \"leaflet-zoom-\" + (this._zoomAnimated ? \"animated\" : \"hide\");\n            var icon = options.icon.createIcon(this._icon), addIcon = false;\n            // if we're not reusing the icon, remove the old one and init new one\n            if (icon !== this._icon) {\n                if (this._icon) {\n                    this._removeIcon();\n                }\n                addIcon = true;\n                if (options.title) {\n                    icon.title = options.title;\n                }\n                if (icon.tagName === \"IMG\") {\n                    icon.alt = options.alt || \"\";\n                }\n            }\n            addClass(icon, classToAdd);\n            if (options.keyboard) {\n                icon.tabIndex = \"0\";\n                icon.setAttribute(\"role\", \"button\");\n            }\n            this._icon = icon;\n            if (options.riseOnHover) {\n                this.on({\n                    mouseover: this._bringToFront,\n                    mouseout: this._resetZIndex\n                });\n            }\n            if (this.options.autoPanOnFocus) {\n                on(icon, \"focus\", this._panOnFocus, this);\n            }\n            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;\n            if (newShadow !== this._shadow) {\n                this._removeShadow();\n                addShadow = true;\n            }\n            if (newShadow) {\n                addClass(newShadow, classToAdd);\n                newShadow.alt = \"\";\n            }\n            this._shadow = newShadow;\n            if (options.opacity < 1) {\n                this._updateOpacity();\n            }\n            if (addIcon) {\n                this.getPane().appendChild(this._icon);\n            }\n            this._initInteraction();\n            if (newShadow && addShadow) {\n                this.getPane(options.shadowPane).appendChild(this._shadow);\n            }\n        },\n        _removeIcon: function() {\n            if (this.options.riseOnHover) {\n                this.off({\n                    mouseover: this._bringToFront,\n                    mouseout: this._resetZIndex\n                });\n            }\n            if (this.options.autoPanOnFocus) {\n                off(this._icon, \"focus\", this._panOnFocus, this);\n            }\n            remove(this._icon);\n            this.removeInteractiveTarget(this._icon);\n            this._icon = null;\n        },\n        _removeShadow: function() {\n            if (this._shadow) {\n                remove(this._shadow);\n            }\n            this._shadow = null;\n        },\n        _setPos: function(pos) {\n            if (this._icon) {\n                setPosition(this._icon, pos);\n            }\n            if (this._shadow) {\n                setPosition(this._shadow, pos);\n            }\n            this._zIndex = pos.y + this.options.zIndexOffset;\n            this._resetZIndex();\n        },\n        _updateZIndex: function(offset) {\n            if (this._icon) {\n                this._icon.style.zIndex = this._zIndex + offset;\n            }\n        },\n        _animateZoom: function(opt) {\n            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n            this._setPos(pos);\n        },\n        _initInteraction: function() {\n            if (!this.options.interactive) {\n                return;\n            }\n            addClass(this._icon, \"leaflet-interactive\");\n            this.addInteractiveTarget(this._icon);\n            if (MarkerDrag) {\n                var draggable = this.options.draggable;\n                if (this.dragging) {\n                    draggable = this.dragging.enabled();\n                    this.dragging.disable();\n                }\n                this.dragging = new MarkerDrag(this);\n                if (draggable) {\n                    this.dragging.enable();\n                }\n            }\n        },\n        // @method setOpacity(opacity: Number): this\n        // Changes the opacity of the marker.\n        setOpacity: function(opacity) {\n            this.options.opacity = opacity;\n            if (this._map) {\n                this._updateOpacity();\n            }\n            return this;\n        },\n        _updateOpacity: function() {\n            var opacity = this.options.opacity;\n            if (this._icon) {\n                setOpacity(this._icon, opacity);\n            }\n            if (this._shadow) {\n                setOpacity(this._shadow, opacity);\n            }\n        },\n        _bringToFront: function() {\n            this._updateZIndex(this.options.riseOffset);\n        },\n        _resetZIndex: function() {\n            this._updateZIndex(0);\n        },\n        _panOnFocus: function() {\n            var map = this._map;\n            if (!map) {\n                return;\n            }\n            var iconOpts = this.options.icon.options;\n            var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);\n            var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);\n            map.panInside(this._latlng, {\n                paddingTopLeft: anchor,\n                paddingBottomRight: size.subtract(anchor)\n            });\n        },\n        _getPopupAnchor: function() {\n            return this.options.icon.options.popupAnchor;\n        },\n        _getTooltipAnchor: function() {\n            return this.options.icon.options.tooltipAnchor;\n        }\n    });\n    // factory L.marker(latlng: LatLng, options? : Marker options)\n    // @factory L.marker(latlng: LatLng, options? : Marker options)\n    // Instantiates a Marker object given a geographical point and optionally an options object.\n    function marker(latlng, options) {\n        return new Marker(latlng, options);\n    }\n    /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */ var Path = Layer.extend({\n        // @section\n        // @aka Path options\n        options: {\n            // @option stroke: Boolean = true\n            // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n            stroke: true,\n            // @option color: String = '#3388ff'\n            // Stroke color\n            color: \"#3388ff\",\n            // @option weight: Number = 3\n            // Stroke width in pixels\n            weight: 3,\n            // @option opacity: Number = 1.0\n            // Stroke opacity\n            opacity: 1,\n            // @option lineCap: String= 'round'\n            // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n            lineCap: \"round\",\n            // @option lineJoin: String = 'round'\n            // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n            lineJoin: \"round\",\n            // @option dashArray: String = null\n            // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n            dashArray: null,\n            // @option dashOffset: String = null\n            // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n            dashOffset: null,\n            // @option fill: Boolean = depends\n            // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n            fill: false,\n            // @option fillColor: String = *\n            // Fill color. Defaults to the value of the [`color`](#path-color) option\n            fillColor: null,\n            // @option fillOpacity: Number = 0.2\n            // Fill opacity.\n            fillOpacity: 0.2,\n            // @option fillRule: String = 'evenodd'\n            // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n            fillRule: \"evenodd\",\n            // className: '',\n            // Option inherited from \"Interactive layer\" abstract class\n            interactive: true,\n            // @option bubblingMouseEvents: Boolean = true\n            // When `true`, a mouse event on this path will trigger the same event on the map\n            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n            bubblingMouseEvents: true\n        },\n        beforeAdd: function(map) {\n            // Renderer is set here because we need to call renderer.getEvents\n            // before this.getEvents.\n            this._renderer = map.getRenderer(this);\n        },\n        onAdd: function() {\n            this._renderer._initPath(this);\n            this._reset();\n            this._renderer._addPath(this);\n        },\n        onRemove: function() {\n            this._renderer._removePath(this);\n        },\n        // @method redraw(): this\n        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n        redraw: function() {\n            if (this._map) {\n                this._renderer._updatePath(this);\n            }\n            return this;\n        },\n        // @method setStyle(style: Path options): this\n        // Changes the appearance of a Path based on the options in the `Path options` object.\n        setStyle: function(style) {\n            setOptions(this, style);\n            if (this._renderer) {\n                this._renderer._updateStyle(this);\n                if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, \"weight\")) {\n                    this._updateBounds();\n                }\n            }\n            return this;\n        },\n        // @method bringToFront(): this\n        // Brings the layer to the top of all path layers.\n        bringToFront: function() {\n            if (this._renderer) {\n                this._renderer._bringToFront(this);\n            }\n            return this;\n        },\n        // @method bringToBack(): this\n        // Brings the layer to the bottom of all path layers.\n        bringToBack: function() {\n            if (this._renderer) {\n                this._renderer._bringToBack(this);\n            }\n            return this;\n        },\n        getElement: function() {\n            return this._path;\n        },\n        _reset: function() {\n            // defined in child classes\n            this._project();\n            this._update();\n        },\n        _clickTolerance: function() {\n            // used when doing hit detection for Canvas layers\n            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);\n        }\n    });\n    /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */ var CircleMarker = Path.extend({\n        // @section\n        // @aka CircleMarker options\n        options: {\n            fill: true,\n            // @option radius: Number = 10\n            // Radius of the circle marker, in pixels\n            radius: 10\n        },\n        initialize: function(latlng, options) {\n            setOptions(this, options);\n            this._latlng = toLatLng(latlng);\n            this._radius = this.options.radius;\n        },\n        // @method setLatLng(latLng: LatLng): this\n        // Sets the position of a circle marker to a new location.\n        setLatLng: function(latlng) {\n            var oldLatLng = this._latlng;\n            this._latlng = toLatLng(latlng);\n            this.redraw();\n            // @event move: Event\n            // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n            return this.fire(\"move\", {\n                oldLatLng: oldLatLng,\n                latlng: this._latlng\n            });\n        },\n        // @method getLatLng(): LatLng\n        // Returns the current geographical position of the circle marker\n        getLatLng: function() {\n            return this._latlng;\n        },\n        // @method setRadius(radius: Number): this\n        // Sets the radius of a circle marker. Units are in pixels.\n        setRadius: function(radius) {\n            this.options.radius = this._radius = radius;\n            return this.redraw();\n        },\n        // @method getRadius(): Number\n        // Returns the current radius of the circle\n        getRadius: function() {\n            return this._radius;\n        },\n        setStyle: function(options) {\n            var radius = options && options.radius || this._radius;\n            Path.prototype.setStyle.call(this, options);\n            this.setRadius(radius);\n            return this;\n        },\n        _project: function() {\n            this._point = this._map.latLngToLayerPoint(this._latlng);\n            this._updateBounds();\n        },\n        _updateBounds: function() {\n            var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [\n                r + w,\n                r2 + w\n            ];\n            this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n        },\n        _update: function() {\n            if (this._map) {\n                this._updatePath();\n            }\n        },\n        _updatePath: function() {\n            this._renderer._updateCircle(this);\n        },\n        _empty: function() {\n            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n        },\n        // Needed by the `Canvas` renderer for interactivity\n        _containsPoint: function(p) {\n            return p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n        }\n    });\n    // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n    // Instantiates a circle marker object given a geographical point, and an optional options object.\n    function circleMarker(latlng, options) {\n        return new CircleMarker(latlng, options);\n    }\n    /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */ var Circle = CircleMarker.extend({\n        initialize: function(latlng, options, legacyOptions) {\n            if (typeof options === \"number\") {\n                // Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n                options = extend({}, legacyOptions, {\n                    radius: options\n                });\n            }\n            setOptions(this, options);\n            this._latlng = toLatLng(latlng);\n            if (isNaN(this.options.radius)) {\n                throw new Error(\"Circle radius cannot be NaN\");\n            }\n            // @section\n            // @aka Circle options\n            // @option radius: Number; Radius of the circle, in meters.\n            this._mRadius = this.options.radius;\n        },\n        // @method setRadius(radius: Number): this\n        // Sets the radius of a circle. Units are in meters.\n        setRadius: function(radius) {\n            this._mRadius = radius;\n            return this.redraw();\n        },\n        // @method getRadius(): Number\n        // Returns the current radius of a circle. Units are in meters.\n        getRadius: function() {\n            return this._mRadius;\n        },\n        // @method getBounds(): LatLngBounds\n        // Returns the `LatLngBounds` of the path.\n        getBounds: function() {\n            var half = [\n                this._radius,\n                this._radiusY || this._radius\n            ];\n            return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));\n        },\n        setStyle: Path.prototype.setStyle,\n        _project: function() {\n            var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;\n            if (crs.distance === Earth.distance) {\n                var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([\n                    lat + latR,\n                    lng\n                ]), bottom = map.project([\n                    lat - latR,\n                    lng\n                ]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n                if (isNaN(lngR) || lngR === 0) {\n                    lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n                }\n                this._point = p.subtract(map.getPixelOrigin());\n                this._radius = isNaN(lngR) ? 0 : p.x - map.project([\n                    lat2,\n                    lng - lngR\n                ]).x;\n                this._radiusY = p.y - top.y;\n            } else {\n                var latlng2 = crs.unproject(crs.project(this._latlng).subtract([\n                    this._mRadius,\n                    0\n                ]));\n                this._point = map.latLngToLayerPoint(this._latlng);\n                this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n            }\n            this._updateBounds();\n        }\n    });\n    // @factory L.circle(latlng: LatLng, options?: Circle options)\n    // Instantiates a circle object given a geographical point, and an options object\n    // which contains the circle radius.\n    // @alternative\n    // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n    // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n    // Do not use in new applications or plugins.\n    function circle(latlng, options, legacyOptions) {\n        return new Circle(latlng, options, legacyOptions);\n    }\n    /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */ var Polyline = Path.extend({\n        // @section\n        // @aka Polyline options\n        options: {\n            // @option smoothFactor: Number = 1.0\n            // How much to simplify the polyline on each zoom level. More means\n            // better performance and smoother look, and less means more accurate representation.\n            smoothFactor: 1.0,\n            // @option noClip: Boolean = false\n            // Disable polyline clipping.\n            noClip: false\n        },\n        initialize: function(latlngs, options) {\n            setOptions(this, options);\n            this._setLatLngs(latlngs);\n        },\n        // @method getLatLngs(): LatLng[]\n        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n        getLatLngs: function() {\n            return this._latlngs;\n        },\n        // @method setLatLngs(latlngs: LatLng[]): this\n        // Replaces all the points in the polyline with the given array of geographical points.\n        setLatLngs: function(latlngs) {\n            this._setLatLngs(latlngs);\n            return this.redraw();\n        },\n        // @method isEmpty(): Boolean\n        // Returns `true` if the Polyline has no LatLngs.\n        isEmpty: function() {\n            return !this._latlngs.length;\n        },\n        // @method closestLayerPoint(p: Point): Point\n        // Returns the point closest to `p` on the Polyline.\n        closestLayerPoint: function(p) {\n            var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;\n            for(var j = 0, jLen = this._parts.length; j < jLen; j++){\n                var points = this._parts[j];\n                for(var i = 1, len = points.length; i < len; i++){\n                    p1 = points[i - 1];\n                    p2 = points[i];\n                    var sqDist = closest(p, p1, p2, true);\n                    if (sqDist < minDistance) {\n                        minDistance = sqDist;\n                        minPoint = closest(p, p1, p2);\n                    }\n                }\n            }\n            if (minPoint) {\n                minPoint.distance = Math.sqrt(minDistance);\n            }\n            return minPoint;\n        },\n        // @method getCenter(): LatLng\n        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.\n        getCenter: function() {\n            // throws error when not yet added to map as this center calculation requires projected coordinates\n            if (!this._map) {\n                throw new Error(\"Must add layer to map before using getCenter()\");\n            }\n            return polylineCenter(this._defaultShape(), this._map.options.crs);\n        },\n        // @method getBounds(): LatLngBounds\n        // Returns the `LatLngBounds` of the path.\n        getBounds: function() {\n            return this._bounds;\n        },\n        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\n        // Adds a given point to the polyline. By default, adds to the first ring of\n        // the polyline in case of a multi-polyline, but can be overridden by passing\n        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n        addLatLng: function(latlng, latlngs) {\n            latlngs = latlngs || this._defaultShape();\n            latlng = toLatLng(latlng);\n            latlngs.push(latlng);\n            this._bounds.extend(latlng);\n            return this.redraw();\n        },\n        _setLatLngs: function(latlngs) {\n            this._bounds = new LatLngBounds();\n            this._latlngs = this._convertLatLngs(latlngs);\n        },\n        _defaultShape: function() {\n            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n        },\n        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n        _convertLatLngs: function(latlngs) {\n            var result = [], flat = isFlat(latlngs);\n            for(var i = 0, len = latlngs.length; i < len; i++){\n                if (flat) {\n                    result[i] = toLatLng(latlngs[i]);\n                    this._bounds.extend(result[i]);\n                } else {\n                    result[i] = this._convertLatLngs(latlngs[i]);\n                }\n            }\n            return result;\n        },\n        _project: function() {\n            var pxBounds = new Bounds();\n            this._rings = [];\n            this._projectLatlngs(this._latlngs, this._rings, pxBounds);\n            if (this._bounds.isValid() && pxBounds.isValid()) {\n                this._rawPxBounds = pxBounds;\n                this._updateBounds();\n            }\n        },\n        _updateBounds: function() {\n            var w = this._clickTolerance(), p = new Point(w, w);\n            if (!this._rawPxBounds) {\n                return;\n            }\n            this._pxBounds = new Bounds([\n                this._rawPxBounds.min.subtract(p),\n                this._rawPxBounds.max.add(p)\n            ]);\n        },\n        // recursively turns latlngs into a set of rings with projected coordinates\n        _projectLatlngs: function(latlngs, result, projectedBounds) {\n            var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;\n            if (flat) {\n                ring = [];\n                for(i = 0; i < len; i++){\n                    ring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n                    projectedBounds.extend(ring[i]);\n                }\n                result.push(ring);\n            } else {\n                for(i = 0; i < len; i++){\n                    this._projectLatlngs(latlngs[i], result, projectedBounds);\n                }\n            }\n        },\n        // clip polyline by renderer bounds so that we have less to render for performance\n        _clipPoints: function() {\n            var bounds = this._renderer._bounds;\n            this._parts = [];\n            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n                return;\n            }\n            if (this.options.noClip) {\n                this._parts = this._rings;\n                return;\n            }\n            var parts = this._parts, i, j, k, len, len2, segment, points;\n            for(i = 0, k = 0, len = this._rings.length; i < len; i++){\n                points = this._rings[i];\n                for(j = 0, len2 = points.length; j < len2 - 1; j++){\n                    segment = clipSegment(points[j], points[j + 1], bounds, j, true);\n                    if (!segment) {\n                        continue;\n                    }\n                    parts[k] = parts[k] || [];\n                    parts[k].push(segment[0]);\n                    // if segment goes out of screen, or it's the last one, it's the end of the line part\n                    if (segment[1] !== points[j + 1] || j === len2 - 2) {\n                        parts[k].push(segment[1]);\n                        k++;\n                    }\n                }\n            }\n        },\n        // simplify each clipped part of the polyline for performance\n        _simplifyPoints: function() {\n            var parts = this._parts, tolerance = this.options.smoothFactor;\n            for(var i = 0, len = parts.length; i < len; i++){\n                parts[i] = simplify(parts[i], tolerance);\n            }\n        },\n        _update: function() {\n            if (!this._map) {\n                return;\n            }\n            this._clipPoints();\n            this._simplifyPoints();\n            this._updatePath();\n        },\n        _updatePath: function() {\n            this._renderer._updatePoly(this);\n        },\n        // Needed by the `Canvas` renderer for interactivity\n        _containsPoint: function(p, closed) {\n            var i, j, k, len, len2, part, w = this._clickTolerance();\n            if (!this._pxBounds || !this._pxBounds.contains(p)) {\n                return false;\n            }\n            // hit detection for polylines\n            for(i = 0, len = this._parts.length; i < len; i++){\n                part = this._parts[i];\n                for(j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++){\n                    if (!closed && j === 0) {\n                        continue;\n                    }\n                    if (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    });\n    // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n    // Instantiates a polyline object given an array of geographical points and\n    // optionally an options object. You can create a `Polyline` object with\n    // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n    // of geographic points.\n    function polyline(latlngs, options) {\n        return new Polyline(latlngs, options);\n    }\n    // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n    Polyline._flat = _flat;\n    /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */ var Polygon = Polyline.extend({\n        options: {\n            fill: true\n        },\n        isEmpty: function() {\n            return !this._latlngs.length || !this._latlngs[0].length;\n        },\n        // @method getCenter(): LatLng\n        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.\n        getCenter: function() {\n            // throws error when not yet added to map as this center calculation requires projected coordinates\n            if (!this._map) {\n                throw new Error(\"Must add layer to map before using getCenter()\");\n            }\n            return polygonCenter(this._defaultShape(), this._map.options.crs);\n        },\n        _convertLatLngs: function(latlngs) {\n            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;\n            // remove last point if it equals first one\n            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n                result.pop();\n            }\n            return result;\n        },\n        _setLatLngs: function(latlngs) {\n            Polyline.prototype._setLatLngs.call(this, latlngs);\n            if (isFlat(this._latlngs)) {\n                this._latlngs = [\n                    this._latlngs\n                ];\n            }\n        },\n        _defaultShape: function() {\n            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n        },\n        _clipPoints: function() {\n            // polygons need a different clipping algorithm so we redefine that\n            var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);\n            // increase clip padding by stroke width to avoid stroke on clip edges\n            bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n            this._parts = [];\n            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n                return;\n            }\n            if (this.options.noClip) {\n                this._parts = this._rings;\n                return;\n            }\n            for(var i = 0, len = this._rings.length, clipped; i < len; i++){\n                clipped = clipPolygon(this._rings[i], bounds, true);\n                if (clipped.length) {\n                    this._parts.push(clipped);\n                }\n            }\n        },\n        _updatePath: function() {\n            this._renderer._updatePoly(this, true);\n        },\n        // Needed by the `Canvas` renderer for interactivity\n        _containsPoint: function(p) {\n            var inside = false, part, p1, p2, i, j, k, len, len2;\n            if (!this._pxBounds || !this._pxBounds.contains(p)) {\n                return false;\n            }\n            // ray casting algorithm for detecting if point is in polygon\n            for(i = 0, len = this._parts.length; i < len; i++){\n                part = this._parts[i];\n                for(j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++){\n                    p1 = part[j];\n                    p2 = part[k];\n                    if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {\n                        inside = !inside;\n                    }\n                }\n            }\n            // also check if it's on polygon stroke\n            return inside || Polyline.prototype._containsPoint.call(this, p, true);\n        }\n    });\n    // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n    function polygon(latlngs, options) {\n        return new Polygon(latlngs, options);\n    }\n    /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */ var GeoJSON = FeatureGroup.extend({\n        /* @section\r\n  \t * @aka GeoJSON options\r\n  \t *\r\n  \t * @option pointToLayer: Function = *\r\n  \t * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n  \t * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n  \t * The default is to spawn a default `Marker`:\r\n  \t * ```js\r\n  \t * function(geoJsonPoint, latlng) {\r\n  \t * \treturn L.marker(latlng);\r\n  \t * }\r\n  \t * ```\r\n  \t *\r\n  \t * @option style: Function = *\r\n  \t * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n  \t * called internally when data is added.\r\n  \t * The default value is to not override any defaults:\r\n  \t * ```js\r\n  \t * function (geoJsonFeature) {\r\n  \t * \treturn {}\r\n  \t * }\r\n  \t * ```\r\n  \t *\r\n  \t * @option onEachFeature: Function = *\r\n  \t * A `Function` that will be called once for each created `Feature`, after it has\r\n  \t * been created and styled. Useful for attaching events and popups to features.\r\n  \t * The default is to do nothing with the newly created layers:\r\n  \t * ```js\r\n  \t * function (feature, layer) {}\r\n  \t * ```\r\n  \t *\r\n  \t * @option filter: Function = *\r\n  \t * A `Function` that will be used to decide whether to include a feature or not.\r\n  \t * The default is to include all features:\r\n  \t * ```js\r\n  \t * function (geoJsonFeature) {\r\n  \t * \treturn true;\r\n  \t * }\r\n  \t * ```\r\n  \t * Note: dynamically changing the `filter` option will have effect only on newly\r\n  \t * added data. It will _not_ re-evaluate already included features.\r\n  \t *\r\n  \t * @option coordsToLatLng: Function = *\r\n  \t * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n  \t * The default is the `coordsToLatLng` static method.\r\n  \t *\r\n  \t * @option markersInheritOptions: Boolean = false\r\n  \t * Whether default Markers for \"Point\" type Features inherit from group options.\r\n  \t */ initialize: function(geojson, options) {\n            setOptions(this, options);\n            this._layers = {};\n            if (geojson) {\n                this.addData(geojson);\n            }\n        },\n        // @method addData( <GeoJSON> data ): this\n        // Adds a GeoJSON object to the layer.\n        addData: function(geojson) {\n            var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;\n            if (features) {\n                for(i = 0, len = features.length; i < len; i++){\n                    // only add this if geometry or geometries are set and not null\n                    feature = features[i];\n                    if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n                        this.addData(feature);\n                    }\n                }\n                return this;\n            }\n            var options = this.options;\n            if (options.filter && !options.filter(geojson)) {\n                return this;\n            }\n            var layer = geometryToLayer(geojson, options);\n            if (!layer) {\n                return this;\n            }\n            layer.feature = asFeature(geojson);\n            layer.defaultOptions = layer.options;\n            this.resetStyle(layer);\n            if (options.onEachFeature) {\n                options.onEachFeature(geojson, layer);\n            }\n            return this.addLayer(layer);\n        },\n        // @method resetStyle( <Path> layer? ): this\n        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\n        // If `layer` is omitted, the style of all features in the current layer is reset.\n        resetStyle: function(layer) {\n            if (layer === undefined) {\n                return this.eachLayer(this.resetStyle, this);\n            }\n            // reset any custom styles\n            layer.options = extend({}, layer.defaultOptions);\n            this._setLayerStyle(layer, this.options.style);\n            return this;\n        },\n        // @method setStyle( <Function> style ): this\n        // Changes styles of GeoJSON vector layers with the given style function.\n        setStyle: function(style) {\n            return this.eachLayer(function(layer) {\n                this._setLayerStyle(layer, style);\n            }, this);\n        },\n        _setLayerStyle: function(layer, style) {\n            if (layer.setStyle) {\n                if (typeof style === \"function\") {\n                    style = style(layer.feature);\n                }\n                layer.setStyle(style);\n            }\n        }\n    });\n    // @section\n    // There are several static functions which can be called without instantiating L.GeoJSON:\n    // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\n    // Creates a `Layer` from a given GeoJSON feature. Can use a custom\n    // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\n    // functions if provided as options.\n    function geometryToLayer(geojson, options) {\n        var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;\n        if (!coords && !geometry) {\n            return null;\n        }\n        switch(geometry.type){\n            case \"Point\":\n                latlng = _coordsToLatLng(coords);\n                return _pointToLayer(pointToLayer, geojson, latlng, options);\n            case \"MultiPoint\":\n                for(i = 0, len = coords.length; i < len; i++){\n                    latlng = _coordsToLatLng(coords[i]);\n                    layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\n                }\n                return new FeatureGroup(layers);\n            case \"LineString\":\n            case \"MultiLineString\":\n                latlngs = coordsToLatLngs(coords, geometry.type === \"LineString\" ? 0 : 1, _coordsToLatLng);\n                return new Polyline(latlngs, options);\n            case \"Polygon\":\n            case \"MultiPolygon\":\n                latlngs = coordsToLatLngs(coords, geometry.type === \"Polygon\" ? 1 : 2, _coordsToLatLng);\n                return new Polygon(latlngs, options);\n            case \"GeometryCollection\":\n                for(i = 0, len = geometry.geometries.length; i < len; i++){\n                    var geoLayer = geometryToLayer({\n                        geometry: geometry.geometries[i],\n                        type: \"Feature\",\n                        properties: geojson.properties\n                    }, options);\n                    if (geoLayer) {\n                        layers.push(geoLayer);\n                    }\n                }\n                return new FeatureGroup(layers);\n            case \"FeatureCollection\":\n                for(i = 0, len = geometry.features.length; i < len; i++){\n                    var featureLayer = geometryToLayer(geometry.features[i], options);\n                    if (featureLayer) {\n                        layers.push(featureLayer);\n                    }\n                }\n                return new FeatureGroup(layers);\n            default:\n                throw new Error(\"Invalid GeoJSON object.\");\n        }\n    }\n    function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\n        return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);\n    }\n    // @function coordsToLatLng(coords: Array): LatLng\n    // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\n    // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\n    function coordsToLatLng(coords) {\n        return new LatLng(coords[1], coords[0], coords[2]);\n    }\n    // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\n    // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\n    // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\n    // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\n    function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\n        var latlngs = [];\n        for(var i = 0, len = coords.length, latlng; i < len; i++){\n            latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);\n            latlngs.push(latlng);\n        }\n        return latlngs;\n    }\n    // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array\n    // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n    function latLngToCoords(latlng, precision) {\n        latlng = toLatLng(latlng);\n        return latlng.alt !== undefined ? [\n            formatNum(latlng.lng, precision),\n            formatNum(latlng.lat, precision),\n            formatNum(latlng.alt, precision)\n        ] : [\n            formatNum(latlng.lng, precision),\n            formatNum(latlng.lat, precision)\n        ];\n    }\n    // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array\n    // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\n    // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\n    function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\n        var coords = [];\n        for(var i = 0, len = latlngs.length; i < len; i++){\n            // Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion\n            coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));\n        }\n        if (!levelsDeep && closed && coords.length > 0) {\n            coords.push(coords[0].slice());\n        }\n        return coords;\n    }\n    function getFeature(layer, newGeometry) {\n        return layer.feature ? extend({}, layer.feature, {\n            geometry: newGeometry\n        }) : asFeature(newGeometry);\n    }\n    // @function asFeature(geojson: Object): Object\n    // Normalize GeoJSON geometries/features into GeoJSON features.\n    function asFeature(geojson) {\n        if (geojson.type === \"Feature\" || geojson.type === \"FeatureCollection\") {\n            return geojson;\n        }\n        return {\n            type: \"Feature\",\n            properties: {},\n            geometry: geojson\n        };\n    }\n    var PointToGeoJSON = {\n        toGeoJSON: function(precision) {\n            return getFeature(this, {\n                type: \"Point\",\n                coordinates: latLngToCoords(this.getLatLng(), precision)\n            });\n        }\n    };\n    // @namespace Marker\n    // @section Other methods\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\n    Marker.include(PointToGeoJSON);\n    // @namespace CircleMarker\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\n    Circle.include(PointToGeoJSON);\n    CircleMarker.include(PointToGeoJSON);\n    // @namespace Polyline\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\n    Polyline.include({\n        toGeoJSON: function(precision) {\n            var multi = !isFlat(this._latlngs);\n            var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\n            return getFeature(this, {\n                type: (multi ? \"Multi\" : \"\") + \"LineString\",\n                coordinates: coords\n            });\n        }\n    });\n    // @namespace Polygon\n    // @method toGeoJSON(precision?: Number|false): Object\n    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\n    Polygon.include({\n        toGeoJSON: function(precision) {\n            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);\n            var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\n            if (!holes) {\n                coords = [\n                    coords\n                ];\n            }\n            return getFeature(this, {\n                type: (multi ? \"Multi\" : \"\") + \"Polygon\",\n                coordinates: coords\n            });\n        }\n    });\n    // @namespace LayerGroup\n    LayerGroup.include({\n        toMultiPoint: function(precision) {\n            var coords = [];\n            this.eachLayer(function(layer) {\n                coords.push(layer.toGeoJSON(precision).geometry.coordinates);\n            });\n            return getFeature(this, {\n                type: \"MultiPoint\",\n                coordinates: coords\n            });\n        },\n        // @method toGeoJSON(precision?: Number|false): Object\n        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\n        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\n        toGeoJSON: function(precision) {\n            var type = this.feature && this.feature.geometry && this.feature.geometry.type;\n            if (type === \"MultiPoint\") {\n                return this.toMultiPoint(precision);\n            }\n            var isGeometryCollection = type === \"GeometryCollection\", jsons = [];\n            this.eachLayer(function(layer) {\n                if (layer.toGeoJSON) {\n                    var json = layer.toGeoJSON(precision);\n                    if (isGeometryCollection) {\n                        jsons.push(json.geometry);\n                    } else {\n                        var feature = asFeature(json);\n                        // Squash nested feature collections\n                        if (feature.type === \"FeatureCollection\") {\n                            jsons.push.apply(jsons, feature.features);\n                        } else {\n                            jsons.push(feature);\n                        }\n                    }\n                }\n            });\n            if (isGeometryCollection) {\n                return getFeature(this, {\n                    geometries: jsons,\n                    type: \"GeometryCollection\"\n                });\n            }\n            return {\n                type: \"FeatureCollection\",\n                features: jsons\n            };\n        }\n    });\n    // @namespace GeoJSON\n    // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\n    // Creates a GeoJSON layer. Optionally accepts an object in\n    // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\n    // (you can alternatively add it later with `addData` method) and an `options` object.\n    function geoJSON(geojson, options) {\n        return new GeoJSON(geojson, options);\n    }\n    // Backward compatibility.\n    var geoJson = geoJSON;\n    /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */ var ImageOverlay = Layer.extend({\n        // @section\n        // @aka ImageOverlay options\n        options: {\n            // @option opacity: Number = 1.0\n            // The opacity of the image overlay.\n            opacity: 1,\n            // @option alt: String = ''\n            // Text for the `alt` attribute of the image (useful for accessibility).\n            alt: \"\",\n            // @option interactive: Boolean = false\n            // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\n            interactive: false,\n            // @option crossOrigin: Boolean|String = false\n            // Whether the crossOrigin attribute will be added to the image.\n            // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\n            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n            crossOrigin: false,\n            // @option errorOverlayUrl: String = ''\n            // URL to the overlay image to show in place of the overlay that failed to load.\n            errorOverlayUrl: \"\",\n            // @option zIndex: Number = 1\n            // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\n            zIndex: 1,\n            // @option className: String = ''\n            // A custom class name to assign to the image. Empty by default.\n            className: \"\"\n        },\n        initialize: function(url, bounds, options) {\n            this._url = url;\n            this._bounds = toLatLngBounds(bounds);\n            setOptions(this, options);\n        },\n        onAdd: function() {\n            if (!this._image) {\n                this._initImage();\n                if (this.options.opacity < 1) {\n                    this._updateOpacity();\n                }\n            }\n            if (this.options.interactive) {\n                addClass(this._image, \"leaflet-interactive\");\n                this.addInteractiveTarget(this._image);\n            }\n            this.getPane().appendChild(this._image);\n            this._reset();\n        },\n        onRemove: function() {\n            remove(this._image);\n            if (this.options.interactive) {\n                this.removeInteractiveTarget(this._image);\n            }\n        },\n        // @method setOpacity(opacity: Number): this\n        // Sets the opacity of the overlay.\n        setOpacity: function(opacity) {\n            this.options.opacity = opacity;\n            if (this._image) {\n                this._updateOpacity();\n            }\n            return this;\n        },\n        setStyle: function(styleOpts) {\n            if (styleOpts.opacity) {\n                this.setOpacity(styleOpts.opacity);\n            }\n            return this;\n        },\n        // @method bringToFront(): this\n        // Brings the layer to the top of all overlays.\n        bringToFront: function() {\n            if (this._map) {\n                toFront(this._image);\n            }\n            return this;\n        },\n        // @method bringToBack(): this\n        // Brings the layer to the bottom of all overlays.\n        bringToBack: function() {\n            if (this._map) {\n                toBack(this._image);\n            }\n            return this;\n        },\n        // @method setUrl(url: String): this\n        // Changes the URL of the image.\n        setUrl: function(url) {\n            this._url = url;\n            if (this._image) {\n                this._image.src = url;\n            }\n            return this;\n        },\n        // @method setBounds(bounds: LatLngBounds): this\n        // Update the bounds that this ImageOverlay covers\n        setBounds: function(bounds) {\n            this._bounds = toLatLngBounds(bounds);\n            if (this._map) {\n                this._reset();\n            }\n            return this;\n        },\n        getEvents: function() {\n            var events = {\n                zoom: this._reset,\n                viewreset: this._reset\n            };\n            if (this._zoomAnimated) {\n                events.zoomanim = this._animateZoom;\n            }\n            return events;\n        },\n        // @method setZIndex(value: Number): this\n        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\n        setZIndex: function(value) {\n            this.options.zIndex = value;\n            this._updateZIndex();\n            return this;\n        },\n        // @method getBounds(): LatLngBounds\n        // Get the bounds that this ImageOverlay covers\n        getBounds: function() {\n            return this._bounds;\n        },\n        // @method getElement(): HTMLElement\n        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\n        // used by this overlay.\n        getElement: function() {\n            return this._image;\n        },\n        _initImage: function() {\n            var wasElementSupplied = this._url.tagName === \"IMG\";\n            var img = this._image = wasElementSupplied ? this._url : create$1(\"img\");\n            addClass(img, \"leaflet-image-layer\");\n            if (this._zoomAnimated) {\n                addClass(img, \"leaflet-zoom-animated\");\n            }\n            if (this.options.className) {\n                addClass(img, this.options.className);\n            }\n            img.onselectstart = falseFn;\n            img.onmousemove = falseFn;\n            // @event load: Event\n            // Fired when the ImageOverlay layer has loaded its image\n            img.onload = bind(this.fire, this, \"load\");\n            img.onerror = bind(this._overlayOnError, this, \"error\");\n            if (this.options.crossOrigin || this.options.crossOrigin === \"\") {\n                img.crossOrigin = this.options.crossOrigin === true ? \"\" : this.options.crossOrigin;\n            }\n            if (this.options.zIndex) {\n                this._updateZIndex();\n            }\n            if (wasElementSupplied) {\n                this._url = img.src;\n                return;\n            }\n            img.src = this._url;\n            img.alt = this.options.alt;\n        },\n        _animateZoom: function(e) {\n            var scale = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\n            setTransform(this._image, offset, scale);\n        },\n        _reset: function() {\n            var image = this._image, bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), size = bounds.getSize();\n            setPosition(image, bounds.min);\n            image.style.width = size.x + \"px\";\n            image.style.height = size.y + \"px\";\n        },\n        _updateOpacity: function() {\n            setOpacity(this._image, this.options.opacity);\n        },\n        _updateZIndex: function() {\n            if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n                this._image.style.zIndex = this.options.zIndex;\n            }\n        },\n        _overlayOnError: function() {\n            // @event error: Event\n            // Fired when the ImageOverlay layer fails to load its image\n            this.fire(\"error\");\n            var errorUrl = this.options.errorOverlayUrl;\n            if (errorUrl && this._url !== errorUrl) {\n                this._url = errorUrl;\n                this._image.src = errorUrl;\n            }\n        },\n        // @method getCenter(): LatLng\n        // Returns the center of the ImageOverlay.\n        getCenter: function() {\n            return this._bounds.getCenter();\n        }\n    });\n    // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\n    // Instantiates an image overlay object given the URL of the image and the\n    // geographical bounds it is tied to.\n    var imageOverlay = function(url, bounds, options) {\n        return new ImageOverlay(url, bounds, options);\n    };\n    /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */ var VideoOverlay = ImageOverlay.extend({\n        // @section\n        // @aka VideoOverlay options\n        options: {\n            // @option autoplay: Boolean = true\n            // Whether the video starts playing automatically when loaded.\n            // On some browsers autoplay will only work with `muted: true`\n            autoplay: true,\n            // @option loop: Boolean = true\n            // Whether the video will loop back to the beginning when played.\n            loop: true,\n            // @option keepAspectRatio: Boolean = true\n            // Whether the video will save aspect ratio after the projection.\n            // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)\n            keepAspectRatio: true,\n            // @option muted: Boolean = false\n            // Whether the video starts on mute when loaded.\n            muted: false,\n            // @option playsInline: Boolean = true\n            // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.\n            playsInline: true\n        },\n        _initImage: function() {\n            var wasElementSupplied = this._url.tagName === \"VIDEO\";\n            var vid = this._image = wasElementSupplied ? this._url : create$1(\"video\");\n            addClass(vid, \"leaflet-image-layer\");\n            if (this._zoomAnimated) {\n                addClass(vid, \"leaflet-zoom-animated\");\n            }\n            if (this.options.className) {\n                addClass(vid, this.options.className);\n            }\n            vid.onselectstart = falseFn;\n            vid.onmousemove = falseFn;\n            // @event load: Event\n            // Fired when the video has finished loading the first frame\n            vid.onloadeddata = bind(this.fire, this, \"load\");\n            if (wasElementSupplied) {\n                var sourceElements = vid.getElementsByTagName(\"source\");\n                var sources = [];\n                for(var j = 0; j < sourceElements.length; j++){\n                    sources.push(sourceElements[j].src);\n                }\n                this._url = sourceElements.length > 0 ? sources : [\n                    vid.src\n                ];\n                return;\n            }\n            if (!isArray(this._url)) {\n                this._url = [\n                    this._url\n                ];\n            }\n            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, \"objectFit\")) {\n                vid.style[\"objectFit\"] = \"fill\";\n            }\n            vid.autoplay = !!this.options.autoplay;\n            vid.loop = !!this.options.loop;\n            vid.muted = !!this.options.muted;\n            vid.playsInline = !!this.options.playsInline;\n            for(var i = 0; i < this._url.length; i++){\n                var source = create$1(\"source\");\n                source.src = this._url[i];\n                vid.appendChild(source);\n            }\n        }\n    });\n    // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\n    // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\n    // geographical bounds it is tied to.\n    function videoOverlay(video, bounds, options) {\n        return new VideoOverlay(video, bounds, options);\n    }\n    /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */ var SVGOverlay = ImageOverlay.extend({\n        _initImage: function() {\n            var el = this._image = this._url;\n            addClass(el, \"leaflet-image-layer\");\n            if (this._zoomAnimated) {\n                addClass(el, \"leaflet-zoom-animated\");\n            }\n            if (this.options.className) {\n                addClass(el, this.options.className);\n            }\n            el.onselectstart = falseFn;\n            el.onmousemove = falseFn;\n        }\n    });\n    // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n    // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n    // A viewBox attribute is required on the SVG element to zoom in and out properly.\n    function svgOverlay(el, bounds, options) {\n        return new SVGOverlay(el, bounds, options);\n    }\n    /*\r\n   * @class DivOverlay\r\n   * @inherits Interactive layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.\r\n   */ // @namespace DivOverlay\n    var DivOverlay = Layer.extend({\n        // @section\n        // @aka DivOverlay options\n        options: {\n            // @option interactive: Boolean = false\n            // If true, the popup/tooltip will listen to the mouse events.\n            interactive: false,\n            // @option offset: Point = Point(0, 0)\n            // The offset of the overlay position.\n            offset: [\n                0,\n                0\n            ],\n            // @option className: String = ''\n            // A custom CSS class name to assign to the overlay.\n            className: \"\",\n            // @option pane: String = undefined\n            // `Map pane` where the overlay will be added.\n            pane: undefined,\n            // @option content: String|HTMLElement|Function = ''\n            // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be\n            // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.\n            content: \"\"\n        },\n        initialize: function(options, source) {\n            if (options && (options instanceof LatLng || isArray(options))) {\n                this._latlng = toLatLng(options);\n                setOptions(this, source);\n            } else {\n                setOptions(this, options);\n                this._source = source;\n            }\n            if (this.options.content) {\n                this._content = this.options.content;\n            }\n        },\n        // @method openOn(map: Map): this\n        // Adds the overlay to the map.\n        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.\n        openOn: function(map) {\n            map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n            if (!map.hasLayer(this)) {\n                map.addLayer(this);\n            }\n            return this;\n        },\n        // @method close(): this\n        // Closes the overlay.\n        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`\n        // and `layer.closePopup()`/`.closeTooltip()`.\n        close: function() {\n            if (this._map) {\n                this._map.removeLayer(this);\n            }\n            return this;\n        },\n        // @method toggle(layer?: Layer): this\n        // Opens or closes the overlay bound to layer depending on its current state.\n        // Argument may be omitted only for overlay bound to layer.\n        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.\n        toggle: function(layer) {\n            if (this._map) {\n                this.close();\n            } else {\n                if (arguments.length) {\n                    this._source = layer;\n                } else {\n                    layer = this._source;\n                }\n                this._prepareOpen();\n                // open the overlay on the map\n                this.openOn(layer._map);\n            }\n            return this;\n        },\n        onAdd: function(map) {\n            this._zoomAnimated = map._zoomAnimated;\n            if (!this._container) {\n                this._initLayout();\n            }\n            if (map._fadeAnimated) {\n                setOpacity(this._container, 0);\n            }\n            clearTimeout(this._removeTimeout);\n            this.getPane().appendChild(this._container);\n            this.update();\n            if (map._fadeAnimated) {\n                setOpacity(this._container, 1);\n            }\n            this.bringToFront();\n            if (this.options.interactive) {\n                addClass(this._container, \"leaflet-interactive\");\n                this.addInteractiveTarget(this._container);\n            }\n        },\n        onRemove: function(map) {\n            if (map._fadeAnimated) {\n                setOpacity(this._container, 0);\n                this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\n            } else {\n                remove(this._container);\n            }\n            if (this.options.interactive) {\n                removeClass(this._container, \"leaflet-interactive\");\n                this.removeInteractiveTarget(this._container);\n            }\n        },\n        // @namespace DivOverlay\n        // @method getLatLng: LatLng\n        // Returns the geographical point of the overlay.\n        getLatLng: function() {\n            return this._latlng;\n        },\n        // @method setLatLng(latlng: LatLng): this\n        // Sets the geographical point where the overlay will open.\n        setLatLng: function(latlng) {\n            this._latlng = toLatLng(latlng);\n            if (this._map) {\n                this._updatePosition();\n                this._adjustPan();\n            }\n            return this;\n        },\n        // @method getContent: String|HTMLElement\n        // Returns the content of the overlay.\n        getContent: function() {\n            return this._content;\n        },\n        // @method setContent(htmlContent: String|HTMLElement|Function): this\n        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.\n        // The function should return a `String` or `HTMLElement` to be used in the overlay.\n        setContent: function(content) {\n            this._content = content;\n            this.update();\n            return this;\n        },\n        // @method getElement: String|HTMLElement\n        // Returns the HTML container of the overlay.\n        getElement: function() {\n            return this._container;\n        },\n        // @method update: null\n        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.\n        update: function() {\n            if (!this._map) {\n                return;\n            }\n            this._container.style.visibility = \"hidden\";\n            this._updateContent();\n            this._updateLayout();\n            this._updatePosition();\n            this._container.style.visibility = \"\";\n            this._adjustPan();\n        },\n        getEvents: function() {\n            var events = {\n                zoom: this._updatePosition,\n                viewreset: this._updatePosition\n            };\n            if (this._zoomAnimated) {\n                events.zoomanim = this._animateZoom;\n            }\n            return events;\n        },\n        // @method isOpen: Boolean\n        // Returns `true` when the overlay is visible on the map.\n        isOpen: function() {\n            return !!this._map && this._map.hasLayer(this);\n        },\n        // @method bringToFront: this\n        // Brings this overlay in front of other overlays (in the same map pane).\n        bringToFront: function() {\n            if (this._map) {\n                toFront(this._container);\n            }\n            return this;\n        },\n        // @method bringToBack: this\n        // Brings this overlay to the back of other overlays (in the same map pane).\n        bringToBack: function() {\n            if (this._map) {\n                toBack(this._container);\n            }\n            return this;\n        },\n        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)\n        _prepareOpen: function(latlng) {\n            var source = this._source;\n            if (!source._map) {\n                return false;\n            }\n            if (source instanceof FeatureGroup) {\n                source = null;\n                var layers = this._source._layers;\n                for(var id in layers){\n                    if (layers[id]._map) {\n                        source = layers[id];\n                        break;\n                    }\n                }\n                if (!source) {\n                    return false;\n                } // Unable to get source layer.\n                // set overlay source to this layer\n                this._source = source;\n            }\n            if (!latlng) {\n                if (source.getCenter) {\n                    latlng = source.getCenter();\n                } else if (source.getLatLng) {\n                    latlng = source.getLatLng();\n                } else if (source.getBounds) {\n                    latlng = source.getBounds().getCenter();\n                } else {\n                    throw new Error(\"Unable to get source layer LatLng.\");\n                }\n            }\n            this.setLatLng(latlng);\n            if (this._map) {\n                // update the overlay (content, layout, etc...)\n                this.update();\n            }\n            return true;\n        },\n        _updateContent: function() {\n            if (!this._content) {\n                return;\n            }\n            var node = this._contentNode;\n            var content = typeof this._content === \"function\" ? this._content(this._source || this) : this._content;\n            if (typeof content === \"string\") {\n                node.innerHTML = content;\n            } else {\n                while(node.hasChildNodes()){\n                    node.removeChild(node.firstChild);\n                }\n                node.appendChild(content);\n            }\n            // @namespace DivOverlay\n            // @section DivOverlay events\n            // @event contentupdate: Event\n            // Fired when the content of the overlay is updated\n            this.fire(\"contentupdate\");\n        },\n        _updatePosition: function() {\n            if (!this._map) {\n                return;\n            }\n            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();\n            if (this._zoomAnimated) {\n                setPosition(this._container, pos.add(anchor));\n            } else {\n                offset = offset.add(pos).add(anchor);\n            }\n            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\n            // bottom position the overlay in case the height of the overlay changes (images loading etc)\n            this._container.style.bottom = bottom + \"px\";\n            this._container.style.left = left + \"px\";\n        },\n        _getAnchor: function() {\n            return [\n                0,\n                0\n            ];\n        }\n    });\n    Map.include({\n        _initOverlay: function(OverlayClass, content, latlng, options) {\n            var overlay = content;\n            if (!(overlay instanceof OverlayClass)) {\n                overlay = new OverlayClass(options).setContent(content);\n            }\n            if (latlng) {\n                overlay.setLatLng(latlng);\n            }\n            return overlay;\n        }\n    });\n    Layer.include({\n        _initOverlay: function(OverlayClass, old, content, options) {\n            var overlay = content;\n            if (overlay instanceof OverlayClass) {\n                setOptions(overlay, options);\n                overlay._source = this;\n            } else {\n                overlay = old && !options ? old : new OverlayClass(options, this);\n                overlay.setContent(content);\n            }\n            return overlay;\n        }\n    });\n    /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   *\r\n   * A popup can be also standalone:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   * or\r\n   * ```js\r\n   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */ // @namespace Popup\n    var Popup = DivOverlay.extend({\n        // @section\n        // @aka Popup options\n        options: {\n            // @option pane: String = 'popupPane'\n            // `Map pane` where the popup will be added.\n            pane: \"popupPane\",\n            // @option offset: Point = Point(0, 7)\n            // The offset of the popup position.\n            offset: [\n                0,\n                7\n            ],\n            // @option maxWidth: Number = 300\n            // Max width of the popup, in pixels.\n            maxWidth: 300,\n            // @option minWidth: Number = 50\n            // Min width of the popup, in pixels.\n            minWidth: 50,\n            // @option maxHeight: Number = null\n            // If set, creates a scrollable container of the given height\n            // inside a popup if its content exceeds it.\n            // The scrollable container can be styled using the\n            // `leaflet-popup-scrolled` CSS class selector.\n            maxHeight: null,\n            // @option autoPan: Boolean = true\n            // Set it to `false` if you don't want the map to do panning animation\n            // to fit the opened popup.\n            autoPan: true,\n            // @option autoPanPaddingTopLeft: Point = null\n            // The margin between the popup and the top left corner of the map\n            // view after autopanning was performed.\n            autoPanPaddingTopLeft: null,\n            // @option autoPanPaddingBottomRight: Point = null\n            // The margin between the popup and the bottom right corner of the map\n            // view after autopanning was performed.\n            autoPanPaddingBottomRight: null,\n            // @option autoPanPadding: Point = Point(5, 5)\n            // Equivalent of setting both top left and bottom right autopan padding to the same value.\n            autoPanPadding: [\n                5,\n                5\n            ],\n            // @option keepInView: Boolean = false\n            // Set it to `true` if you want to prevent users from panning the popup\n            // off of the screen while it is open.\n            keepInView: false,\n            // @option closeButton: Boolean = true\n            // Controls the presence of a close button in the popup.\n            closeButton: true,\n            // @option autoClose: Boolean = true\n            // Set it to `false` if you want to override the default behavior of\n            // the popup closing when another popup is opened.\n            autoClose: true,\n            // @option closeOnEscapeKey: Boolean = true\n            // Set it to `false` if you want to override the default behavior of\n            // the ESC key for closing of the popup.\n            closeOnEscapeKey: true,\n            // @option closeOnClick: Boolean = *\n            // Set it if you want to override the default behavior of the popup closing when user clicks\n            // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\n            // @option className: String = ''\n            // A custom CSS class name to assign to the popup.\n            className: \"\"\n        },\n        // @namespace Popup\n        // @method openOn(map: Map): this\n        // Alternative to `map.openPopup(popup)`.\n        // Adds the popup to the map and closes the previous one.\n        openOn: function(map) {\n            map = arguments.length ? map : this._source._map; // experimental, not the part of public api\n            if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {\n                map.removeLayer(map._popup);\n            }\n            map._popup = this;\n            return DivOverlay.prototype.openOn.call(this, map);\n        },\n        onAdd: function(map) {\n            DivOverlay.prototype.onAdd.call(this, map);\n            // @namespace Map\n            // @section Popup events\n            // @event popupopen: PopupEvent\n            // Fired when a popup is opened in the map\n            map.fire(\"popupopen\", {\n                popup: this\n            });\n            if (this._source) {\n                // @namespace Layer\n                // @section Popup events\n                // @event popupopen: PopupEvent\n                // Fired when a popup bound to this layer is opened\n                this._source.fire(\"popupopen\", {\n                    popup: this\n                }, true);\n                // For non-path layers, we toggle the popup when clicking\n                // again the layer, so prevent the map to reopen it.\n                if (!(this._source instanceof Path)) {\n                    this._source.on(\"preclick\", stopPropagation);\n                }\n            }\n        },\n        onRemove: function(map) {\n            DivOverlay.prototype.onRemove.call(this, map);\n            // @namespace Map\n            // @section Popup events\n            // @event popupclose: PopupEvent\n            // Fired when a popup in the map is closed\n            map.fire(\"popupclose\", {\n                popup: this\n            });\n            if (this._source) {\n                // @namespace Layer\n                // @section Popup events\n                // @event popupclose: PopupEvent\n                // Fired when a popup bound to this layer is closed\n                this._source.fire(\"popupclose\", {\n                    popup: this\n                }, true);\n                if (!(this._source instanceof Path)) {\n                    this._source.off(\"preclick\", stopPropagation);\n                }\n            }\n        },\n        getEvents: function() {\n            var events = DivOverlay.prototype.getEvents.call(this);\n            if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n                events.preclick = this.close;\n            }\n            if (this.options.keepInView) {\n                events.moveend = this._adjustPan;\n            }\n            return events;\n        },\n        _initLayout: function() {\n            var prefix = \"leaflet-popup\", container = this._container = create$1(\"div\", prefix + \" \" + (this.options.className || \"\") + \" leaflet-zoom-animated\");\n            var wrapper = this._wrapper = create$1(\"div\", prefix + \"-content-wrapper\", container);\n            this._contentNode = create$1(\"div\", prefix + \"-content\", wrapper);\n            disableClickPropagation(container);\n            disableScrollPropagation(this._contentNode);\n            on(container, \"contextmenu\", stopPropagation);\n            this._tipContainer = create$1(\"div\", prefix + \"-tip-container\", container);\n            this._tip = create$1(\"div\", prefix + \"-tip\", this._tipContainer);\n            if (this.options.closeButton) {\n                var closeButton = this._closeButton = create$1(\"a\", prefix + \"-close-button\", container);\n                closeButton.setAttribute(\"role\", \"button\"); // overrides the implicit role=link of <a> elements #7399\n                closeButton.setAttribute(\"aria-label\", \"Close popup\");\n                closeButton.href = \"#close\";\n                closeButton.innerHTML = '<span aria-hidden=\"true\">&#215;</span>';\n                on(closeButton, \"click\", function(ev) {\n                    preventDefault(ev);\n                    this.close();\n                }, this);\n            }\n        },\n        _updateLayout: function() {\n            var container = this._contentNode, style = container.style;\n            style.width = \"\";\n            style.whiteSpace = \"nowrap\";\n            var width = container.offsetWidth;\n            width = Math.min(width, this.options.maxWidth);\n            width = Math.max(width, this.options.minWidth);\n            style.width = width + 1 + \"px\";\n            style.whiteSpace = \"\";\n            style.height = \"\";\n            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = \"leaflet-popup-scrolled\";\n            if (maxHeight && height > maxHeight) {\n                style.height = maxHeight + \"px\";\n                addClass(container, scrolledClass);\n            } else {\n                removeClass(container, scrolledClass);\n            }\n            this._containerWidth = this._container.offsetWidth;\n        },\n        _animateZoom: function(e) {\n            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();\n            setPosition(this._container, pos.add(anchor));\n        },\n        _adjustPan: function() {\n            if (!this.options.autoPan) {\n                return;\n            }\n            if (this._map._panAnim) {\n                this._map._panAnim.stop();\n            }\n            // We can endlessly recurse if keepInView is set and the view resets.\n            // Let's guard against that by exiting early if we're responding to our own autopan.\n            if (this._autopanning) {\n                this._autopanning = false;\n                return;\n            }\n            var map = this._map, marginBottom = parseInt(getStyle(this._container, \"marginBottom\"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\n            layerPos._add(getPosition(this._container));\n            var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;\n            if (containerPos.x + containerWidth + paddingBR.x > size.x) {\n                dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n            }\n            if (containerPos.x - dx - paddingTL.x < 0) {\n                dx = containerPos.x - paddingTL.x;\n            }\n            if (containerPos.y + containerHeight + paddingBR.y > size.y) {\n                dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n            }\n            if (containerPos.y - dy - paddingTL.y < 0) {\n                dy = containerPos.y - paddingTL.y;\n            }\n            // @namespace Map\n            // @section Popup events\n            // @event autopanstart: Event\n            // Fired when the map starts autopanning when opening a popup.\n            if (dx || dy) {\n                // Track that we're autopanning, as this function will be re-ran on moveend\n                if (this.options.keepInView) {\n                    this._autopanning = true;\n                }\n                map.fire(\"autopanstart\").panBy([\n                    dx,\n                    dy\n                ]);\n            }\n        },\n        _getAnchor: function() {\n            // Where should we anchor the popup on the source layer?\n            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [\n                0,\n                0\n            ]);\n        }\n    });\n    // @namespace Popup\n    // @factory L.popup(options?: Popup options, source?: Layer)\n    // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\n    // @alternative\n    // @factory L.popup(latlng: LatLng, options?: Popup options)\n    // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.\n    var popup = function(options, source) {\n        return new Popup(options, source);\n    };\n    /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */ Map.mergeOptions({\n        closePopupOnClick: true\n    });\n    // @namespace Map\n    // @section Methods for Layers and Controls\n    Map.include({\n        // @method openPopup(popup: Popup): this\n        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\n        // @alternative\n        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\n        // Creates a popup with the specified content and options and opens it in the given point on a map.\n        openPopup: function(popup, latlng, options) {\n            this._initOverlay(Popup, popup, latlng, options).openOn(this);\n            return this;\n        },\n        // @method closePopup(popup?: Popup): this\n        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\n        closePopup: function(popup) {\n            popup = arguments.length ? popup : this._popup;\n            if (popup) {\n                popup.close();\n            }\n            return this;\n        }\n    });\n    /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */ // @section Popup methods\n    Layer.include({\n        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\n        // Binds a popup to the layer with the passed `content` and sets up the\n        // necessary event listeners. If a `Function` is passed it will receive\n        // the layer as the first argument and should return a `String` or `HTMLElement`.\n        bindPopup: function(content, options) {\n            this._popup = this._initOverlay(Popup, this._popup, content, options);\n            if (!this._popupHandlersAdded) {\n                this.on({\n                    click: this._openPopup,\n                    keypress: this._onKeyPress,\n                    remove: this.closePopup,\n                    move: this._movePopup\n                });\n                this._popupHandlersAdded = true;\n            }\n            return this;\n        },\n        // @method unbindPopup(): this\n        // Removes the popup previously bound with `bindPopup`.\n        unbindPopup: function() {\n            if (this._popup) {\n                this.off({\n                    click: this._openPopup,\n                    keypress: this._onKeyPress,\n                    remove: this.closePopup,\n                    move: this._movePopup\n                });\n                this._popupHandlersAdded = false;\n                this._popup = null;\n            }\n            return this;\n        },\n        // @method openPopup(latlng?: LatLng): this\n        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\n        openPopup: function(latlng) {\n            if (this._popup) {\n                if (!(this instanceof FeatureGroup)) {\n                    this._popup._source = this;\n                }\n                if (this._popup._prepareOpen(latlng || this._latlng)) {\n                    // open the popup on the map\n                    this._popup.openOn(this._map);\n                }\n            }\n            return this;\n        },\n        // @method closePopup(): this\n        // Closes the popup bound to this layer if it is open.\n        closePopup: function() {\n            if (this._popup) {\n                this._popup.close();\n            }\n            return this;\n        },\n        // @method togglePopup(): this\n        // Opens or closes the popup bound to this layer depending on its current state.\n        togglePopup: function() {\n            if (this._popup) {\n                this._popup.toggle(this);\n            }\n            return this;\n        },\n        // @method isPopupOpen(): boolean\n        // Returns `true` if the popup bound to this layer is currently open.\n        isPopupOpen: function() {\n            return this._popup ? this._popup.isOpen() : false;\n        },\n        // @method setPopupContent(content: String|HTMLElement|Popup): this\n        // Sets the content of the popup bound to this layer.\n        setPopupContent: function(content) {\n            if (this._popup) {\n                this._popup.setContent(content);\n            }\n            return this;\n        },\n        // @method getPopup(): Popup\n        // Returns the popup bound to this layer.\n        getPopup: function() {\n            return this._popup;\n        },\n        _openPopup: function(e) {\n            if (!this._popup || !this._map) {\n                return;\n            }\n            // prevent map click\n            stop(e);\n            var target = e.layer || e.target;\n            if (this._popup._source === target && !(target instanceof Path)) {\n                // treat it like a marker and figure out\n                // if we should toggle it open/closed\n                if (this._map.hasLayer(this._popup)) {\n                    this.closePopup();\n                } else {\n                    this.openPopup(e.latlng);\n                }\n                return;\n            }\n            this._popup._source = target;\n            this.openPopup(e.latlng);\n        },\n        _movePopup: function(e) {\n            this._popup.setLatLng(e.latlng);\n        },\n        _onKeyPress: function(e) {\n            if (e.originalEvent.keyCode === 13) {\n                this._openPopup(e);\n            }\n        }\n    });\n    /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   * If you want to just bind a tooltip to marker:\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Path overlays like polylines also have a `bindTooltip` method.\n   *\n   * A tooltip can be also standalone:\n   *\n   * ```js\n   * var tooltip = L.tooltip()\n   * \t.setLatLng(latlng)\n   * \t.setContent('Hello world!<br />This is a nice tooltip.')\n   * \t.addTo(map);\n   * ```\n   * or\n   * ```js\n   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})\n   * \t.addTo(map);\n   * ```\n   *\n   *\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */ // @namespace Tooltip\n    var Tooltip = DivOverlay.extend({\n        // @section\n        // @aka Tooltip options\n        options: {\n            // @option pane: String = 'tooltipPane'\n            // `Map pane` where the tooltip will be added.\n            pane: \"tooltipPane\",\n            // @option offset: Point = Point(0, 0)\n            // Optional offset of the tooltip position.\n            offset: [\n                0,\n                0\n            ],\n            // @option direction: String = 'auto'\n            // Direction where to open the tooltip. Possible values are: `right`, `left`,\n            // `top`, `bottom`, `center`, `auto`.\n            // `auto` will dynamically switch between `right` and `left` according to the tooltip\n            // position on the map.\n            direction: \"auto\",\n            // @option permanent: Boolean = false\n            // Whether to open the tooltip permanently or only on mouseover.\n            permanent: false,\n            // @option sticky: Boolean = false\n            // If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n            sticky: false,\n            // @option opacity: Number = 0.9\n            // Tooltip container opacity.\n            opacity: 0.9\n        },\n        onAdd: function(map) {\n            DivOverlay.prototype.onAdd.call(this, map);\n            this.setOpacity(this.options.opacity);\n            // @namespace Map\n            // @section Tooltip events\n            // @event tooltipopen: TooltipEvent\n            // Fired when a tooltip is opened in the map.\n            map.fire(\"tooltipopen\", {\n                tooltip: this\n            });\n            if (this._source) {\n                this.addEventParent(this._source);\n                // @namespace Layer\n                // @section Tooltip events\n                // @event tooltipopen: TooltipEvent\n                // Fired when a tooltip bound to this layer is opened.\n                this._source.fire(\"tooltipopen\", {\n                    tooltip: this\n                }, true);\n            }\n        },\n        onRemove: function(map) {\n            DivOverlay.prototype.onRemove.call(this, map);\n            // @namespace Map\n            // @section Tooltip events\n            // @event tooltipclose: TooltipEvent\n            // Fired when a tooltip in the map is closed.\n            map.fire(\"tooltipclose\", {\n                tooltip: this\n            });\n            if (this._source) {\n                this.removeEventParent(this._source);\n                // @namespace Layer\n                // @section Tooltip events\n                // @event tooltipclose: TooltipEvent\n                // Fired when a tooltip bound to this layer is closed.\n                this._source.fire(\"tooltipclose\", {\n                    tooltip: this\n                }, true);\n            }\n        },\n        getEvents: function() {\n            var events = DivOverlay.prototype.getEvents.call(this);\n            if (!this.options.permanent) {\n                events.preclick = this.close;\n            }\n            return events;\n        },\n        _initLayout: function() {\n            var prefix = \"leaflet-tooltip\", className = prefix + \" \" + (this.options.className || \"\") + \" leaflet-zoom-\" + (this._zoomAnimated ? \"animated\" : \"hide\");\n            this._contentNode = this._container = create$1(\"div\", className);\n            this._container.setAttribute(\"role\", \"tooltip\");\n            this._container.setAttribute(\"id\", \"leaflet-tooltip-\" + stamp(this));\n        },\n        _updateLayout: function() {},\n        _adjustPan: function() {},\n        _setPosition: function(pos) {\n            var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();\n            if (direction === \"top\") {\n                subX = tooltipWidth / 2;\n                subY = tooltipHeight;\n            } else if (direction === \"bottom\") {\n                subX = tooltipWidth / 2;\n                subY = 0;\n            } else if (direction === \"center\") {\n                subX = tooltipWidth / 2;\n                subY = tooltipHeight / 2;\n            } else if (direction === \"right\") {\n                subX = 0;\n                subY = tooltipHeight / 2;\n            } else if (direction === \"left\") {\n                subX = tooltipWidth;\n                subY = tooltipHeight / 2;\n            } else if (tooltipPoint.x < centerPoint.x) {\n                direction = \"right\";\n                subX = 0;\n                subY = tooltipHeight / 2;\n            } else {\n                direction = \"left\";\n                subX = tooltipWidth + (offset.x + anchor.x) * 2;\n                subY = tooltipHeight / 2;\n            }\n            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);\n            removeClass(container, \"leaflet-tooltip-right\");\n            removeClass(container, \"leaflet-tooltip-left\");\n            removeClass(container, \"leaflet-tooltip-top\");\n            removeClass(container, \"leaflet-tooltip-bottom\");\n            addClass(container, \"leaflet-tooltip-\" + direction);\n            setPosition(container, pos);\n        },\n        _updatePosition: function() {\n            var pos = this._map.latLngToLayerPoint(this._latlng);\n            this._setPosition(pos);\n        },\n        setOpacity: function(opacity) {\n            this.options.opacity = opacity;\n            if (this._container) {\n                setOpacity(this._container, opacity);\n            }\n        },\n        _animateZoom: function(e) {\n            var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n            this._setPosition(pos);\n        },\n        _getAnchor: function() {\n            // Where should we anchor the tooltip on the source layer?\n            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [\n                0,\n                0\n            ]);\n        }\n    });\n    // @namespace Tooltip\n    // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n    // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n    // @alternative\n    // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)\n    // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.\n    var tooltip = function(options, source) {\n        return new Tooltip(options, source);\n    };\n    // @namespace Map\n    // @section Methods for Layers and Controls\n    Map.include({\n        // @method openTooltip(tooltip: Tooltip): this\n        // Opens the specified tooltip.\n        // @alternative\n        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n        // Creates a tooltip with the specified content and options and open it.\n        openTooltip: function(tooltip, latlng, options) {\n            this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);\n            return this;\n        },\n        // @method closeTooltip(tooltip: Tooltip): this\n        // Closes the tooltip given as parameter.\n        closeTooltip: function(tooltip) {\n            tooltip.close();\n            return this;\n        }\n    });\n    /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */ // @section Tooltip methods\n    Layer.include({\n        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n        // Binds a tooltip to the layer with the passed `content` and sets up the\n        // necessary event listeners. If a `Function` is passed it will receive\n        // the layer as the first argument and should return a `String` or `HTMLElement`.\n        bindTooltip: function(content, options) {\n            if (this._tooltip && this.isTooltipOpen()) {\n                this.unbindTooltip();\n            }\n            this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);\n            this._initTooltipInteractions();\n            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n                this.openTooltip();\n            }\n            return this;\n        },\n        // @method unbindTooltip(): this\n        // Removes the tooltip previously bound with `bindTooltip`.\n        unbindTooltip: function() {\n            if (this._tooltip) {\n                this._initTooltipInteractions(true);\n                this.closeTooltip();\n                this._tooltip = null;\n            }\n            return this;\n        },\n        _initTooltipInteractions: function(remove) {\n            if (!remove && this._tooltipHandlersAdded) {\n                return;\n            }\n            var onOff = remove ? \"off\" : \"on\", events = {\n                remove: this.closeTooltip,\n                move: this._moveTooltip\n            };\n            if (!this._tooltip.options.permanent) {\n                events.mouseover = this._openTooltip;\n                events.mouseout = this.closeTooltip;\n                events.click = this._openTooltip;\n                if (this._map) {\n                    this._addFocusListeners();\n                } else {\n                    events.add = this._addFocusListeners;\n                }\n            } else {\n                events.add = this._openTooltip;\n            }\n            if (this._tooltip.options.sticky) {\n                events.mousemove = this._moveTooltip;\n            }\n            this[onOff](events);\n            this._tooltipHandlersAdded = !remove;\n        },\n        // @method openTooltip(latlng?: LatLng): this\n        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n        openTooltip: function(latlng) {\n            if (this._tooltip) {\n                if (!(this instanceof FeatureGroup)) {\n                    this._tooltip._source = this;\n                }\n                if (this._tooltip._prepareOpen(latlng)) {\n                    // open the tooltip on the map\n                    this._tooltip.openOn(this._map);\n                    if (this.getElement) {\n                        this._setAriaDescribedByOnLayer(this);\n                    } else if (this.eachLayer) {\n                        this.eachLayer(this._setAriaDescribedByOnLayer, this);\n                    }\n                }\n            }\n            return this;\n        },\n        // @method closeTooltip(): this\n        // Closes the tooltip bound to this layer if it is open.\n        closeTooltip: function() {\n            if (this._tooltip) {\n                return this._tooltip.close();\n            }\n        },\n        // @method toggleTooltip(): this\n        // Opens or closes the tooltip bound to this layer depending on its current state.\n        toggleTooltip: function() {\n            if (this._tooltip) {\n                this._tooltip.toggle(this);\n            }\n            return this;\n        },\n        // @method isTooltipOpen(): boolean\n        // Returns `true` if the tooltip bound to this layer is currently open.\n        isTooltipOpen: function() {\n            return this._tooltip.isOpen();\n        },\n        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n        // Sets the content of the tooltip bound to this layer.\n        setTooltipContent: function(content) {\n            if (this._tooltip) {\n                this._tooltip.setContent(content);\n            }\n            return this;\n        },\n        // @method getTooltip(): Tooltip\n        // Returns the tooltip bound to this layer.\n        getTooltip: function() {\n            return this._tooltip;\n        },\n        _addFocusListeners: function() {\n            if (this.getElement) {\n                this._addFocusListenersOnLayer(this);\n            } else if (this.eachLayer) {\n                this.eachLayer(this._addFocusListenersOnLayer, this);\n            }\n        },\n        _addFocusListenersOnLayer: function(layer) {\n            var el = typeof layer.getElement === \"function\" && layer.getElement();\n            if (el) {\n                on(el, \"focus\", function() {\n                    this._tooltip._source = layer;\n                    this.openTooltip();\n                }, this);\n                on(el, \"blur\", this.closeTooltip, this);\n            }\n        },\n        _setAriaDescribedByOnLayer: function(layer) {\n            var el = typeof layer.getElement === \"function\" && layer.getElement();\n            if (el) {\n                el.setAttribute(\"aria-describedby\", this._tooltip._container.id);\n            }\n        },\n        _openTooltip: function(e) {\n            if (!this._tooltip || !this._map) {\n                return;\n            }\n            // If the map is moving, we will show the tooltip after it's done.\n            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {\n                this._openOnceFlag = true;\n                var that = this;\n                this._map.once(\"moveend\", function() {\n                    that._openOnceFlag = false;\n                    that._openTooltip(e);\n                });\n                return;\n            }\n            this._tooltip._source = e.layer || e.target;\n            this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);\n        },\n        _moveTooltip: function(e) {\n            var latlng = e.latlng, containerPoint, layerPoint;\n            if (this._tooltip.options.sticky && e.originalEvent) {\n                containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n                layerPoint = this._map.containerPointToLayerPoint(containerPoint);\n                latlng = this._map.layerPointToLatLng(layerPoint);\n            }\n            this._tooltip.setLatLng(latlng);\n        }\n    });\n    /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */ var DivIcon = Icon.extend({\n        options: {\n            // @section\n            // @aka DivIcon options\n            iconSize: [\n                12,\n                12\n            ],\n            // iconAnchor: (Point),\n            // popupAnchor: (Point),\n            // @option html: String|HTMLElement = ''\n            // Custom HTML code to put inside the div element, empty by default. Alternatively,\n            // an instance of `HTMLElement`.\n            html: false,\n            // @option bgPos: Point = [0, 0]\n            // Optional relative position of the background, in pixels\n            bgPos: null,\n            className: \"leaflet-div-icon\"\n        },\n        createIcon: function(oldIcon) {\n            var div = oldIcon && oldIcon.tagName === \"DIV\" ? oldIcon : document.createElement(\"div\"), options = this.options;\n            if (options.html instanceof Element) {\n                empty(div);\n                div.appendChild(options.html);\n            } else {\n                div.innerHTML = options.html !== false ? options.html : \"\";\n            }\n            if (options.bgPos) {\n                var bgPos = toPoint(options.bgPos);\n                div.style.backgroundPosition = -bgPos.x + \"px \" + -bgPos.y + \"px\";\n            }\n            this._setIconStyles(div, \"icon\");\n            return div;\n        },\n        createShadow: function() {\n            return null;\n        }\n    });\n    // @factory L.divIcon(options: DivIcon options)\n    // Creates a `DivIcon` instance with the given options.\n    function divIcon(options) {\n        return new DivIcon(options);\n    }\n    Icon.Default = IconDefault;\n    /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */ var GridLayer = Layer.extend({\n        // @section\n        // @aka GridLayer options\n        options: {\n            // @option tileSize: Number|Point = 256\n            // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n            tileSize: 256,\n            // @option opacity: Number = 1.0\n            // Opacity of the tiles. Can be used in the `createTile()` function.\n            opacity: 1,\n            // @option updateWhenIdle: Boolean = (depends)\n            // Load new tiles only when panning ends.\n            // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n            // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n            // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n            updateWhenIdle: Browser.mobile,\n            // @option updateWhenZooming: Boolean = true\n            // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n            updateWhenZooming: true,\n            // @option updateInterval: Number = 200\n            // Tiles will not update more than once every `updateInterval` milliseconds when panning.\n            updateInterval: 200,\n            // @option zIndex: Number = 1\n            // The explicit zIndex of the tile layer.\n            zIndex: 1,\n            // @option bounds: LatLngBounds = undefined\n            // If set, tiles will only be loaded inside the set `LatLngBounds`.\n            bounds: null,\n            // @option minZoom: Number = 0\n            // The minimum zoom level down to which this layer will be displayed (inclusive).\n            minZoom: 0,\n            // @option maxZoom: Number = undefined\n            // The maximum zoom level up to which this layer will be displayed (inclusive).\n            maxZoom: undefined,\n            // @option maxNativeZoom: Number = undefined\n            // Maximum zoom number the tile source has available. If it is specified,\n            // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n            // from `maxNativeZoom` level and auto-scaled.\n            maxNativeZoom: undefined,\n            // @option minNativeZoom: Number = undefined\n            // Minimum zoom number the tile source has available. If it is specified,\n            // the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n            // from `minNativeZoom` level and auto-scaled.\n            minNativeZoom: undefined,\n            // @option noWrap: Boolean = false\n            // Whether the layer is wrapped around the antimeridian. If `true`, the\n            // GridLayer will only be displayed once at low zoom levels. Has no\n            // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n            // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n            // tiles outside the CRS limits.\n            noWrap: false,\n            // @option pane: String = 'tilePane'\n            // `Map pane` where the grid layer will be added.\n            pane: \"tilePane\",\n            // @option className: String = ''\n            // A custom class name to assign to the tile layer. Empty by default.\n            className: \"\",\n            // @option keepBuffer: Number = 2\n            // When panning the map, keep this many rows and columns of tiles before unloading them.\n            keepBuffer: 2\n        },\n        initialize: function(options) {\n            setOptions(this, options);\n        },\n        onAdd: function() {\n            this._initContainer();\n            this._levels = {};\n            this._tiles = {};\n            this._resetView(); // implicit _update() call\n        },\n        beforeAdd: function(map) {\n            map._addZoomLimit(this);\n        },\n        onRemove: function(map) {\n            this._removeAllTiles();\n            remove(this._container);\n            map._removeZoomLimit(this);\n            this._container = null;\n            this._tileZoom = undefined;\n        },\n        // @method bringToFront: this\n        // Brings the tile layer to the top of all tile layers.\n        bringToFront: function() {\n            if (this._map) {\n                toFront(this._container);\n                this._setAutoZIndex(Math.max);\n            }\n            return this;\n        },\n        // @method bringToBack: this\n        // Brings the tile layer to the bottom of all tile layers.\n        bringToBack: function() {\n            if (this._map) {\n                toBack(this._container);\n                this._setAutoZIndex(Math.min);\n            }\n            return this;\n        },\n        // @method getContainer: HTMLElement\n        // Returns the HTML element that contains the tiles for this layer.\n        getContainer: function() {\n            return this._container;\n        },\n        // @method setOpacity(opacity: Number): this\n        // Changes the [opacity](#gridlayer-opacity) of the grid layer.\n        setOpacity: function(opacity) {\n            this.options.opacity = opacity;\n            this._updateOpacity();\n            return this;\n        },\n        // @method setZIndex(zIndex: Number): this\n        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n        setZIndex: function(zIndex) {\n            this.options.zIndex = zIndex;\n            this._updateZIndex();\n            return this;\n        },\n        // @method isLoading: Boolean\n        // Returns `true` if any tile in the grid layer has not finished loading.\n        isLoading: function() {\n            return this._loading;\n        },\n        // @method redraw: this\n        // Causes the layer to clear all the tiles and request them again.\n        redraw: function() {\n            if (this._map) {\n                this._removeAllTiles();\n                var tileZoom = this._clampZoom(this._map.getZoom());\n                if (tileZoom !== this._tileZoom) {\n                    this._tileZoom = tileZoom;\n                    this._updateLevels();\n                }\n                this._update();\n            }\n            return this;\n        },\n        getEvents: function() {\n            var events = {\n                viewprereset: this._invalidateAll,\n                viewreset: this._resetView,\n                zoom: this._resetView,\n                moveend: this._onMoveEnd\n            };\n            if (!this.options.updateWhenIdle) {\n                // update tiles on move, but not more often than once per given interval\n                if (!this._onMove) {\n                    this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n                }\n                events.move = this._onMove;\n            }\n            if (this._zoomAnimated) {\n                events.zoomanim = this._animateZoom;\n            }\n            return events;\n        },\n        // @section Extension methods\n        // Layers extending `GridLayer` shall reimplement the following method.\n        // @method createTile(coords: Object, done?: Function): HTMLElement\n        // Called only internally, must be overridden by classes extending `GridLayer`.\n        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n        // is specified, it must be called when the tile has finished loading and drawing.\n        createTile: function() {\n            return document.createElement(\"div\");\n        },\n        // @section\n        // @method getTileSize: Point\n        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n        getTileSize: function() {\n            var s = this.options.tileSize;\n            return s instanceof Point ? s : new Point(s, s);\n        },\n        _updateZIndex: function() {\n            if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n                this._container.style.zIndex = this.options.zIndex;\n            }\n        },\n        _setAutoZIndex: function(compare) {\n            // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n            var layers = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n            for(var i = 0, len = layers.length, zIndex; i < len; i++){\n                zIndex = layers[i].style.zIndex;\n                if (layers[i] !== this._container && zIndex) {\n                    edgeZIndex = compare(edgeZIndex, +zIndex);\n                }\n            }\n            if (isFinite(edgeZIndex)) {\n                this.options.zIndex = edgeZIndex + compare(-1, 1);\n                this._updateZIndex();\n            }\n        },\n        _updateOpacity: function() {\n            if (!this._map) {\n                return;\n            }\n            // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n            if (Browser.ielt9) {\n                return;\n            }\n            setOpacity(this._container, this.options.opacity);\n            var now = +new Date(), nextFrame = false, willPrune = false;\n            for(var key in this._tiles){\n                var tile = this._tiles[key];\n                if (!tile.current || !tile.loaded) {\n                    continue;\n                }\n                var fade = Math.min(1, (now - tile.loaded) / 200);\n                setOpacity(tile.el, fade);\n                if (fade < 1) {\n                    nextFrame = true;\n                } else {\n                    if (tile.active) {\n                        willPrune = true;\n                    } else {\n                        this._onOpaqueTile(tile);\n                    }\n                    tile.active = true;\n                }\n            }\n            if (willPrune && !this._noPrune) {\n                this._pruneTiles();\n            }\n            if (nextFrame) {\n                cancelAnimFrame(this._fadeFrame);\n                this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n            }\n        },\n        _onOpaqueTile: falseFn,\n        _initContainer: function() {\n            if (this._container) {\n                return;\n            }\n            this._container = create$1(\"div\", \"leaflet-layer \" + (this.options.className || \"\"));\n            this._updateZIndex();\n            if (this.options.opacity < 1) {\n                this._updateOpacity();\n            }\n            this.getPane().appendChild(this._container);\n        },\n        _updateLevels: function() {\n            var zoom = this._tileZoom, maxZoom = this.options.maxZoom;\n            if (zoom === undefined) {\n                return undefined;\n            }\n            for(var z in this._levels){\n                z = Number(z);\n                if (this._levels[z].el.children.length || z === zoom) {\n                    this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n                    this._onUpdateLevel(z);\n                } else {\n                    remove(this._levels[z].el);\n                    this._removeTilesAtZoom(z);\n                    this._onRemoveLevel(z);\n                    delete this._levels[z];\n                }\n            }\n            var level = this._levels[zoom], map = this._map;\n            if (!level) {\n                level = this._levels[zoom] = {};\n                level.el = create$1(\"div\", \"leaflet-tile-container leaflet-zoom-animated\", this._container);\n                level.el.style.zIndex = maxZoom;\n                level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n                level.zoom = zoom;\n                this._setZoomTransform(level, map.getCenter(), map.getZoom());\n                // force the browser to consider the newly added element for transition\n                falseFn(level.el.offsetWidth);\n                this._onCreateLevel(level);\n            }\n            this._level = level;\n            return level;\n        },\n        _onUpdateLevel: falseFn,\n        _onRemoveLevel: falseFn,\n        _onCreateLevel: falseFn,\n        _pruneTiles: function() {\n            if (!this._map) {\n                return;\n            }\n            var key, tile;\n            var zoom = this._map.getZoom();\n            if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n                this._removeAllTiles();\n                return;\n            }\n            for(key in this._tiles){\n                tile = this._tiles[key];\n                tile.retain = tile.current;\n            }\n            for(key in this._tiles){\n                tile = this._tiles[key];\n                if (tile.current && !tile.active) {\n                    var coords = tile.coords;\n                    if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n                        this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n                    }\n                }\n            }\n            for(key in this._tiles){\n                if (!this._tiles[key].retain) {\n                    this._removeTile(key);\n                }\n            }\n        },\n        _removeTilesAtZoom: function(zoom) {\n            for(var key in this._tiles){\n                if (this._tiles[key].coords.z !== zoom) {\n                    continue;\n                }\n                this._removeTile(key);\n            }\n        },\n        _removeAllTiles: function() {\n            for(var key in this._tiles){\n                this._removeTile(key);\n            }\n        },\n        _invalidateAll: function() {\n            for(var z in this._levels){\n                remove(this._levels[z].el);\n                this._onRemoveLevel(Number(z));\n                delete this._levels[z];\n            }\n            this._removeAllTiles();\n            this._tileZoom = undefined;\n        },\n        _retainParent: function(x, y, z, minZoom) {\n            var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);\n            coords2.z = +z2;\n            var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];\n            if (tile && tile.active) {\n                tile.retain = true;\n                return true;\n            } else if (tile && tile.loaded) {\n                tile.retain = true;\n            }\n            if (z2 > minZoom) {\n                return this._retainParent(x2, y2, z2, minZoom);\n            }\n            return false;\n        },\n        _retainChildren: function(x, y, z, maxZoom) {\n            for(var i = 2 * x; i < 2 * x + 2; i++){\n                for(var j = 2 * y; j < 2 * y + 2; j++){\n                    var coords = new Point(i, j);\n                    coords.z = z + 1;\n                    var key = this._tileCoordsToKey(coords), tile = this._tiles[key];\n                    if (tile && tile.active) {\n                        tile.retain = true;\n                        continue;\n                    } else if (tile && tile.loaded) {\n                        tile.retain = true;\n                    }\n                    if (z + 1 < maxZoom) {\n                        this._retainChildren(i, j, z + 1, maxZoom);\n                    }\n                }\n            }\n        },\n        _resetView: function(e) {\n            var animating = e && (e.pinch || e.flyTo);\n            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n        },\n        _animateZoom: function(e) {\n            this._setView(e.center, e.zoom, true, e.noUpdate);\n        },\n        _clampZoom: function(zoom) {\n            var options = this.options;\n            if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n                return options.minNativeZoom;\n            }\n            if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n                return options.maxNativeZoom;\n            }\n            return zoom;\n        },\n        _setView: function(center, zoom, noPrune, noUpdate) {\n            var tileZoom = Math.round(zoom);\n            if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {\n                tileZoom = undefined;\n            } else {\n                tileZoom = this._clampZoom(tileZoom);\n            }\n            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;\n            if (!noUpdate || tileZoomChanged) {\n                this._tileZoom = tileZoom;\n                if (this._abortLoading) {\n                    this._abortLoading();\n                }\n                this._updateLevels();\n                this._resetGrid();\n                if (tileZoom !== undefined) {\n                    this._update(center);\n                }\n                if (!noPrune) {\n                    this._pruneTiles();\n                }\n                // Flag to prevent _updateOpacity from pruning tiles during\n                // a zoom anim or a pinch gesture\n                this._noPrune = !!noPrune;\n            }\n            this._setZoomTransforms(center, zoom);\n        },\n        _setZoomTransforms: function(center, zoom) {\n            for(var i in this._levels){\n                this._setZoomTransform(this._levels[i], center, zoom);\n            }\n        },\n        _setZoomTransform: function(level, center, zoom) {\n            var scale = this._map.getZoomScale(zoom, level.zoom), translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n            if (Browser.any3d) {\n                setTransform(level.el, translate, scale);\n            } else {\n                setPosition(level.el, translate);\n            }\n        },\n        _resetGrid: function() {\n            var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;\n            var bounds = this._map.getPixelWorldBounds(this._tileZoom);\n            if (bounds) {\n                this._globalTileRange = this._pxBoundsToTileRange(bounds);\n            }\n            this._wrapX = crs.wrapLng && !this.options.noWrap && [\n                Math.floor(map.project([\n                    0,\n                    crs.wrapLng[0]\n                ], tileZoom).x / tileSize.x),\n                Math.ceil(map.project([\n                    0,\n                    crs.wrapLng[1]\n                ], tileZoom).x / tileSize.y)\n            ];\n            this._wrapY = crs.wrapLat && !this.options.noWrap && [\n                Math.floor(map.project([\n                    crs.wrapLat[0],\n                    0\n                ], tileZoom).y / tileSize.x),\n                Math.ceil(map.project([\n                    crs.wrapLat[1],\n                    0\n                ], tileZoom).y / tileSize.y)\n            ];\n        },\n        _onMoveEnd: function() {\n            if (!this._map || this._map._animatingZoom) {\n                return;\n            }\n            this._update();\n        },\n        _getTiledPixelBounds: function(center) {\n            var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale * 2);\n            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n        },\n        // Private method to load tiles in the grid's active zoom level according to map bounds\n        _update: function(center) {\n            var map = this._map;\n            if (!map) {\n                return;\n            }\n            var zoom = this._clampZoom(map.getZoom());\n            if (center === undefined) {\n                center = map.getCenter();\n            }\n            if (this._tileZoom === undefined) {\n                return;\n            } // if out of minzoom/maxzoom\n            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([\n                margin,\n                -margin\n            ]), tileRange.getTopRight().add([\n                margin,\n                -margin\n            ]));\n            // Sanity check: panic if the tile range contains Infinity somewhere.\n            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n                throw new Error(\"Attempted to load an infinite number of tiles\");\n            }\n            for(var key in this._tiles){\n                var c = this._tiles[key].coords;\n                if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n                    this._tiles[key].current = false;\n                }\n            }\n            // _update just loads more tiles. If the tile zoom level differs too much\n            // from the map's, let _setView reset levels and prune old tiles.\n            if (Math.abs(zoom - this._tileZoom) > 1) {\n                this._setView(center, zoom);\n                return;\n            }\n            // create a queue of coordinates to load tiles from\n            for(var j = tileRange.min.y; j <= tileRange.max.y; j++){\n                for(var i = tileRange.min.x; i <= tileRange.max.x; i++){\n                    var coords = new Point(i, j);\n                    coords.z = this._tileZoom;\n                    if (!this._isValidTile(coords)) {\n                        continue;\n                    }\n                    var tile = this._tiles[this._tileCoordsToKey(coords)];\n                    if (tile) {\n                        tile.current = true;\n                    } else {\n                        queue.push(coords);\n                    }\n                }\n            }\n            // sort tile queue to load tiles in order of their distance to center\n            queue.sort(function(a, b) {\n                return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n            });\n            if (queue.length !== 0) {\n                // if it's the first batch of tiles to load\n                if (!this._loading) {\n                    this._loading = true;\n                    // @event loading: Event\n                    // Fired when the grid layer starts loading tiles.\n                    this.fire(\"loading\");\n                }\n                // create DOM fragment to append tiles in one batch\n                var fragment = document.createDocumentFragment();\n                for(i = 0; i < queue.length; i++){\n                    this._addTile(queue[i], fragment);\n                }\n                this._level.el.appendChild(fragment);\n            }\n        },\n        _isValidTile: function(coords) {\n            var crs = this._map.options.crs;\n            if (!crs.infinite) {\n                // don't load tile if it's out of bounds and not wrapped\n                var bounds = this._globalTileRange;\n                if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n                    return false;\n                }\n            }\n            if (!this.options.bounds) {\n                return true;\n            }\n            // don't load tile if it doesn't intersect the bounds in options\n            var tileBounds = this._tileCoordsToBounds(coords);\n            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n        },\n        _keyToBounds: function(key) {\n            return this._tileCoordsToBounds(this._keyToTileCoords(key));\n        },\n        _tileCoordsToNwSe: function(coords) {\n            var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se = map.unproject(sePoint, coords.z);\n            return [\n                nw,\n                se\n            ];\n        },\n        // converts tile coordinates to its geographical bounds\n        _tileCoordsToBounds: function(coords) {\n            var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);\n            if (!this.options.noWrap) {\n                bounds = this._map.wrapLatLngBounds(bounds);\n            }\n            return bounds;\n        },\n        // converts tile coordinates to key for the tile cache\n        _tileCoordsToKey: function(coords) {\n            return coords.x + \":\" + coords.y + \":\" + coords.z;\n        },\n        // converts tile cache key to coordinates\n        _keyToTileCoords: function(key) {\n            var k = key.split(\":\"), coords = new Point(+k[0], +k[1]);\n            coords.z = +k[2];\n            return coords;\n        },\n        _removeTile: function(key) {\n            var tile = this._tiles[key];\n            if (!tile) {\n                return;\n            }\n            remove(tile.el);\n            delete this._tiles[key];\n            // @event tileunload: TileEvent\n            // Fired when a tile is removed (e.g. when a tile goes off the screen).\n            this.fire(\"tileunload\", {\n                tile: tile.el,\n                coords: this._keyToTileCoords(key)\n            });\n        },\n        _initTile: function(tile) {\n            addClass(tile, \"leaflet-tile\");\n            var tileSize = this.getTileSize();\n            tile.style.width = tileSize.x + \"px\";\n            tile.style.height = tileSize.y + \"px\";\n            tile.onselectstart = falseFn;\n            tile.onmousemove = falseFn;\n            // update opacity on tiles in IE7-8 because of filter inheritance problems\n            if (Browser.ielt9 && this.options.opacity < 1) {\n                setOpacity(tile, this.options.opacity);\n            }\n        },\n        _addTile: function(coords, container) {\n            var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);\n            var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n            this._initTile(tile);\n            // if createTile is defined with a second argument (\"done\" callback),\n            // we know that tile is async and will be ready later; otherwise\n            if (this.createTile.length < 2) {\n                // mark tile as ready, but delay one frame for opacity animation to happen\n                requestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n            }\n            setPosition(tile, tilePos);\n            // save tile in cache\n            this._tiles[key] = {\n                el: tile,\n                coords: coords,\n                current: true\n            };\n            container.appendChild(tile);\n            // @event tileloadstart: TileEvent\n            // Fired when a tile is requested and starts loading.\n            this.fire(\"tileloadstart\", {\n                tile: tile,\n                coords: coords\n            });\n        },\n        _tileReady: function(coords, err, tile) {\n            if (err) {\n                // @event tileerror: TileErrorEvent\n                // Fired when there is an error loading a tile.\n                this.fire(\"tileerror\", {\n                    error: err,\n                    tile: tile,\n                    coords: coords\n                });\n            }\n            var key = this._tileCoordsToKey(coords);\n            tile = this._tiles[key];\n            if (!tile) {\n                return;\n            }\n            tile.loaded = +new Date();\n            if (this._map._fadeAnimated) {\n                setOpacity(tile.el, 0);\n                cancelAnimFrame(this._fadeFrame);\n                this._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n            } else {\n                tile.active = true;\n                this._pruneTiles();\n            }\n            if (!err) {\n                addClass(tile.el, \"leaflet-tile-loaded\");\n                // @event tileload: TileEvent\n                // Fired when a tile loads.\n                this.fire(\"tileload\", {\n                    tile: tile.el,\n                    coords: coords\n                });\n            }\n            if (this._noTilesToLoad()) {\n                this._loading = false;\n                // @event load: Event\n                // Fired when the grid layer loaded all visible tiles.\n                this.fire(\"load\");\n                if (Browser.ielt9 || !this._map._fadeAnimated) {\n                    requestAnimFrame(this._pruneTiles, this);\n                } else {\n                    // Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n                    // to trigger a pruning.\n                    setTimeout(bind(this._pruneTiles, this), 250);\n                }\n            }\n        },\n        _getTilePos: function(coords) {\n            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n        },\n        _wrapCoords: function(coords) {\n            var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n            newCoords.z = coords.z;\n            return newCoords;\n        },\n        _pxBoundsToTileRange: function(bounds) {\n            var tileSize = this.getTileSize();\n            return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([\n                1,\n                1\n            ]));\n        },\n        _noTilesToLoad: function() {\n            for(var key in this._tiles){\n                if (!this._tiles[key].loaded) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    });\n    // @factory L.gridLayer(options?: GridLayer options)\n    // Creates a new instance of GridLayer with the supplied options.\n    function gridLayer(options) {\n        return new GridLayer(options);\n    }\n    /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'}).addTo(map);\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */ var TileLayer = GridLayer.extend({\n        // @section\n        // @aka TileLayer options\n        options: {\n            // @option minZoom: Number = 0\n            // The minimum zoom level down to which this layer will be displayed (inclusive).\n            minZoom: 0,\n            // @option maxZoom: Number = 18\n            // The maximum zoom level up to which this layer will be displayed (inclusive).\n            maxZoom: 18,\n            // @option subdomains: String|String[] = 'abc'\n            // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\n            subdomains: \"abc\",\n            // @option errorTileUrl: String = ''\n            // URL to the tile image to show in place of the tile that failed to load.\n            errorTileUrl: \"\",\n            // @option zoomOffset: Number = 0\n            // The zoom number used in tile URLs will be offset with this value.\n            zoomOffset: 0,\n            // @option tms: Boolean = false\n            // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\n            tms: false,\n            // @option zoomReverse: Boolean = false\n            // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\n            zoomReverse: false,\n            // @option detectRetina: Boolean = false\n            // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\n            detectRetina: false,\n            // @option crossOrigin: Boolean|String = false\n            // Whether the crossOrigin attribute will be added to the tiles.\n            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\n            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\n            crossOrigin: false,\n            // @option referrerPolicy: Boolean|String = false\n            // Whether the referrerPolicy attribute will be added to the tiles.\n            // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.\n            // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer\n            // (e.g. to validate an API token).\n            // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.\n            referrerPolicy: false\n        },\n        initialize: function(url, options) {\n            this._url = url;\n            options = setOptions(this, options);\n            // detecting retina displays, adjusting tileSize and zoom levels\n            if (options.detectRetina && Browser.retina && options.maxZoom > 0) {\n                options.tileSize = Math.floor(options.tileSize / 2);\n                if (!options.zoomReverse) {\n                    options.zoomOffset++;\n                    options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);\n                } else {\n                    options.zoomOffset--;\n                    options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);\n                }\n                options.minZoom = Math.max(0, options.minZoom);\n            } else if (!options.zoomReverse) {\n                // make sure maxZoom is gte minZoom\n                options.maxZoom = Math.max(options.minZoom, options.maxZoom);\n            } else {\n                // make sure minZoom is lte maxZoom\n                options.minZoom = Math.min(options.maxZoom, options.minZoom);\n            }\n            if (typeof options.subdomains === \"string\") {\n                options.subdomains = options.subdomains.split(\"\");\n            }\n            this.on(\"tileunload\", this._onTileRemove);\n        },\n        // @method setUrl(url: String, noRedraw?: Boolean): this\n        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\n        // If the URL does not change, the layer will not be redrawn unless\n        // the noRedraw parameter is set to false.\n        setUrl: function(url, noRedraw) {\n            if (this._url === url && noRedraw === undefined) {\n                noRedraw = true;\n            }\n            this._url = url;\n            if (!noRedraw) {\n                this.redraw();\n            }\n            return this;\n        },\n        // @method createTile(coords: Object, done?: Function): HTMLElement\n        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\n        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\n        // callback is called when the tile has been loaded.\n        createTile: function(coords, done) {\n            var tile = document.createElement(\"img\");\n            on(tile, \"load\", bind(this._tileOnLoad, this, done, tile));\n            on(tile, \"error\", bind(this._tileOnError, this, done, tile));\n            if (this.options.crossOrigin || this.options.crossOrigin === \"\") {\n                tile.crossOrigin = this.options.crossOrigin === true ? \"\" : this.options.crossOrigin;\n            }\n            // for this new option we follow the documented behavior\n            // more closely by only setting the property when string\n            if (typeof this.options.referrerPolicy === \"string\") {\n                tile.referrerPolicy = this.options.referrerPolicy;\n            }\n            // The alt attribute is set to the empty string,\n            // allowing screen readers to ignore the decorative image tiles.\n            // https://www.w3.org/WAI/tutorials/images/decorative/\n            // https://www.w3.org/TR/html-aria/#el-img-empty-alt\n            tile.alt = \"\";\n            tile.src = this.getTileUrl(coords);\n            return tile;\n        },\n        // @section Extension methods\n        // @uninheritable\n        // Layers extending `TileLayer` might reimplement the following method.\n        // @method getTileUrl(coords: Object): String\n        // Called only internally, returns the URL for a tile given its coordinates.\n        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\n        getTileUrl: function(coords) {\n            var data = {\n                r: Browser.retina ? \"@2x\" : \"\",\n                s: this._getSubdomain(coords),\n                x: coords.x,\n                y: coords.y,\n                z: this._getZoomForUrl()\n            };\n            if (this._map && !this._map.options.crs.infinite) {\n                var invertedY = this._globalTileRange.max.y - coords.y;\n                if (this.options.tms) {\n                    data[\"y\"] = invertedY;\n                }\n                data[\"-y\"] = invertedY;\n            }\n            return template(this._url, extend(data, this.options));\n        },\n        _tileOnLoad: function(done, tile) {\n            // For https://github.com/Leaflet/Leaflet/issues/3332\n            if (Browser.ielt9) {\n                setTimeout(bind(done, this, null, tile), 0);\n            } else {\n                done(null, tile);\n            }\n        },\n        _tileOnError: function(done, tile, e) {\n            var errorUrl = this.options.errorTileUrl;\n            if (errorUrl && tile.getAttribute(\"src\") !== errorUrl) {\n                tile.src = errorUrl;\n            }\n            done(e, tile);\n        },\n        _onTileRemove: function(e) {\n            e.tile.onload = null;\n        },\n        _getZoomForUrl: function() {\n            var zoom = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;\n            if (zoomReverse) {\n                zoom = maxZoom - zoom;\n            }\n            return zoom + zoomOffset;\n        },\n        _getSubdomain: function(tilePoint) {\n            var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n            return this.options.subdomains[index];\n        },\n        // stops loading all tiles in the background layer\n        _abortLoading: function() {\n            var i, tile;\n            for(i in this._tiles){\n                if (this._tiles[i].coords.z !== this._tileZoom) {\n                    tile = this._tiles[i].el;\n                    tile.onload = falseFn;\n                    tile.onerror = falseFn;\n                    if (!tile.complete) {\n                        tile.src = emptyImageUrl;\n                        var coords = this._tiles[i].coords;\n                        remove(tile);\n                        delete this._tiles[i];\n                        // @event tileabort: TileEvent\n                        // Fired when a tile was loading but is now not wanted.\n                        this.fire(\"tileabort\", {\n                            tile: tile,\n                            coords: coords\n                        });\n                    }\n                }\n            }\n        },\n        _removeTile: function(key) {\n            var tile = this._tiles[key];\n            if (!tile) {\n                return;\n            }\n            // Cancels any pending http requests associated with the tile\n            tile.el.setAttribute(\"src\", emptyImageUrl);\n            return GridLayer.prototype._removeTile.call(this, key);\n        },\n        _tileReady: function(coords, err, tile) {\n            if (!this._map || tile && tile.getAttribute(\"src\") === emptyImageUrl) {\n                return;\n            }\n            return GridLayer.prototype._tileReady.call(this, coords, err, tile);\n        }\n    });\n    // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\n    // Instantiates a tile layer object given a `URL template` and optionally an options object.\n    function tileLayer(url, options) {\n        return new TileLayer(url, options);\n    }\n    /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data © 2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */ var TileLayerWMS = TileLayer.extend({\n        // @section\n        // @aka TileLayer.WMS options\n        // If any custom options not documented here are used, they will be sent to the\n        // WMS server as extra parameters in each request URL. This can be useful for\n        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\n        defaultWmsParams: {\n            service: \"WMS\",\n            request: \"GetMap\",\n            // @option layers: String = ''\n            // **(required)** Comma-separated list of WMS layers to show.\n            layers: \"\",\n            // @option styles: String = ''\n            // Comma-separated list of WMS styles.\n            styles: \"\",\n            // @option format: String = 'image/jpeg'\n            // WMS image format (use `'image/png'` for layers with transparency).\n            format: \"image/jpeg\",\n            // @option transparent: Boolean = false\n            // If `true`, the WMS service will return images with transparency.\n            transparent: false,\n            // @option version: String = '1.1.1'\n            // Version of the WMS service to use\n            version: \"1.1.1\"\n        },\n        options: {\n            // @option crs: CRS = null\n            // Coordinate Reference System to use for the WMS requests, defaults to\n            // map CRS. Don't change this if you're not sure what it means.\n            crs: null,\n            // @option uppercase: Boolean = false\n            // If `true`, WMS request parameter keys will be uppercase.\n            uppercase: false\n        },\n        initialize: function(url, options) {\n            this._url = url;\n            var wmsParams = extend({}, this.defaultWmsParams);\n            // all keys that are not TileLayer options go to WMS params\n            for(var i in options){\n                if (!(i in this.options)) {\n                    wmsParams[i] = options[i];\n                }\n            }\n            options = setOptions(this, options);\n            var realRetina = options.detectRetina && Browser.retina ? 2 : 1;\n            var tileSize = this.getTileSize();\n            wmsParams.width = tileSize.x * realRetina;\n            wmsParams.height = tileSize.y * realRetina;\n            this.wmsParams = wmsParams;\n        },\n        onAdd: function(map) {\n            this._crs = this.options.crs || map.options.crs;\n            this._wmsVersion = parseFloat(this.wmsParams.version);\n            var projectionKey = this._wmsVersion >= 1.3 ? \"crs\" : \"srs\";\n            this.wmsParams[projectionKey] = this._crs.code;\n            TileLayer.prototype.onAdd.call(this, map);\n        },\n        getTileUrl: function(coords) {\n            var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [\n                min.y,\n                min.x,\n                max.y,\n                max.x\n            ] : [\n                min.x,\n                min.y,\n                max.x,\n                max.y\n            ]).join(\",\"), url = TileLayer.prototype.getTileUrl.call(this, coords);\n            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? \"&BBOX=\" : \"&bbox=\") + bbox;\n        },\n        // @method setParams(params: Object, noRedraw?: Boolean): this\n        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\n        setParams: function(params, noRedraw) {\n            extend(this.wmsParams, params);\n            if (!noRedraw) {\n                this.redraw();\n            }\n            return this;\n        }\n    });\n    // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\n    // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\n    function tileLayerWMS(url, options) {\n        return new TileLayerWMS(url, options);\n    }\n    TileLayer.WMS = TileLayerWMS;\n    tileLayer.wms = tileLayerWMS;\n    /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */ var Renderer = Layer.extend({\n        // @section\n        // @aka Renderer options\n        options: {\n            // @option padding: Number = 0.1\n            // How much to extend the clip area around the map view (relative to its size)\n            // e.g. 0.1 would be 10% of map view in each direction\n            padding: 0.1\n        },\n        initialize: function(options) {\n            setOptions(this, options);\n            stamp(this);\n            this._layers = this._layers || {};\n        },\n        onAdd: function() {\n            if (!this._container) {\n                this._initContainer(); // defined by renderer implementations\n                // always keep transform-origin as 0 0\n                addClass(this._container, \"leaflet-zoom-animated\");\n            }\n            this.getPane().appendChild(this._container);\n            this._update();\n            this.on(\"update\", this._updatePaths, this);\n        },\n        onRemove: function() {\n            this.off(\"update\", this._updatePaths, this);\n            this._destroyContainer();\n        },\n        getEvents: function() {\n            var events = {\n                viewreset: this._reset,\n                zoom: this._onZoom,\n                moveend: this._update,\n                zoomend: this._onZoomEnd\n            };\n            if (this._zoomAnimated) {\n                events.zoomanim = this._onAnimZoom;\n            }\n            return events;\n        },\n        _onAnimZoom: function(ev) {\n            this._updateTransform(ev.center, ev.zoom);\n        },\n        _onZoom: function() {\n            this._updateTransform(this._map.getCenter(), this._map.getZoom());\n        },\n        _updateTransform: function(center, zoom) {\n            var scale = this._map.getZoomScale(zoom, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom), topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));\n            if (Browser.any3d) {\n                setTransform(this._container, topLeftOffset, scale);\n            } else {\n                setPosition(this._container, topLeftOffset);\n            }\n        },\n        _reset: function() {\n            this._update();\n            this._updateTransform(this._center, this._zoom);\n            for(var id in this._layers){\n                this._layers[id]._reset();\n            }\n        },\n        _onZoomEnd: function() {\n            for(var id in this._layers){\n                this._layers[id]._project();\n            }\n        },\n        _updatePaths: function() {\n            for(var id in this._layers){\n                this._layers[id]._update();\n            }\n        },\n        _update: function() {\n            // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n            // Subclasses are responsible of firing the 'update' event.\n            var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n            this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n            this._center = this._map.getCenter();\n            this._zoom = this._map.getZoom();\n        }\n    });\n    /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */ var Canvas = Renderer.extend({\n        // @section\n        // @aka Canvas options\n        options: {\n            // @option tolerance: Number = 0\n            // How much to extend the click tolerance around a path/object on the map.\n            tolerance: 0\n        },\n        getEvents: function() {\n            var events = Renderer.prototype.getEvents.call(this);\n            events.viewprereset = this._onViewPreReset;\n            return events;\n        },\n        _onViewPreReset: function() {\n            // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n            this._postponeUpdatePaths = true;\n        },\n        onAdd: function() {\n            Renderer.prototype.onAdd.call(this);\n            // Redraw vectors since canvas is cleared upon removal,\n            // in case of removing the renderer itself from the map.\n            this._draw();\n        },\n        _initContainer: function() {\n            var container = this._container = document.createElement(\"canvas\");\n            on(container, \"mousemove\", this._onMouseMove, this);\n            on(container, \"click dblclick mousedown mouseup contextmenu\", this._onClick, this);\n            on(container, \"mouseout\", this._handleMouseOut, this);\n            container[\"_leaflet_disable_events\"] = true;\n            this._ctx = container.getContext(\"2d\");\n        },\n        _destroyContainer: function() {\n            cancelAnimFrame(this._redrawRequest);\n            delete this._ctx;\n            remove(this._container);\n            off(this._container);\n            delete this._container;\n        },\n        _updatePaths: function() {\n            if (this._postponeUpdatePaths) {\n                return;\n            }\n            var layer;\n            this._redrawBounds = null;\n            for(var id in this._layers){\n                layer = this._layers[id];\n                layer._update();\n            }\n            this._redraw();\n        },\n        _update: function() {\n            if (this._map._animatingZoom && this._bounds) {\n                return;\n            }\n            Renderer.prototype._update.call(this);\n            var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;\n            setPosition(container, b.min);\n            // set canvas size (also clearing it); use double size on retina\n            container.width = m * size.x;\n            container.height = m * size.y;\n            container.style.width = size.x + \"px\";\n            container.style.height = size.y + \"px\";\n            if (Browser.retina) {\n                this._ctx.scale(2, 2);\n            }\n            // translate so we use the same path coordinates after canvas element moves\n            this._ctx.translate(-b.min.x, -b.min.y);\n            // Tell paths to redraw themselves\n            this.fire(\"update\");\n        },\n        _reset: function() {\n            Renderer.prototype._reset.call(this);\n            if (this._postponeUpdatePaths) {\n                this._postponeUpdatePaths = false;\n                this._updatePaths();\n            }\n        },\n        _initPath: function(layer) {\n            this._updateDashArray(layer);\n            this._layers[stamp(layer)] = layer;\n            var order = layer._order = {\n                layer: layer,\n                prev: this._drawLast,\n                next: null\n            };\n            if (this._drawLast) {\n                this._drawLast.next = order;\n            }\n            this._drawLast = order;\n            this._drawFirst = this._drawFirst || this._drawLast;\n        },\n        _addPath: function(layer) {\n            this._requestRedraw(layer);\n        },\n        _removePath: function(layer) {\n            var order = layer._order;\n            var next = order.next;\n            var prev = order.prev;\n            if (next) {\n                next.prev = prev;\n            } else {\n                this._drawLast = prev;\n            }\n            if (prev) {\n                prev.next = next;\n            } else {\n                this._drawFirst = next;\n            }\n            delete layer._order;\n            delete this._layers[stamp(layer)];\n            this._requestRedraw(layer);\n        },\n        _updatePath: function(layer) {\n            // Redraw the union of the layer's old pixel\n            // bounds and the new pixel bounds.\n            this._extendRedrawBounds(layer);\n            layer._project();\n            layer._update();\n            // The redraw will extend the redraw bounds\n            // with the new pixel bounds.\n            this._requestRedraw(layer);\n        },\n        _updateStyle: function(layer) {\n            this._updateDashArray(layer);\n            this._requestRedraw(layer);\n        },\n        _updateDashArray: function(layer) {\n            if (typeof layer.options.dashArray === \"string\") {\n                var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;\n                for(i = 0; i < parts.length; i++){\n                    dashValue = Number(parts[i]);\n                    // Ignore dash array containing invalid lengths\n                    if (isNaN(dashValue)) {\n                        return;\n                    }\n                    dashArray.push(dashValue);\n                }\n                layer.options._dashArray = dashArray;\n            } else {\n                layer.options._dashArray = layer.options.dashArray;\n            }\n        },\n        _requestRedraw: function(layer) {\n            if (!this._map) {\n                return;\n            }\n            this._extendRedrawBounds(layer);\n            this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n        },\n        _extendRedrawBounds: function(layer) {\n            if (layer._pxBounds) {\n                var padding = (layer.options.weight || 0) + 1;\n                this._redrawBounds = this._redrawBounds || new Bounds();\n                this._redrawBounds.extend(layer._pxBounds.min.subtract([\n                    padding,\n                    padding\n                ]));\n                this._redrawBounds.extend(layer._pxBounds.max.add([\n                    padding,\n                    padding\n                ]));\n            }\n        },\n        _redraw: function() {\n            this._redrawRequest = null;\n            if (this._redrawBounds) {\n                this._redrawBounds.min._floor();\n                this._redrawBounds.max._ceil();\n            }\n            this._clear(); // clear layers in redraw bounds\n            this._draw(); // draw layers\n            this._redrawBounds = null;\n        },\n        _clear: function() {\n            var bounds = this._redrawBounds;\n            if (bounds) {\n                var size = bounds.getSize();\n                this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n            } else {\n                this._ctx.save();\n                this._ctx.setTransform(1, 0, 0, 1, 0, 0);\n                this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n                this._ctx.restore();\n            }\n        },\n        _draw: function() {\n            var layer, bounds = this._redrawBounds;\n            this._ctx.save();\n            if (bounds) {\n                var size = bounds.getSize();\n                this._ctx.beginPath();\n                this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n                this._ctx.clip();\n            }\n            this._drawing = true;\n            for(var order = this._drawFirst; order; order = order.next){\n                layer = order.layer;\n                if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {\n                    layer._updatePath();\n                }\n            }\n            this._drawing = false;\n            this._ctx.restore(); // Restore state before clipping.\n        },\n        _updatePoly: function(layer, closed) {\n            if (!this._drawing) {\n                return;\n            }\n            var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;\n            if (!len) {\n                return;\n            }\n            ctx.beginPath();\n            for(i = 0; i < len; i++){\n                for(j = 0, len2 = parts[i].length; j < len2; j++){\n                    p = parts[i][j];\n                    ctx[j ? \"lineTo\" : \"moveTo\"](p.x, p.y);\n                }\n                if (closed) {\n                    ctx.closePath();\n                }\n            }\n            this._fillStroke(ctx, layer);\n        // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n        },\n        _updateCircle: function(layer) {\n            if (!this._drawing || layer._empty()) {\n                return;\n            }\n            var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n            if (s !== 1) {\n                ctx.save();\n                ctx.scale(1, s);\n            }\n            ctx.beginPath();\n            ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n            if (s !== 1) {\n                ctx.restore();\n            }\n            this._fillStroke(ctx, layer);\n        },\n        _fillStroke: function(ctx, layer) {\n            var options = layer.options;\n            if (options.fill) {\n                ctx.globalAlpha = options.fillOpacity;\n                ctx.fillStyle = options.fillColor || options.color;\n                ctx.fill(options.fillRule || \"evenodd\");\n            }\n            if (options.stroke && options.weight !== 0) {\n                if (ctx.setLineDash) {\n                    ctx.setLineDash(layer.options && layer.options._dashArray || []);\n                }\n                ctx.globalAlpha = options.opacity;\n                ctx.lineWidth = options.weight;\n                ctx.strokeStyle = options.color;\n                ctx.lineCap = options.lineCap;\n                ctx.lineJoin = options.lineJoin;\n                ctx.stroke();\n            }\n        },\n        // Canvas obviously doesn't have mouse events for individual drawn objects,\n        // so we emulate that by calculating what's under the mouse on mousemove/click manually\n        _onClick: function(e) {\n            var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;\n            for(var order = this._drawFirst; order; order = order.next){\n                layer = order.layer;\n                if (layer.options.interactive && layer._containsPoint(point)) {\n                    if (!(e.type === \"click\" || e.type === \"preclick\") || !this._map._draggableMoved(layer)) {\n                        clickedLayer = layer;\n                    }\n                }\n            }\n            this._fireEvent(clickedLayer ? [\n                clickedLayer\n            ] : false, e);\n        },\n        _onMouseMove: function(e) {\n            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {\n                return;\n            }\n            var point = this._map.mouseEventToLayerPoint(e);\n            this._handleMouseHover(e, point);\n        },\n        _handleMouseOut: function(e) {\n            var layer = this._hoveredLayer;\n            if (layer) {\n                // if we're leaving the layer, fire mouseout\n                removeClass(this._container, \"leaflet-interactive\");\n                this._fireEvent([\n                    layer\n                ], e, \"mouseout\");\n                this._hoveredLayer = null;\n                this._mouseHoverThrottled = false;\n            }\n        },\n        _handleMouseHover: function(e, point) {\n            if (this._mouseHoverThrottled) {\n                return;\n            }\n            var layer, candidateHoveredLayer;\n            for(var order = this._drawFirst; order; order = order.next){\n                layer = order.layer;\n                if (layer.options.interactive && layer._containsPoint(point)) {\n                    candidateHoveredLayer = layer;\n                }\n            }\n            if (candidateHoveredLayer !== this._hoveredLayer) {\n                this._handleMouseOut(e);\n                if (candidateHoveredLayer) {\n                    addClass(this._container, \"leaflet-interactive\"); // change cursor\n                    this._fireEvent([\n                        candidateHoveredLayer\n                    ], e, \"mouseover\");\n                    this._hoveredLayer = candidateHoveredLayer;\n                }\n            }\n            this._fireEvent(this._hoveredLayer ? [\n                this._hoveredLayer\n            ] : false, e);\n            this._mouseHoverThrottled = true;\n            setTimeout(bind(function() {\n                this._mouseHoverThrottled = false;\n            }, this), 32);\n        },\n        _fireEvent: function(layers, e, type) {\n            this._map._fireDOMEvent(e, type || e.type, layers);\n        },\n        _bringToFront: function(layer) {\n            var order = layer._order;\n            if (!order) {\n                return;\n            }\n            var next = order.next;\n            var prev = order.prev;\n            if (next) {\n                next.prev = prev;\n            } else {\n                // Already last\n                return;\n            }\n            if (prev) {\n                prev.next = next;\n            } else if (next) {\n                // Update first entry unless this is the\n                // single entry\n                this._drawFirst = next;\n            }\n            order.prev = this._drawLast;\n            this._drawLast.next = order;\n            order.next = null;\n            this._drawLast = order;\n            this._requestRedraw(layer);\n        },\n        _bringToBack: function(layer) {\n            var order = layer._order;\n            if (!order) {\n                return;\n            }\n            var next = order.next;\n            var prev = order.prev;\n            if (prev) {\n                prev.next = next;\n            } else {\n                // Already first\n                return;\n            }\n            if (next) {\n                next.prev = prev;\n            } else if (prev) {\n                // Update last entry unless this is the\n                // single entry\n                this._drawLast = prev;\n            }\n            order.prev = null;\n            order.next = this._drawFirst;\n            this._drawFirst.prev = order;\n            this._drawFirst = order;\n            this._requestRedraw(layer);\n        }\n    });\n    // @factory L.canvas(options?: Renderer options)\n    // Creates a Canvas renderer with the given options.\n    function canvas(options) {\n        return Browser.canvas ? new Canvas(options) : null;\n    }\n    /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */ var vmlCreate = function() {\n        try {\n            document.namespaces.add(\"lvml\", \"urn:schemas-microsoft-com:vml\");\n            return function(name) {\n                return document.createElement(\"<lvml:\" + name + ' class=\"lvml\">');\n            };\n        } catch (e) {\n        // Do not return fn from catch block so `e` can be garbage collected\n        // See https://github.com/Leaflet/Leaflet/pull/7279\n        }\n        return function(name) {\n            return document.createElement(\"<\" + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n        };\n    }();\n    /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */ // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n    var vmlMixin = {\n        _initContainer: function() {\n            this._container = create$1(\"div\", \"leaflet-vml-container\");\n        },\n        _update: function() {\n            if (this._map._animatingZoom) {\n                return;\n            }\n            Renderer.prototype._update.call(this);\n            this.fire(\"update\");\n        },\n        _initPath: function(layer) {\n            var container = layer._container = vmlCreate(\"shape\");\n            addClass(container, \"leaflet-vml-shape \" + (this.options.className || \"\"));\n            container.coordsize = \"1 1\";\n            layer._path = vmlCreate(\"path\");\n            container.appendChild(layer._path);\n            this._updateStyle(layer);\n            this._layers[stamp(layer)] = layer;\n        },\n        _addPath: function(layer) {\n            var container = layer._container;\n            this._container.appendChild(container);\n            if (layer.options.interactive) {\n                layer.addInteractiveTarget(container);\n            }\n        },\n        _removePath: function(layer) {\n            var container = layer._container;\n            remove(container);\n            layer.removeInteractiveTarget(container);\n            delete this._layers[stamp(layer)];\n        },\n        _updateStyle: function(layer) {\n            var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;\n            container.stroked = !!options.stroke;\n            container.filled = !!options.fill;\n            if (options.stroke) {\n                if (!stroke) {\n                    stroke = layer._stroke = vmlCreate(\"stroke\");\n                }\n                container.appendChild(stroke);\n                stroke.weight = options.weight + \"px\";\n                stroke.color = options.color;\n                stroke.opacity = options.opacity;\n                if (options.dashArray) {\n                    stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(\" \") : options.dashArray.replace(/( *, *)/g, \" \");\n                } else {\n                    stroke.dashStyle = \"\";\n                }\n                stroke.endcap = options.lineCap.replace(\"butt\", \"flat\");\n                stroke.joinstyle = options.lineJoin;\n            } else if (stroke) {\n                container.removeChild(stroke);\n                layer._stroke = null;\n            }\n            if (options.fill) {\n                if (!fill) {\n                    fill = layer._fill = vmlCreate(\"fill\");\n                }\n                container.appendChild(fill);\n                fill.color = options.fillColor || options.color;\n                fill.opacity = options.fillOpacity;\n            } else if (fill) {\n                container.removeChild(fill);\n                layer._fill = null;\n            }\n        },\n        _updateCircle: function(layer) {\n            var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);\n            this._setPath(layer, layer._empty() ? \"M0 0\" : \"AL \" + p.x + \",\" + p.y + \" \" + r + \",\" + r2 + \" 0,\" + 65535 * 360);\n        },\n        _setPath: function(layer, path) {\n            layer._path.v = path;\n        },\n        _bringToFront: function(layer) {\n            toFront(layer._container);\n        },\n        _bringToBack: function(layer) {\n            toBack(layer._container);\n        }\n    };\n    var create = Browser.vml ? vmlCreate : svgCreate;\n    /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */ var SVG = Renderer.extend({\n        _initContainer: function() {\n            this._container = create(\"svg\");\n            // makes it possible to click through svg root; we'll reset it back in individual paths\n            this._container.setAttribute(\"pointer-events\", \"none\");\n            this._rootGroup = create(\"g\");\n            this._container.appendChild(this._rootGroup);\n        },\n        _destroyContainer: function() {\n            remove(this._container);\n            off(this._container);\n            delete this._container;\n            delete this._rootGroup;\n            delete this._svgSize;\n        },\n        _update: function() {\n            if (this._map._animatingZoom && this._bounds) {\n                return;\n            }\n            Renderer.prototype._update.call(this);\n            var b = this._bounds, size = b.getSize(), container = this._container;\n            // set size of svg-container if changed\n            if (!this._svgSize || !this._svgSize.equals(size)) {\n                this._svgSize = size;\n                container.setAttribute(\"width\", size.x);\n                container.setAttribute(\"height\", size.y);\n            }\n            // movement: update container viewBox so that we don't have to change coordinates of individual layers\n            setPosition(container, b.min);\n            container.setAttribute(\"viewBox\", [\n                b.min.x,\n                b.min.y,\n                size.x,\n                size.y\n            ].join(\" \"));\n            this.fire(\"update\");\n        },\n        // methods below are called by vector layers implementations\n        _initPath: function(layer) {\n            var path = layer._path = create(\"path\");\n            // @namespace Path\n            // @option className: String = null\n            // Custom class name set on an element. Only for SVG renderer.\n            if (layer.options.className) {\n                addClass(path, layer.options.className);\n            }\n            if (layer.options.interactive) {\n                addClass(path, \"leaflet-interactive\");\n            }\n            this._updateStyle(layer);\n            this._layers[stamp(layer)] = layer;\n        },\n        _addPath: function(layer) {\n            if (!this._rootGroup) {\n                this._initContainer();\n            }\n            this._rootGroup.appendChild(layer._path);\n            layer.addInteractiveTarget(layer._path);\n        },\n        _removePath: function(layer) {\n            remove(layer._path);\n            layer.removeInteractiveTarget(layer._path);\n            delete this._layers[stamp(layer)];\n        },\n        _updatePath: function(layer) {\n            layer._project();\n            layer._update();\n        },\n        _updateStyle: function(layer) {\n            var path = layer._path, options = layer.options;\n            if (!path) {\n                return;\n            }\n            if (options.stroke) {\n                path.setAttribute(\"stroke\", options.color);\n                path.setAttribute(\"stroke-opacity\", options.opacity);\n                path.setAttribute(\"stroke-width\", options.weight);\n                path.setAttribute(\"stroke-linecap\", options.lineCap);\n                path.setAttribute(\"stroke-linejoin\", options.lineJoin);\n                if (options.dashArray) {\n                    path.setAttribute(\"stroke-dasharray\", options.dashArray);\n                } else {\n                    path.removeAttribute(\"stroke-dasharray\");\n                }\n                if (options.dashOffset) {\n                    path.setAttribute(\"stroke-dashoffset\", options.dashOffset);\n                } else {\n                    path.removeAttribute(\"stroke-dashoffset\");\n                }\n            } else {\n                path.setAttribute(\"stroke\", \"none\");\n            }\n            if (options.fill) {\n                path.setAttribute(\"fill\", options.fillColor || options.color);\n                path.setAttribute(\"fill-opacity\", options.fillOpacity);\n                path.setAttribute(\"fill-rule\", options.fillRule || \"evenodd\");\n            } else {\n                path.setAttribute(\"fill\", \"none\");\n            }\n        },\n        _updatePoly: function(layer, closed) {\n            this._setPath(layer, pointsToPath(layer._parts, closed));\n        },\n        _updateCircle: function(layer) {\n            var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = \"a\" + r + \",\" + r2 + \" 0 1,0 \";\n            // drawing a circle with two half-arcs\n            var d = layer._empty() ? \"M0 0\" : \"M\" + (p.x - r) + \",\" + p.y + arc + r * 2 + \",0 \" + arc + -r * 2 + \",0 \";\n            this._setPath(layer, d);\n        },\n        _setPath: function(layer, path) {\n            layer._path.setAttribute(\"d\", path);\n        },\n        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n        _bringToFront: function(layer) {\n            toFront(layer._path);\n        },\n        _bringToBack: function(layer) {\n            toBack(layer._path);\n        }\n    });\n    if (Browser.vml) {\n        SVG.include(vmlMixin);\n    }\n    // @namespace SVG\n    // @factory L.svg(options?: Renderer options)\n    // Creates a SVG renderer with the given options.\n    function svg(options) {\n        return Browser.svg || Browser.vml ? new SVG(options) : null;\n    }\n    Map.include({\n        // @namespace Map; @method getRenderer(layer: Path): Renderer\n        // Returns the instance of `Renderer` that should be used to render the given\n        // `Path`. It will ensure that the `renderer` options of the map and paths\n        // are respected, and that the renderers do exist on the map.\n        getRenderer: function(layer) {\n            // @namespace Path; @option renderer: Renderer\n            // Use this specific instance of `Renderer` for this path. Takes\n            // precedence over the map's [default renderer](#map-renderer).\n            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n            if (!renderer) {\n                renderer = this._renderer = this._createRenderer();\n            }\n            if (!this.hasLayer(renderer)) {\n                this.addLayer(renderer);\n            }\n            return renderer;\n        },\n        _getPaneRenderer: function(name) {\n            if (name === \"overlayPane\" || name === undefined) {\n                return false;\n            }\n            var renderer = this._paneRenderers[name];\n            if (renderer === undefined) {\n                renderer = this._createRenderer({\n                    pane: name\n                });\n                this._paneRenderers[name] = renderer;\n            }\n            return renderer;\n        },\n        _createRenderer: function(options) {\n            // @namespace Map; @option preferCanvas: Boolean = false\n            // Whether `Path`s should be rendered on a `Canvas` renderer.\n            // By default, all `Path`s are rendered in a `SVG` renderer.\n            return this.options.preferCanvas && canvas(options) || svg(options);\n        }\n    });\n    /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */ /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */ var Rectangle = Polygon.extend({\n        initialize: function(latLngBounds, options) {\n            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n        },\n        // @method setBounds(latLngBounds: LatLngBounds): this\n        // Redraws the rectangle with the passed bounds.\n        setBounds: function(latLngBounds) {\n            return this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n        },\n        _boundsToLatLngs: function(latLngBounds) {\n            latLngBounds = toLatLngBounds(latLngBounds);\n            return [\n                latLngBounds.getSouthWest(),\n                latLngBounds.getNorthWest(),\n                latLngBounds.getNorthEast(),\n                latLngBounds.getSouthEast()\n            ];\n        }\n    });\n    // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n    function rectangle(latLngBounds, options) {\n        return new Rectangle(latLngBounds, options);\n    }\n    SVG.create = create;\n    SVG.pointsToPath = pointsToPath;\n    GeoJSON.geometryToLayer = geometryToLayer;\n    GeoJSON.coordsToLatLng = coordsToLatLng;\n    GeoJSON.coordsToLatLngs = coordsToLatLngs;\n    GeoJSON.latLngToCoords = latLngToCoords;\n    GeoJSON.latLngsToCoords = latLngsToCoords;\n    GeoJSON.getFeature = getFeature;\n    GeoJSON.asFeature = asFeature;\n    /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */ // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @option boxZoom: Boolean = true\n        // Whether the map can be zoomed to a rectangular area specified by\n        // dragging the mouse while pressing the shift key.\n        boxZoom: true\n    });\n    var BoxZoom = Handler.extend({\n        initialize: function(map) {\n            this._map = map;\n            this._container = map._container;\n            this._pane = map._panes.overlayPane;\n            this._resetStateTimeout = 0;\n            map.on(\"unload\", this._destroy, this);\n        },\n        addHooks: function() {\n            on(this._container, \"mousedown\", this._onMouseDown, this);\n        },\n        removeHooks: function() {\n            off(this._container, \"mousedown\", this._onMouseDown, this);\n        },\n        moved: function() {\n            return this._moved;\n        },\n        _destroy: function() {\n            remove(this._pane);\n            delete this._pane;\n        },\n        _resetState: function() {\n            this._resetStateTimeout = 0;\n            this._moved = false;\n        },\n        _clearDeferredResetState: function() {\n            if (this._resetStateTimeout !== 0) {\n                clearTimeout(this._resetStateTimeout);\n                this._resetStateTimeout = 0;\n            }\n        },\n        _onMouseDown: function(e) {\n            if (!e.shiftKey || e.which !== 1 && e.button !== 1) {\n                return false;\n            }\n            // Clear the deferred resetState if it hasn't executed yet, otherwise it\n            // will interrupt the interaction and orphan a box element in the container.\n            this._clearDeferredResetState();\n            this._resetState();\n            disableTextSelection();\n            disableImageDrag();\n            this._startPoint = this._map.mouseEventToContainerPoint(e);\n            on(document, {\n                contextmenu: stop,\n                mousemove: this._onMouseMove,\n                mouseup: this._onMouseUp,\n                keydown: this._onKeyDown\n            }, this);\n        },\n        _onMouseMove: function(e) {\n            if (!this._moved) {\n                this._moved = true;\n                this._box = create$1(\"div\", \"leaflet-zoom-box\", this._container);\n                addClass(this._container, \"leaflet-crosshair\");\n                this._map.fire(\"boxzoomstart\");\n            }\n            this._point = this._map.mouseEventToContainerPoint(e);\n            var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();\n            setPosition(this._box, bounds.min);\n            this._box.style.width = size.x + \"px\";\n            this._box.style.height = size.y + \"px\";\n        },\n        _finish: function() {\n            if (this._moved) {\n                remove(this._box);\n                removeClass(this._container, \"leaflet-crosshair\");\n            }\n            enableTextSelection();\n            enableImageDrag();\n            off(document, {\n                contextmenu: stop,\n                mousemove: this._onMouseMove,\n                mouseup: this._onMouseUp,\n                keydown: this._onKeyDown\n            }, this);\n        },\n        _onMouseUp: function(e) {\n            if (e.which !== 1 && e.button !== 1) {\n                return;\n            }\n            this._finish();\n            if (!this._moved) {\n                return;\n            }\n            // Postpone to next JS tick so internal click event handling\n            // still see it as \"moved\".\n            this._clearDeferredResetState();\n            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n            var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n            this._map.fitBounds(bounds).fire(\"boxzoomend\", {\n                boxZoomBounds: bounds\n            });\n        },\n        _onKeyDown: function(e) {\n            if (e.keyCode === 27) {\n                this._finish();\n                this._clearDeferredResetState();\n                this._resetState();\n            }\n        }\n    });\n    // @section Handlers\n    // @property boxZoom: Handler\n    // Box (shift-drag with mouse) zoom handler.\n    Map.addInitHook(\"addHandler\", \"boxZoom\", BoxZoom);\n    /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */ // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @option doubleClickZoom: Boolean|String = true\n        // Whether the map can be zoomed in by double clicking on it and\n        // zoomed out by double clicking while holding shift. If passed\n        // `'center'`, double-click zoom will zoom to the center of the\n        //  view regardless of where the mouse was.\n        doubleClickZoom: true\n    });\n    var DoubleClickZoom = Handler.extend({\n        addHooks: function() {\n            this._map.on(\"dblclick\", this._onDoubleClick, this);\n        },\n        removeHooks: function() {\n            this._map.off(\"dblclick\", this._onDoubleClick, this);\n        },\n        _onDoubleClick: function(e) {\n            var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n            if (map.options.doubleClickZoom === \"center\") {\n                map.setZoom(zoom);\n            } else {\n                map.setZoomAround(e.containerPoint, zoom);\n            }\n        }\n    });\n    // @section Handlers\n    //\n    // Map properties include interaction handlers that allow you to control\n    // interaction behavior in runtime, enabling or disabling certain features such\n    // as dragging or touch zoom (see `Handler` methods). For example:\n    //\n    // ```js\n    // map.doubleClickZoom.disable();\n    // ```\n    //\n    // @property doubleClickZoom: Handler\n    // Double click zoom handler.\n    Map.addInitHook(\"addHandler\", \"doubleClickZoom\", DoubleClickZoom);\n    /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */ // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @option dragging: Boolean = true\n        // Whether the map is draggable with mouse/touch or not.\n        dragging: true,\n        // @section Panning Inertia Options\n        // @option inertia: Boolean = *\n        // If enabled, panning of the map will have an inertia effect where\n        // the map builds momentum while dragging and continues moving in\n        // the same direction for some time. Feels especially nice on touch\n        // devices. Enabled by default.\n        inertia: true,\n        // @option inertiaDeceleration: Number = 3000\n        // The rate with which the inertial movement slows down, in pixels/second².\n        inertiaDeceleration: 3400,\n        // @option inertiaMaxSpeed: Number = Infinity\n        // Max speed of the inertial movement, in pixels/second.\n        inertiaMaxSpeed: Infinity,\n        // @option easeLinearity: Number = 0.2\n        easeLinearity: 0.2,\n        // TODO refactor, move to CRS\n        // @option worldCopyJump: Boolean = false\n        // With this option enabled, the map tracks when you pan to another \"copy\"\n        // of the world and seamlessly jumps to the original one so that all overlays\n        // like markers and vector layers are still visible.\n        worldCopyJump: false,\n        // @option maxBoundsViscosity: Number = 0.0\n        // If `maxBounds` is set, this option will control how solid the bounds\n        // are when dragging the map around. The default value of `0.0` allows the\n        // user to drag outside the bounds at normal speed, higher values will\n        // slow down map dragging outside bounds, and `1.0` makes the bounds fully\n        // solid, preventing the user from dragging outside the bounds.\n        maxBoundsViscosity: 0.0\n    });\n    var Drag = Handler.extend({\n        addHooks: function() {\n            if (!this._draggable) {\n                var map = this._map;\n                this._draggable = new Draggable(map._mapPane, map._container);\n                this._draggable.on({\n                    dragstart: this._onDragStart,\n                    drag: this._onDrag,\n                    dragend: this._onDragEnd\n                }, this);\n                this._draggable.on(\"predrag\", this._onPreDragLimit, this);\n                if (map.options.worldCopyJump) {\n                    this._draggable.on(\"predrag\", this._onPreDragWrap, this);\n                    map.on(\"zoomend\", this._onZoomEnd, this);\n                    map.whenReady(this._onZoomEnd, this);\n                }\n            }\n            addClass(this._map._container, \"leaflet-grab leaflet-touch-drag\");\n            this._draggable.enable();\n            this._positions = [];\n            this._times = [];\n        },\n        removeHooks: function() {\n            removeClass(this._map._container, \"leaflet-grab\");\n            removeClass(this._map._container, \"leaflet-touch-drag\");\n            this._draggable.disable();\n        },\n        moved: function() {\n            return this._draggable && this._draggable._moved;\n        },\n        moving: function() {\n            return this._draggable && this._draggable._moving;\n        },\n        _onDragStart: function() {\n            var map = this._map;\n            map._stop();\n            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n                var bounds = toLatLngBounds(this._map.options.maxBounds);\n                this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));\n                this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n            } else {\n                this._offsetLimit = null;\n            }\n            map.fire(\"movestart\").fire(\"dragstart\");\n            if (map.options.inertia) {\n                this._positions = [];\n                this._times = [];\n            }\n        },\n        _onDrag: function(e) {\n            if (this._map.options.inertia) {\n                var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n                this._positions.push(pos);\n                this._times.push(time);\n                this._prunePositions(time);\n            }\n            this._map.fire(\"move\", e).fire(\"drag\", e);\n        },\n        _prunePositions: function(time) {\n            while(this._positions.length > 1 && time - this._times[0] > 50){\n                this._positions.shift();\n                this._times.shift();\n            }\n        },\n        _onZoomEnd: function() {\n            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([\n                0,\n                0\n            ]);\n            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n        },\n        _viscousLimit: function(value, threshold) {\n            return value - (value - threshold) * this._viscosity;\n        },\n        _onPreDragLimit: function() {\n            if (!this._viscosity || !this._offsetLimit) {\n                return;\n            }\n            var offset = this._draggable._newPos.subtract(this._draggable._startPos);\n            var limit = this._offsetLimit;\n            if (offset.x < limit.min.x) {\n                offset.x = this._viscousLimit(offset.x, limit.min.x);\n            }\n            if (offset.y < limit.min.y) {\n                offset.y = this._viscousLimit(offset.y, limit.min.y);\n            }\n            if (offset.x > limit.max.x) {\n                offset.x = this._viscousLimit(offset.x, limit.max.x);\n            }\n            if (offset.y > limit.max.y) {\n                offset.y = this._viscousLimit(offset.y, limit.max.y);\n            }\n            this._draggable._newPos = this._draggable._startPos.add(offset);\n        },\n        _onPreDragWrap: function() {\n            // TODO refactor to be able to adjust map pane position after zoom\n            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n            this._draggable._absPos = this._draggable._newPos.clone();\n            this._draggable._newPos.x = newX;\n        },\n        _onDragEnd: function(e) {\n            var map = this._map, options = map.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;\n            map.fire(\"dragend\", e);\n            if (noInertia) {\n                map.fire(\"moveend\");\n            } else {\n                this._prunePositions(+new Date());\n                var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1000, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([\n                    0,\n                    0\n                ]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n                if (!offset.x && !offset.y) {\n                    map.fire(\"moveend\");\n                } else {\n                    offset = map._limitOffset(offset, map.options.maxBounds);\n                    requestAnimFrame(function() {\n                        map.panBy(offset, {\n                            duration: decelerationDuration,\n                            easeLinearity: ease,\n                            noMoveStart: true,\n                            animate: true\n                        });\n                    });\n                }\n            }\n        }\n    });\n    // @section Handlers\n    // @property dragging: Handler\n    // Map dragging handler (by both mouse and touch).\n    Map.addInitHook(\"addHandler\", \"dragging\", Drag);\n    /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */ // @namespace Map\n    // @section Keyboard Navigation Options\n    Map.mergeOptions({\n        // @option keyboard: Boolean = true\n        // Makes the map focusable and allows users to navigate the map with keyboard\n        // arrows and `+`/`-` keys.\n        keyboard: true,\n        // @option keyboardPanDelta: Number = 80\n        // Amount of pixels to pan when pressing an arrow key.\n        keyboardPanDelta: 80\n    });\n    var Keyboard = Handler.extend({\n        keyCodes: {\n            left: [\n                37\n            ],\n            right: [\n                39\n            ],\n            down: [\n                40\n            ],\n            up: [\n                38\n            ],\n            zoomIn: [\n                187,\n                107,\n                61,\n                171\n            ],\n            zoomOut: [\n                189,\n                109,\n                54,\n                173\n            ]\n        },\n        initialize: function(map) {\n            this._map = map;\n            this._setPanDelta(map.options.keyboardPanDelta);\n            this._setZoomDelta(map.options.zoomDelta);\n        },\n        addHooks: function() {\n            var container = this._map._container;\n            // make the container focusable by tabbing\n            if (container.tabIndex <= 0) {\n                container.tabIndex = \"0\";\n            }\n            on(container, {\n                focus: this._onFocus,\n                blur: this._onBlur,\n                mousedown: this._onMouseDown\n            }, this);\n            this._map.on({\n                focus: this._addHooks,\n                blur: this._removeHooks\n            }, this);\n        },\n        removeHooks: function() {\n            this._removeHooks();\n            off(this._map._container, {\n                focus: this._onFocus,\n                blur: this._onBlur,\n                mousedown: this._onMouseDown\n            }, this);\n            this._map.off({\n                focus: this._addHooks,\n                blur: this._removeHooks\n            }, this);\n        },\n        _onMouseDown: function() {\n            if (this._focused) {\n                return;\n            }\n            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;\n            this._map._container.focus();\n            window.scrollTo(left, top);\n        },\n        _onFocus: function() {\n            this._focused = true;\n            this._map.fire(\"focus\");\n        },\n        _onBlur: function() {\n            this._focused = false;\n            this._map.fire(\"blur\");\n        },\n        _setPanDelta: function(panDelta) {\n            var keys = this._panKeys = {}, codes = this.keyCodes, i, len;\n            for(i = 0, len = codes.left.length; i < len; i++){\n                keys[codes.left[i]] = [\n                    -1 * panDelta,\n                    0\n                ];\n            }\n            for(i = 0, len = codes.right.length; i < len; i++){\n                keys[codes.right[i]] = [\n                    panDelta,\n                    0\n                ];\n            }\n            for(i = 0, len = codes.down.length; i < len; i++){\n                keys[codes.down[i]] = [\n                    0,\n                    panDelta\n                ];\n            }\n            for(i = 0, len = codes.up.length; i < len; i++){\n                keys[codes.up[i]] = [\n                    0,\n                    -1 * panDelta\n                ];\n            }\n        },\n        _setZoomDelta: function(zoomDelta) {\n            var keys = this._zoomKeys = {}, codes = this.keyCodes, i, len;\n            for(i = 0, len = codes.zoomIn.length; i < len; i++){\n                keys[codes.zoomIn[i]] = zoomDelta;\n            }\n            for(i = 0, len = codes.zoomOut.length; i < len; i++){\n                keys[codes.zoomOut[i]] = -zoomDelta;\n            }\n        },\n        _addHooks: function() {\n            on(document, \"keydown\", this._onKeyDown, this);\n        },\n        _removeHooks: function() {\n            off(document, \"keydown\", this._onKeyDown, this);\n        },\n        _onKeyDown: function(e) {\n            if (e.altKey || e.ctrlKey || e.metaKey) {\n                return;\n            }\n            var key = e.keyCode, map = this._map, offset;\n            if (key in this._panKeys) {\n                if (!map._panAnim || !map._panAnim._inProgress) {\n                    offset = this._panKeys[key];\n                    if (e.shiftKey) {\n                        offset = toPoint(offset).multiplyBy(3);\n                    }\n                    if (map.options.maxBounds) {\n                        offset = map._limitOffset(toPoint(offset), map.options.maxBounds);\n                    }\n                    if (map.options.worldCopyJump) {\n                        var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));\n                        map.panTo(newLatLng);\n                    } else {\n                        map.panBy(offset);\n                    }\n                }\n            } else if (key in this._zoomKeys) {\n                map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n            } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n                map.closePopup();\n            } else {\n                return;\n            }\n            stop(e);\n        }\n    });\n    // @section Handlers\n    // @section Handlers\n    // @property keyboard: Handler\n    // Keyboard navigation handler.\n    Map.addInitHook(\"addHandler\", \"keyboard\", Keyboard);\n    /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */ // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @section Mouse wheel options\n        // @option scrollWheelZoom: Boolean|String = true\n        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n        // it will zoom to the center of the view regardless of where the mouse was.\n        scrollWheelZoom: true,\n        // @option wheelDebounceTime: Number = 40\n        // Limits the rate at which a wheel can fire (in milliseconds). By default\n        // user can't zoom via wheel more often than once per 40 ms.\n        wheelDebounceTime: 40,\n        // @option wheelPxPerZoomLevel: Number = 60\n        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n        // mean a change of one full zoom level. Smaller values will make wheel-zooming\n        // faster (and vice versa).\n        wheelPxPerZoomLevel: 60\n    });\n    var ScrollWheelZoom = Handler.extend({\n        addHooks: function() {\n            on(this._map._container, \"wheel\", this._onWheelScroll, this);\n            this._delta = 0;\n        },\n        removeHooks: function() {\n            off(this._map._container, \"wheel\", this._onWheelScroll, this);\n        },\n        _onWheelScroll: function(e) {\n            var delta = getWheelDelta(e);\n            var debounce = this._map.options.wheelDebounceTime;\n            this._delta += delta;\n            this._lastMousePos = this._map.mouseEventToContainerPoint(e);\n            if (!this._startTime) {\n                this._startTime = +new Date();\n            }\n            var left = Math.max(debounce - (+new Date() - this._startTime), 0);\n            clearTimeout(this._timer);\n            this._timer = setTimeout(bind(this._performZoom, this), left);\n            stop(e);\n        },\n        _performZoom: function() {\n            var map = this._map, zoom = map.getZoom(), snap = this._map.options.zoomSnap || 0;\n            map._stop(); // stop panning and fly animations if any\n            // map the delta with a sigmoid function to -4..4 range leaning on -1..1\n            var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n            this._delta = 0;\n            this._startTime = null;\n            if (!delta) {\n                return;\n            }\n            if (map.options.scrollWheelZoom === \"center\") {\n                map.setZoom(zoom + delta);\n            } else {\n                map.setZoomAround(this._lastMousePos, zoom + delta);\n            }\n        }\n    });\n    // @section Handlers\n    // @property scrollWheelZoom: Handler\n    // Scroll wheel zoom handler.\n    Map.addInitHook(\"addHandler\", \"scrollWheelZoom\", ScrollWheelZoom);\n    /*\n   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,\n   * which otherwise is not fired by mobile Safari.\n   */ var tapHoldDelay = 600;\n    // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @section Touch interaction options\n        // @option tapHold: Boolean\n        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.\n        tapHold: Browser.touchNative && Browser.safari && Browser.mobile,\n        // @option tapTolerance: Number = 15\n        // The max number of pixels a user can shift his finger during touch\n        // for it to be considered a valid tap.\n        tapTolerance: 15\n    });\n    var TapHold = Handler.extend({\n        addHooks: function() {\n            on(this._map._container, \"touchstart\", this._onDown, this);\n        },\n        removeHooks: function() {\n            off(this._map._container, \"touchstart\", this._onDown, this);\n        },\n        _onDown: function(e) {\n            clearTimeout(this._holdTimeout);\n            if (e.touches.length !== 1) {\n                return;\n            }\n            var first = e.touches[0];\n            this._startPos = this._newPos = new Point(first.clientX, first.clientY);\n            this._holdTimeout = setTimeout(bind(function() {\n                this._cancel();\n                if (!this._isTapValid()) {\n                    return;\n                }\n                // prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events\n                on(document, \"touchend\", preventDefault);\n                on(document, \"touchend touchcancel\", this._cancelClickPrevent);\n                this._simulateEvent(\"contextmenu\", first);\n            }, this), tapHoldDelay);\n            on(document, \"touchend touchcancel contextmenu\", this._cancel, this);\n            on(document, \"touchmove\", this._onMove, this);\n        },\n        _cancelClickPrevent: function cancelClickPrevent() {\n            off(document, \"touchend\", preventDefault);\n            off(document, \"touchend touchcancel\", cancelClickPrevent);\n        },\n        _cancel: function() {\n            clearTimeout(this._holdTimeout);\n            off(document, \"touchend touchcancel contextmenu\", this._cancel, this);\n            off(document, \"touchmove\", this._onMove, this);\n        },\n        _onMove: function(e) {\n            var first = e.touches[0];\n            this._newPos = new Point(first.clientX, first.clientY);\n        },\n        _isTapValid: function() {\n            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n        },\n        _simulateEvent: function(type, e) {\n            var simulatedEvent = new MouseEvent(type, {\n                bubbles: true,\n                cancelable: true,\n                view: window,\n                // detail: 1,\n                screenX: e.screenX,\n                screenY: e.screenY,\n                clientX: e.clientX,\n                clientY: e.clientY\n            });\n            simulatedEvent._simulated = true;\n            e.target.dispatchEvent(simulatedEvent);\n        }\n    });\n    // @section Handlers\n    // @property tapHold: Handler\n    // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).\n    Map.addInitHook(\"addHandler\", \"tapHold\", TapHold);\n    /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */ // @namespace Map\n    // @section Interaction Options\n    Map.mergeOptions({\n        // @section Touch interaction options\n        // @option touchZoom: Boolean|String = *\n        // Whether the map can be zoomed by touch-dragging with two fingers. If\n        // passed `'center'`, it will zoom to the center of the view regardless of\n        // where the touch events (fingers) were. Enabled for touch-capable web\n        // browsers.\n        touchZoom: Browser.touch,\n        // @option bounceAtZoomLimits: Boolean = true\n        // Set it to false if you don't want the map to zoom beyond min/max zoom\n        // and then bounce back when pinch-zooming.\n        bounceAtZoomLimits: true\n    });\n    var TouchZoom = Handler.extend({\n        addHooks: function() {\n            addClass(this._map._container, \"leaflet-touch-zoom\");\n            on(this._map._container, \"touchstart\", this._onTouchStart, this);\n        },\n        removeHooks: function() {\n            removeClass(this._map._container, \"leaflet-touch-zoom\");\n            off(this._map._container, \"touchstart\", this._onTouchStart, this);\n        },\n        _onTouchStart: function(e) {\n            var map = this._map;\n            if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {\n                return;\n            }\n            var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);\n            this._centerPoint = map.getSize()._divideBy(2);\n            this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n            if (map.options.touchZoom !== \"center\") {\n                this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n            }\n            this._startDist = p1.distanceTo(p2);\n            this._startZoom = map.getZoom();\n            this._moved = false;\n            this._zooming = true;\n            map._stop();\n            on(document, \"touchmove\", this._onTouchMove, this);\n            on(document, \"touchend touchcancel\", this._onTouchEnd, this);\n            preventDefault(e);\n        },\n        _onTouchMove: function(e) {\n            if (!e.touches || e.touches.length !== 2 || !this._zooming) {\n                return;\n            }\n            var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale = p1.distanceTo(p2) / this._startDist;\n            this._zoom = map.getScaleZoom(scale, this._startZoom);\n            if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {\n                this._zoom = map._limitZoom(this._zoom);\n            }\n            if (map.options.touchZoom === \"center\") {\n                this._center = this._startLatLng;\n                if (scale === 1) {\n                    return;\n                }\n            } else {\n                // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n                var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n                if (scale === 1 && delta.x === 0 && delta.y === 0) {\n                    return;\n                }\n                this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n            }\n            if (!this._moved) {\n                map._moveStart(true, false);\n                this._moved = true;\n            }\n            cancelAnimFrame(this._animRequest);\n            var moveFn = bind(map._move, map, this._center, this._zoom, {\n                pinch: true,\n                round: false\n            }, undefined);\n            this._animRequest = requestAnimFrame(moveFn, this, true);\n            preventDefault(e);\n        },\n        _onTouchEnd: function() {\n            if (!this._moved || !this._zooming) {\n                this._zooming = false;\n                return;\n            }\n            this._zooming = false;\n            cancelAnimFrame(this._animRequest);\n            off(document, \"touchmove\", this._onTouchMove, this);\n            off(document, \"touchend touchcancel\", this._onTouchEnd, this);\n            // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n            if (this._map.options.zoomAnimation) {\n                this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n            } else {\n                this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n            }\n        }\n    });\n    // @section Handlers\n    // @property touchZoom: Handler\n    // Touch zoom handler.\n    Map.addInitHook(\"addHandler\", \"touchZoom\", TouchZoom);\n    Map.BoxZoom = BoxZoom;\n    Map.DoubleClickZoom = DoubleClickZoom;\n    Map.Drag = Drag;\n    Map.Keyboard = Keyboard;\n    Map.ScrollWheelZoom = ScrollWheelZoom;\n    Map.TapHold = TapHold;\n    Map.TouchZoom = TouchZoom;\n    exports1.Bounds = Bounds;\n    exports1.Browser = Browser;\n    exports1.CRS = CRS;\n    exports1.Canvas = Canvas;\n    exports1.Circle = Circle;\n    exports1.CircleMarker = CircleMarker;\n    exports1.Class = Class;\n    exports1.Control = Control;\n    exports1.DivIcon = DivIcon;\n    exports1.DivOverlay = DivOverlay;\n    exports1.DomEvent = DomEvent;\n    exports1.DomUtil = DomUtil;\n    exports1.Draggable = Draggable;\n    exports1.Evented = Evented;\n    exports1.FeatureGroup = FeatureGroup;\n    exports1.GeoJSON = GeoJSON;\n    exports1.GridLayer = GridLayer;\n    exports1.Handler = Handler;\n    exports1.Icon = Icon;\n    exports1.ImageOverlay = ImageOverlay;\n    exports1.LatLng = LatLng;\n    exports1.LatLngBounds = LatLngBounds;\n    exports1.Layer = Layer;\n    exports1.LayerGroup = LayerGroup;\n    exports1.LineUtil = LineUtil;\n    exports1.Map = Map;\n    exports1.Marker = Marker;\n    exports1.Mixin = Mixin;\n    exports1.Path = Path;\n    exports1.Point = Point;\n    exports1.PolyUtil = PolyUtil;\n    exports1.Polygon = Polygon;\n    exports1.Polyline = Polyline;\n    exports1.Popup = Popup;\n    exports1.PosAnimation = PosAnimation;\n    exports1.Projection = index;\n    exports1.Rectangle = Rectangle;\n    exports1.Renderer = Renderer;\n    exports1.SVG = SVG;\n    exports1.SVGOverlay = SVGOverlay;\n    exports1.TileLayer = TileLayer;\n    exports1.Tooltip = Tooltip;\n    exports1.Transformation = Transformation;\n    exports1.Util = Util;\n    exports1.VideoOverlay = VideoOverlay;\n    exports1.bind = bind;\n    exports1.bounds = toBounds;\n    exports1.canvas = canvas;\n    exports1.circle = circle;\n    exports1.circleMarker = circleMarker;\n    exports1.control = control;\n    exports1.divIcon = divIcon;\n    exports1.extend = extend;\n    exports1.featureGroup = featureGroup;\n    exports1.geoJSON = geoJSON;\n    exports1.geoJson = geoJson;\n    exports1.gridLayer = gridLayer;\n    exports1.icon = icon;\n    exports1.imageOverlay = imageOverlay;\n    exports1.latLng = toLatLng;\n    exports1.latLngBounds = toLatLngBounds;\n    exports1.layerGroup = layerGroup;\n    exports1.map = createMap;\n    exports1.marker = marker;\n    exports1.point = toPoint;\n    exports1.polygon = polygon;\n    exports1.polyline = polyline;\n    exports1.popup = popup;\n    exports1.rectangle = rectangle;\n    exports1.setOptions = setOptions;\n    exports1.stamp = stamp;\n    exports1.svg = svg;\n    exports1.svgOverlay = svgOverlay;\n    exports1.tileLayer = tileLayer;\n    exports1.tooltip = tooltip;\n    exports1.transformation = toTransformation;\n    exports1.version = version;\n    exports1.videoOverlay = videoOverlay;\n    var oldL = window.L;\n    exports1.noConflict = function() {\n        window.L = oldL;\n        return this;\n    };\n    // Always export us to window global (see #2364)\n    window.L = exports1;\n}); //# sourceMappingURL=leaflet-src.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQyxHQUVBLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUN4QixLQUFpRCxHQUFjQSxRQUFRQyxXQUN2RSxDQUN1RztBQUN6RyxHQUFHLElBQUksRUFBRyxTQUFVQSxRQUFPO0lBQUk7SUFFN0IsSUFBSU8sVUFBVTtJQUVkOzs7O0dBSUMsR0FFRCx1REFBdUQ7SUFDdkQseUlBQXlJO0lBQ3pJLFNBQVNDLE9BQU9DLElBQUk7UUFDbkIsSUFBSUMsR0FBR0MsR0FBR0MsS0FBS0M7UUFFZixJQUFLRixJQUFJLEdBQUdDLE1BQU1FLFVBQVVDLE1BQU0sRUFBRUosSUFBSUMsS0FBS0QsSUFBSztZQUNqREUsTUFBTUMsU0FBUyxDQUFDSCxFQUFFO1lBQ2xCLElBQUtELEtBQUtHLElBQUs7Z0JBQ2RKLElBQUksQ0FBQ0MsRUFBRSxHQUFHRyxHQUFHLENBQUNILEVBQUU7WUFDakI7UUFDRDtRQUNBLE9BQU9EO0lBQ1I7SUFFQSwrREFBK0Q7SUFDL0QsdUlBQXVJO0lBQ3ZJLElBQUlPLFdBQVdDLE9BQU9DLE1BQU0sSUFBSTtRQUMvQixTQUFTQyxLQUFLO1FBQ2QsT0FBTyxTQUFVQyxLQUFLO1lBQ3JCRCxFQUFFRSxTQUFTLEdBQUdEO1lBQ2QsT0FBTyxJQUFJRDtRQUNaO0lBQ0Q7SUFFQSw0Q0FBNEM7SUFDNUMsa0xBQWtMO0lBQ2xMLDZCQUE2QjtJQUM3QixTQUFTRyxLQUFLQyxFQUFFLEVBQUVDLEdBQUc7UUFDcEIsSUFBSUMsUUFBUUMsTUFBTUwsU0FBUyxDQUFDSSxLQUFLO1FBRWpDLElBQUlGLEdBQUdELElBQUksRUFBRTtZQUNaLE9BQU9DLEdBQUdELElBQUksQ0FBQ0ssS0FBSyxDQUFDSixJQUFJRSxNQUFNRyxJQUFJLENBQUNkLFdBQVc7UUFDaEQ7UUFFQSxJQUFJZSxPQUFPSixNQUFNRyxJQUFJLENBQUNkLFdBQVc7UUFFakMsT0FBTztZ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b0MsU0FBUThLLEtBQUssR0FBR0U7SUFDaEJoTCxTQUFRa3lDLE9BQU8sR0FBR0E7SUFDbEJseUMsU0FBUTh4QyxRQUFRLEdBQUdBO0lBQ25COXhDLFNBQVErNEMsS0FBSyxHQUFHQTtJQUNoQi80QyxTQUFRaXFELFNBQVMsR0FBR0E7SUFDcEJqcUQsU0FBUTZELFVBQVUsR0FBR0E7SUFDckI3RCxTQUFRZ0MsS0FBSyxHQUFHQTtJQUNoQmhDLFNBQVFxVSxHQUFHLEdBQUdBO0lBQ2RyVSxTQUFRNDJDLFVBQVUsR0FBR0E7SUFDckI1MkMsU0FBUW1rRCxTQUFTLEdBQUdBO0lBQ3BCbmtELFNBQVFpN0MsT0FBTyxHQUFHQTtJQUNsQmo3QyxTQUFRK1EsY0FBYyxHQUFHeUM7SUFDekJ4VCxTQUFRTyxPQUFPLEdBQUdBO0lBQ2xCUCxTQUFReTJDLFlBQVksR0FBR0E7SUFFdkIsSUFBSW1iLE9BQU90c0QsT0FBT2tDLENBQUM7SUFDbkJ4SCxTQUFRNnhELFVBQVUsR0FBRztRQUNwQnZzRCxPQUFPa0MsQ0FBQyxHQUFHb3FEO1FBQ1gsT0FBTyxJQUFJO0lBQ1o7SUFDQSxnREFBZ0Q7SUFDaER0c0QsT0FBT2tDLENBQUMsR0FBR3hIO0FBRWIsSUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3Jwb3JhdGUtdHJhdmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5qcz9hZjZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIEBwcmVzZXJ2ZVxuICogTGVhZmxldCAxLjkuNCwgYSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzLiBodHRwczovL2xlYWZsZXRqcy5jb21cbiAqIChjKSAyMDEwLTIwMjMgVmxhZGltaXIgQWdhZm9ua2luLCAoYykgMjAxMC0yMDExIENsb3VkTWFkZVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwubGVhZmxldCA9IHt9KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB2ZXJzaW9uID0gXCIxLjkuNFwiO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBVdGlsXHJcbiAgICpcclxuICAgKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKi9cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGV4dGVuZChkZXN0OiBPYmplY3QsIHNyYz86IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gZXh0ZW5kKGRlc3QpIHtcclxuICBcdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcbiAgXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuICBcdFx0c3JjID0gYXJndW1lbnRzW2pdO1xyXG4gIFx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcbiAgXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGRlc3Q7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuICB2YXIgY3JlYXRlJDIgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgXHRmdW5jdGlvbiBGKCkge31cclxuICBcdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcclxuICBcdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuICBcdFx0cmV0dXJuIG5ldyBGKCk7XHJcbiAgXHR9O1xyXG4gIH0pKCk7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBiaW5kKGZuOiBGdW5jdGlvbiwg4oCmKTogRnVuY3Rpb25cclxuICAvLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXHJcbiAgLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuICBmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHtcclxuICBcdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcbiAgXHRpZiAoZm4uYmluZCkge1xyXG4gIFx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHJcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG4gIFx0fTtcclxuICB9XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4gIC8vIExhc3QgdW5pcXVlIElEIHVzZWQgYnkgW2BzdGFtcCgpYF0oI3V0aWwtc3RhbXApXHJcbiAgdmFyIGxhc3RJZCA9IDA7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzdGFtcChvYmo6IE9iamVjdCk6IE51bWJlclxyXG4gIC8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiBhbiBvYmplY3QsIGFzc2lnbmluZyBpdCBvbmUgaWYgaXQgZG9lc24ndCBoYXZlIGl0LlxyXG4gIGZ1bmN0aW9uIHN0YW1wKG9iaikge1xyXG4gIFx0aWYgKCEoJ19sZWFmbGV0X2lkJyBpbiBvYmopKSB7XHJcbiAgXHRcdG9ialsnX2xlYWZsZXRfaWQnXSA9ICsrbGFzdElkO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG9iai5fbGVhZmxldF9pZDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0aHJvdHRsZShmbjogRnVuY3Rpb24sIHRpbWU6IE51bWJlciwgY29udGV4dDogT2JqZWN0KTogRnVuY3Rpb25cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgZnVuY3Rpb24gYGZuYCB3aXRoIHRoZSBnaXZlbiBzY29wZSBgY29udGV4dGBcclxuICAvLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuICAvLyBgZm5gIHdpbGwgYmUgY2FsbGVkIG5vIG1vcmUgdGhhbiBvbmUgdGltZSBwZXIgZ2l2ZW4gYW1vdW50IG9mIGB0aW1lYC4gVGhlIGFyZ3VtZW50c1xyXG4gIC8vIHJlY2VpdmVkIGJ5IHRoZSBib3VuZCBmdW5jdGlvbiB3aWxsIGJlIGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gYmluZGluZyB0aGVcclxuICAvLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbiAgLy8gSGFzIGFuIGBMLnRocm90dGxlYCBzaG9ydGN1dC5cclxuICBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG4gIFx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XHJcblxyXG4gIFx0bGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcbiAgXHRcdGxvY2sgPSBmYWxzZTtcclxuICBcdFx0aWYgKGFyZ3MpIHtcclxuICBcdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgXHRcdFx0YXJncyA9IGZhbHNlO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG5cclxuICBcdHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKGxvY2spIHtcclxuICBcdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuICBcdFx0XHRhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcbiAgXHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuICBcdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuICBcdFx0XHRsb2NrID0gdHJ1ZTtcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuXHJcbiAgXHRyZXR1cm4gd3JhcHBlckZuO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHdyYXBOdW0obnVtOiBOdW1iZXIsIHJhbmdlOiBOdW1iZXJbXSwgaW5jbHVkZU1heD86IEJvb2xlYW4pOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4gIC8vIGByYW5nZVswXWAgYW5kIGByYW5nZVsxXWAuIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGFsd2F5cyBzbWFsbGVyIHRoYW5cclxuICAvLyBgcmFuZ2VbMV1gIHVubGVzcyBgaW5jbHVkZU1heGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuICBmdW5jdGlvbiB3cmFwTnVtKHgsIHJhbmdlLCBpbmNsdWRlTWF4KSB7XHJcbiAgXHR2YXIgbWF4ID0gcmFuZ2VbMV0sXHJcbiAgXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcbiAgXHQgICAgZCA9IG1heCAtIG1pbjtcclxuICBcdHJldHVybiB4ID09PSBtYXggJiYgaW5jbHVkZU1heCA/IHggOiAoKHggLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBmYWxzZUZuKCk6IEZ1bmN0aW9uXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXHJcbiAgZnVuY3Rpb24gZmFsc2VGbigpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBmb3JtYXROdW0obnVtOiBOdW1iZXIsIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE51bWJlclxyXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHdpdGggc3BlY2lmaWVkIGBwcmVjaXNpb25gLlxyXG4gIC8vIFRoZSBkZWZhdWx0IGBwcmVjaXNpb25gIHZhbHVlIGlzIDYgZGVjaW1hbCBwbGFjZXMuXHJcbiAgLy8gYGZhbHNlYCBjYW4gYmUgcGFzc2VkIHRvIHNraXAgYW55IHByb2Nlc3NpbmcgKGNhbiBiZSB1c2VmdWwgdG8gYXZvaWQgcm91bmQtb2ZmIGVycm9ycykuXHJcbiAgZnVuY3Rpb24gZm9ybWF0TnVtKG51bSwgcHJlY2lzaW9uKSB7XHJcbiAgXHRpZiAocHJlY2lzaW9uID09PSBmYWxzZSkgeyByZXR1cm4gbnVtOyB9XHJcbiAgXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNiA6IHByZWNpc2lvbik7XHJcbiAgXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuICBmdW5jdGlvbiB0cmltKHN0cikge1xyXG4gIFx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbiAgLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG4gIGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcbiAgXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcbiAgXHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdvcHRpb25zJykpIHtcclxuICBcdFx0b2JqLm9wdGlvbnMgPSBvYmoub3B0aW9ucyA/IGNyZWF0ZSQyKG9iai5vcHRpb25zKSA6IHt9O1xyXG4gIFx0fVxyXG4gIFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcbiAgXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuICBcdH1cclxuICBcdHJldHVybiBvYmoub3B0aW9ucztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmo6IE9iamVjdCwgZXhpc3RpbmdVcmw/OiBTdHJpbmcsIHVwcGVyY2FzZT86IEJvb2xlYW4pOiBTdHJpbmdcclxuICAvLyBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHBhcmFtZXRlciBVUkwgc3RyaW5nLCBlLmcuIGB7YTogXCJmb29cIiwgYjogXCJiYXJcIn1gXHJcbiAgLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4gIC8vIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQuIElmIGB1cHBlcmNhc2VgIGlzIGB0cnVlYCwgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsXHJcbiAgLy8gYmUgdXBwZXJjYXNlZCAoZS5nLiBgJz9BPWZvbyZCPWJhcidgKVxyXG4gIGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG4gIFx0dmFyIHBhcmFtcyA9IFtdO1xyXG4gIFx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuICBcdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbiAgfVxyXG5cclxuICB2YXIgdGVtcGxhdGVSZSA9IC9cXHsgKihbXFx3XyAtXSspICpcXH0vZztcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuICAvLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuICAvLyBhbmQgYSBkYXRhIG9iamVjdCBsaWtlIGB7YTogJ2ZvbycsIGI6ICdiYXInfWAsIHJldHVybnMgZXZhbHVhdGVkIHN0cmluZ1xyXG4gIC8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4gIC8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG4gIGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG4gIFx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XHJcblxyXG4gIFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB2YWx1ZTtcclxuICBcdH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGlzQXJyYXkob2JqKTogQm9vbGVhblxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxuICB9O1xyXG5cclxuICAvLyBAZnVuY3Rpb24gaW5kZXhPZihhcnJheTogQXJyYXksIGVsOiBPYmplY3QpOiBOdW1iZXJcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbiAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWwpIHtcclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgLy8gQHByb3BlcnR5IGVtcHR5SW1hZ2VVcmw6IFN0cmluZ1xyXG4gIC8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4gIC8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG4gIC8vIG1vYmlsZSBkZXZpY2VzIChieSBzZXR0aW5nIGltYWdlIGBzcmNgIHRvIHRoaXMgc3RyaW5nKS5cclxuICB2YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcclxuXHJcbiAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG4gIGZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuICBcdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG4gIH1cclxuXHJcbiAgdmFyIGxhc3RUaW1lID0gMDtcclxuXHJcbiAgLy8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG4gIGZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG4gIFx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuICBcdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG4gIFx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuICBcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcbiAgfVxyXG5cclxuICB2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyO1xyXG4gIHZhciBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG4gIFx0XHRnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuICAvLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuICAvLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXHJcbiAgLy8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuICAvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcbiAgLy8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxyXG4gIC8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG4gIGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xyXG4gIFx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG4gIFx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgYmluZChmbiwgY29udGV4dCkpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcbiAgLy8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcbiAgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkKSB7XHJcbiAgXHRpZiAoaWQpIHtcclxuICBcdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuICBcdH1cclxuICB9XG5cbiAgdmFyIFV0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGNyZWF0ZTogY3JlYXRlJDIsXG4gICAgYmluZDogYmluZCxcbiAgICBnZXQgbGFzdElkICgpIHsgcmV0dXJuIGxhc3RJZDsgfSxcbiAgICBzdGFtcDogc3RhbXAsXG4gICAgdGhyb3R0bGU6IHRocm90dGxlLFxuICAgIHdyYXBOdW06IHdyYXBOdW0sXG4gICAgZmFsc2VGbjogZmFsc2VGbixcbiAgICBmb3JtYXROdW06IGZvcm1hdE51bSxcbiAgICB0cmltOiB0cmltLFxuICAgIHNwbGl0V29yZHM6IHNwbGl0V29yZHMsXG4gICAgc2V0T3B0aW9uczogc2V0T3B0aW9ucyxcbiAgICBnZXRQYXJhbVN0cmluZzogZ2V0UGFyYW1TdHJpbmcsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICBlbXB0eUltYWdlVXJsOiBlbXB0eUltYWdlVXJsLFxuICAgIHJlcXVlc3RGbjogcmVxdWVzdEZuLFxuICAgIGNhbmNlbEZuOiBjYW5jZWxGbixcbiAgICByZXF1ZXN0QW5pbUZyYW1lOiByZXF1ZXN0QW5pbUZyYW1lLFxuICAgIGNhbmNlbEFuaW1GcmFtZTogY2FuY2VsQW5pbUZyYW1lXG4gIH07XG5cbiAgLy8gQGNsYXNzIENsYXNzXHJcbiAgLy8gQGFrYSBMLkNsYXNzXHJcblxyXG4gIC8vIEBzZWN0aW9uXHJcbiAgLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbiAgLy8gVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcblxyXG4gIGZ1bmN0aW9uIENsYXNzKCkge31cclxuXHJcbiAgQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG4gIFx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuICBcdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG4gIFx0Ly8gUmV0dXJucyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gdGhhdCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yICh0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCkuXHJcbiAgXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMpO1xyXG5cclxuICBcdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuICBcdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG4gIFx0XHRcdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG4gIFx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuICBcdH07XHJcblxyXG4gIFx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG4gIFx0dmFyIHByb3RvID0gY3JlYXRlJDIocGFyZW50UHJvdG8pO1xyXG4gIFx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcbiAgXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcbiAgXHQvLyBpbmhlcml0IHBhcmVudCdzIHN0YXRpY3NcclxuICBcdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG4gIFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpICYmIGkgIT09ICdwcm90b3R5cGUnICYmIGkgIT09ICdfX3N1cGVyX18nKSB7XHJcbiAgXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcbiAgXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG4gIFx0XHRleHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIG1peCBpbmNsdWRlcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuICBcdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG4gIFx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcbiAgXHRcdGV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG4gIFx0ZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcbiAgXHRkZWxldGUgcHJvdG8uc3RhdGljcztcclxuICBcdGRlbGV0ZSBwcm90by5pbmNsdWRlcztcclxuXHJcbiAgXHQvLyBtZXJnZSBvcHRpb25zXHJcbiAgXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG4gIFx0XHRwcm90by5vcHRpb25zID0gcGFyZW50UHJvdG8ub3B0aW9ucyA/IGNyZWF0ZSQyKHBhcmVudFByb3RvLm9wdGlvbnMpIDoge307XHJcbiAgXHRcdGV4dGVuZChwcm90by5vcHRpb25zLCBwcm9wcy5vcHRpb25zKTtcclxuICBcdH1cclxuXHJcbiAgXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG4gIFx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuICBcdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuICBcdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuXHJcbiAgXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuICAvLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG4gIENsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICBcdHZhciBwYXJlbnRPcHRpb25zID0gdGhpcy5wcm90b3R5cGUub3B0aW9ucztcclxuICBcdGV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG4gIFx0aWYgKHByb3BzLm9wdGlvbnMpIHtcclxuICBcdFx0dGhpcy5wcm90b3R5cGUub3B0aW9ucyA9IHBhcmVudE9wdGlvbnM7XHJcbiAgXHRcdHRoaXMubWVyZ2VPcHRpb25zKHByb3BzLm9wdGlvbnMpO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbiAgQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdGV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBhZGRJbml0SG9vayhmbjogRnVuY3Rpb24pOiB0aGlzXHJcbiAgLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuICBDbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcbiAgXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG4gIFx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgXHR9O1xyXG5cclxuICBcdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG4gIFx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMoaW5jbHVkZXMpIHtcclxuICBcdC8qIGdsb2JhbCBMOiB0cnVlICovXHJcbiAgXHRpZiAodHlwZW9mIEwgPT09ICd1bmRlZmluZWQnIHx8ICFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuICBcdGluY2x1ZGVzID0gaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmNsdWRlcy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRpZiAoaW5jbHVkZXNbaV0gPT09IEwuTWl4aW4uRXZlbnRzKSB7XHJcbiAgXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG4gIFx0XHRcdFx0J3RoaXMgcHJvcGVydHkgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcywgJyArXHJcbiAgXHRcdFx0XHQncGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC4nLCBuZXcgRXJyb3IoKS5zdGFjayk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgRXZlbnRlZFxyXG4gICAqIEBha2EgTC5FdmVudGVkXHJcbiAgICogQGluaGVyaXRzIENsYXNzXHJcbiAgICpcclxuICAgKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gICAqIH0gKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIExlYWZsZXQgZGVhbHMgd2l0aCBldmVudCBsaXN0ZW5lcnMgYnkgcmVmZXJlbmNlLCBzbyBpZiB5b3Ugd2FudCB0byBhZGQgYSBsaXN0ZW5lciBhbmQgdGhlbiByZW1vdmUgaXQsIGRlZmluZSBpdCBhcyBhIGZ1bmN0aW9uOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBmdW5jdGlvbiBvbkNsaWNrKGUpIHsgLi4uIH1cclxuICAgKlxyXG4gICAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICAgKiBtYXAub2ZmKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgRXZlbnRzID0ge1xyXG4gIFx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdCAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgb2YgdGhlIG9iamVjdC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyIChvYmplY3QgdGhlIHRoaXMga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuICBcdCAqXHJcbiAgXHQgKiBAYWx0ZXJuYXRpdmVcclxuICBcdCAqIEBtZXRob2Qgb24oZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuICBcdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuICBcdCAqL1xyXG4gIFx0b246IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG4gIFx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuICBcdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG4gIFx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuICBcdFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuICBcdCAqXHJcbiAgXHQgKiBAYWx0ZXJuYXRpdmVcclxuICBcdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQGFsdGVybmF0aXZlXHJcbiAgXHQgKiBAbWV0aG9kIG9mZjogdGhpc1xyXG4gIFx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBpbXBsaWNpdGx5IGF0dGFjaGVkIGV2ZW50cy5cclxuICBcdCAqL1xyXG4gIFx0b2ZmOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICBcdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRcdHZhciByZW1vdmVBbGwgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0aWYgKHJlbW92ZUFsbCkge1xyXG4gIFx0XHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0pO1xyXG4gIFx0XHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcbiAgXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCwgX29uY2UpIHtcclxuICBcdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcbiAgXHRcdGlmICh0aGlzLl9saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0KSAhPT0gZmFsc2UpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG4gIFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH07XHJcbiAgXHRcdGlmIChfb25jZSkge1xyXG4gIFx0XHRcdG5ld0xpc3RlbmVyLm9uY2UgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcbiAgXHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcclxuICBcdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobmV3TGlzdGVuZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuICBcdFx0dmFyIGxpc3RlbmVycyxcclxuICBcdFx0ICAgIGksXHJcbiAgXHRcdCAgICBsZW47XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMuX2V2ZW50cykge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0bGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gIFx0XHRpZiAoIWxpc3RlbmVycykge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgLy8gcmVtb3ZlIGFsbFxyXG4gIFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG4gIFx0XHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wXHJcbiAgXHRcdFx0XHQvLyBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuICBcdFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBmYWxzZUZuO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGxpc3RlbmVyIHR5cGU6ICcgKyB0eXBlb2YgZm4pO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gZmluZCBmbiBhbmQgcmVtb3ZlIGl0XHJcbiAgXHRcdHZhciBpbmRleCA9IHRoaXMuX2xpc3RlbnModHlwZSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHRpZiAoaW5kZXggIT09IGZhbHNlKSB7XHJcbiAgXHRcdFx0dmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2luZGV4XTtcclxuICBcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuICBcdFx0XHRcdC8vIHNldCB0aGUgcmVtb3ZlZCBsaXN0ZW5lciB0byBub29wIHNvIHRoYXQncyBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuICBcdFx0XHRcdGxpc3RlbmVyLmZuID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG4gIFx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcbiAgXHQvLyBGaXJlcyBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgZGF0YVxyXG4gIFx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuICBcdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcbiAgXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdHZhciBldmVudCA9IGV4dGVuZCh7fSwgZGF0YSwge1xyXG4gIFx0XHRcdHR5cGU6IHR5cGUsXHJcbiAgXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG4gIFx0XHRcdHNvdXJjZVRhcmdldDogZGF0YSAmJiBkYXRhLnNvdXJjZVRhcmdldCB8fCB0aGlzXHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG4gIFx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG4gIFx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG4gIFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuICBcdFx0XHRcdFx0Ly8gb2ZmIG92ZXJ3cml0ZXMgbC5mbiwgc28gd2UgbmVlZCB0byBjb3B5IGZuIHRvIGEgdmFyXHJcbiAgXHRcdFx0XHRcdHZhciBmbiA9IGwuZm47XHJcbiAgXHRcdFx0XHRcdGlmIChsLm9uY2UpIHtcclxuICBcdFx0XHRcdFx0XHR0aGlzLm9mZih0eXBlLCBmbiwgbC5jdHgpO1xyXG4gIFx0XHRcdFx0XHR9XHJcbiAgXHRcdFx0XHRcdGZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xyXG4gIFx0XHRcdFx0fVxyXG5cclxuICBcdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50LS07XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAocHJvcGFnYXRlKSB7XHJcbiAgXHRcdFx0Ly8gcHJvcGFnYXRlIHRoZSBldmVudCB0byBwYXJlbnRzIChzZXQgd2l0aCBhZGRFdmVudFBhcmVudClcclxuICBcdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nLCBwcm9wYWdhdGU/OiBCb29sZWFuKTogQm9vbGVhblxyXG4gIFx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgaGFzIGFueSBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gaXQuXHJcbiAgXHQvLyBUaGUgdmVyaWZpY2F0aW9uIGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQsIGl0IHdpbGwgcmV0dXJuIGB0cnVlYCBpZiBwYXJlbnRzIGhhdmUgdGhlIGxpc3RlbmVyIGF0dGFjaGVkIHRvIGl0LlxyXG4gIFx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0LCBwcm9wYWdhdGUpIHtcclxuICBcdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2FybignXCJzdHJpbmdcIiB0eXBlIGFyZ3VtZW50IGV4cGVjdGVkJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgaW5wdXQgYGZuYCB2YWx1ZSwgYmVjYXVzZSB3ZSBuZWVkIHRvIHVzZSBpdCBmb3IgcHJvcGFnYXRpb25cclxuICBcdFx0dmFyIF9mbiA9IGZuO1xyXG4gIFx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgXHRcdFx0cHJvcGFnYXRlID0gISFmbjtcclxuICBcdFx0XHRfZm4gPSB1bmRlZmluZWQ7XHJcbiAgXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkge1xyXG4gIFx0XHRcdGlmICh0aGlzLl9saXN0ZW5zKHR5cGUsIF9mbiwgY29udGV4dCkgIT09IGZhbHNlKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuICBcdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcbiAgXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcbiAgXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0LCBwcm9wYWdhdGUpKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBmYWxzZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gcmV0dXJucyB0aGUgaW5kZXggKG51bWJlcikgb3IgZmFsc2VcclxuICBcdF9saXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9ldmVudHMpIHtcclxuICBcdFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XHJcbiAgXHRcdGlmICghZm4pIHtcclxuICBcdFx0XHRyZXR1cm4gISFsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG4gIFx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuICBcdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4gJiYgbGlzdGVuZXJzW2ldLmN0eCA9PT0gY29udGV4dCkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIGk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBmYWxzZTtcclxuXHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcbiAgXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuICBcdG9uY2U6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG4gIFx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuICBcdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG4gIFx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuLCB0cnVlKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuICBcdFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG4gIFx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG4gIFx0XHR0aGlzLl9ldmVudFBhcmVudHNbc3RhbXAob2JqKV0gPSBvYmo7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcbiAgXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tzdGFtcChvYmopXTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuICBcdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBleHRlbmQoe1xyXG4gIFx0XHRcdFx0bGF5ZXI6IGUudGFyZ2V0LFxyXG4gIFx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcbiAgXHRcdFx0fSwgZSksIHRydWUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxuXHJcbiAgLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuICBFdmVudHMuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbjtcclxuXHJcbiAgLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuICAvLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbiAgRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4gIC8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuICBFdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbiAgLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuICBFdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4gIC8vIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lcnMo4oCmKTogQm9vbGVhblxyXG4gIC8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuICBFdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbiAgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBQb2ludFxyXG4gICAqIEBha2EgTC5Qb2ludFxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gICAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYFBvaW50YCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBQb2ludCh4LCB5LCByb3VuZCkge1xyXG4gIFx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG4gIFx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG4gIFx0Ly8gQHByb3BlcnR5IHk6IE51bWJlcjsgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG4gIFx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xyXG4gIFx0cmV0dXJuIHYgPiAwID8gTWF0aC5mbG9vcih2KSA6IE1hdGguY2VpbCh2KTtcclxuICB9O1xyXG5cclxuICBQb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcbiAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG4gIFx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcbiAgXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG4gIFx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG4gIFx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG4gIFx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcbiAgXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0dGhpcy54IC89IG51bTtcclxuICBcdFx0dGhpcy55IC89IG51bTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuICBcdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHR0aGlzLnggKj0gbnVtO1xyXG4gIFx0XHR0aGlzLnkgKj0gbnVtO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcbiAgXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG4gIFx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuICBcdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuICBcdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gSW52ZXJzZSBvZiBgc2NhbGVCeWAuIERpdmlkZSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnlcclxuICBcdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG4gIFx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG4gIFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG4gIFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcbiAgXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcbiAgXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCB0cnVuY2F0ZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdG93YXJkcyB6ZXJvKS5cclxuICBcdHRydW5jOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnVuYzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG4gIFx0XHR0aGlzLnkgPSB0cnVuYyh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuICBcdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG4gIFx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG4gIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcbiAgXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG4gIFx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG4gIFx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuICBcdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICdQb2ludCgnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG4gIFx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwucG9pbnQoeDogTnVtYmVyLCB5OiBOdW1iZXIsIHJvdW5kPzogQm9vbGVhbilcclxuICAvLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE51bWJlcltdKVxyXG4gIC8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE9iamVjdClcclxuICAvLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG4gIGZ1bmN0aW9uIHRvUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuICBcdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHg7XHJcbiAgXHR9XHJcbiAgXHRpZiAoaXNBcnJheSh4KSkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG4gIFx0fVxyXG4gIFx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcbiAgXHRcdHJldHVybiB4O1xyXG4gIFx0fVxyXG4gIFx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBCb3VuZHNcclxuICAgKiBAYWthIEwuQm91bmRzXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICAgKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICAgKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcclxuICBcdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgQm91bmRzLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuICBcdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcbiAgXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuICBcdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgbWluMiwgbWF4MjtcclxuICBcdFx0aWYgKCFvYmopIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGlmIChvYmogaW5zdGFuY2VvZiBQb2ludCB8fCB0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCAneCcgaW4gb2JqKSB7XHJcbiAgXHRcdFx0bWluMiA9IG1heDIgPSB0b1BvaW50KG9iaik7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuICBcdFx0XHRtaW4yID0gb2JqLm1pbjtcclxuICBcdFx0XHRtYXgyID0gb2JqLm1heDtcclxuXHJcbiAgXHRcdFx0aWYgKCFtaW4yIHx8ICFtYXgyKSB7IHJldHVybiB0aGlzOyB9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcbiAgXHRcdC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuICBcdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuICBcdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuICBcdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuICBcdFx0XHR0aGlzLm1pbiA9IG1pbjIuY2xvbmUoKTtcclxuICBcdFx0XHR0aGlzLm1heCA9IG1heDIuY2xvbmUoKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4obWluMi54LCB0aGlzLm1pbi54KTtcclxuICBcdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgobWF4Mi54LCB0aGlzLm1heC54KTtcclxuICBcdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4obWluMi55LCB0aGlzLm1pbi55KTtcclxuICBcdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgobWF4Mi55LCB0aGlzLm1heC55KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuICBcdFx0cmV0dXJuIHRvUG9pbnQoXHJcbiAgXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcbiAgXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRUb3BSaWdodCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB0b3AtbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5taW5gXSgjYm91bmRzLW1pbikpLlxyXG4gIFx0Z2V0VG9wTGVmdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdHRvbVJpZ2h0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuICBcdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm1heDsgLy8gcmlnaHQsIGJvdHRvbVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xyXG4gIFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgXHRjb250YWluczogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgUG9pbnQpIHtcclxuICBcdFx0XHRvYmogPSB0b1BvaW50KG9iaik7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG4gIFx0XHRcdG1pbiA9IG9iai5taW47XHJcbiAgXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuICBcdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG4gIFx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcbiAgXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuICBcdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuICBcdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG4gIFx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcbiAgXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuICBcdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG4gIFx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuICBcdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG4gIFx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG4gIFx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuICBcdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuICBcdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuICBcdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG4gIFx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcbiAgXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuICBcdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuICBcdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcbiAgXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcbiAgXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG4gIFx0Ly8gRm9yIGV4YW1wbGUsIGEgcmF0aW8gb2YgMC41IGV4dGVuZHMgdGhlIGJvdW5kcyBieSA1MCUgaW4gZWFjaCBkaXJlY3Rpb24uXHJcbiAgXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcbiAgXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG4gIFx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcbiAgXHRcdG1heCA9IHRoaXMubWF4LFxyXG4gIFx0XHRoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhtaW4ueCAtIG1heC54KSAqIGJ1ZmZlclJhdGlvLFxyXG4gIFx0XHR3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKG1pbi55IC0gbWF4LnkpICogYnVmZmVyUmF0aW87XHJcblxyXG5cclxuICBcdFx0cmV0dXJuIHRvQm91bmRzKFxyXG4gIFx0XHRcdHRvUG9pbnQobWluLnggLSBoZWlnaHRCdWZmZXIsIG1pbi55IC0gd2lkdGhCdWZmZXIpLFxyXG4gIFx0XHRcdHRvUG9pbnQobWF4LnggKyBoZWlnaHRCdWZmZXIsIG1heC55ICsgd2lkdGhCdWZmZXIpKTtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIGJvdW5kcy5cclxuICBcdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5taW4uZXF1YWxzKGJvdW5kcy5nZXRUb3BMZWZ0KCkpICYmXHJcbiAgXHRcdFx0dGhpcy5tYXguZXF1YWxzKGJvdW5kcy5nZXRCb3R0b21SaWdodCgpKTtcclxuICBcdH0sXHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuYm91bmRzKGNvcm5lcjE6IFBvaW50LCBjb3JuZXIyOiBQb2ludClcclxuICAvLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5ib3VuZHMocG9pbnRzOiBQb2ludFtdKVxyXG4gIC8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuICBmdW5jdGlvbiB0b0JvdW5kcyhhLCBiKSB7XHJcbiAgXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBMYXRMbmdCb3VuZHNcclxuICAgKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgZ2VvZ3JhcGhpY2FsIGFyZWEgb24gYSBtYXAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAgICogY29ybmVyMiA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAgICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLmZpdEJvdW5kcyhbXHJcbiAgICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICAgKiBcdFs0MC43NzQsIC03NC4xMjVdXHJcbiAgICogXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYExhdExuZ0JvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcbiAgXHRpZiAoIWNvcm5lcjEpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0dmFyIGxhdGxuZ3MgPSBjb3JuZXIyID8gW2Nvcm5lcjEsIGNvcm5lcjJdIDogY29ybmVyMTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIExhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG4gIFx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcbiAgXHRcdFx0c3cyID0gb2JqO1xyXG4gIFx0XHRcdG5lMiA9IG9iajtcclxuXHJcbiAgXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcbiAgXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcbiAgXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG4gIFx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKHRvTGF0TG5nKG9iaikgfHwgdG9MYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG4gIFx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcbiAgXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IExhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG4gIFx0XHRcdHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcbiAgXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuICBcdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICBcdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG4gIFx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG4gIFx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcbiAgXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcbiAgXHRcdCAgICAgICAgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcbiAgXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcbiAgXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcbiAgXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG4gIFx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG4gIFx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTGF0TG5nIHx8ICdsYXQnIGluIG9iaikge1xyXG4gIFx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqID0gdG9MYXRMbmdCb3VuZHMob2JqKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcbiAgXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuICBcdFx0XHRzdzIgPSBvYmouZ2V0U291dGhXZXN0KCk7XHJcbiAgXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHN3MiA9IG5lMiA9IG9iajtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG4gIFx0XHQgICAgICAgKHN3Mi5sbmcgPj0gc3cubG5nKSAmJiAobmUyLmxuZyA8PSBuZS5sbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuICBcdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuICBcdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcbiAgXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuICBcdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcbiAgXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcbiAgXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG4gIFx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG4gIFx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuICBcdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuICBcdC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gYSAnc291dGh3ZXN0X2xuZyxzb3V0aHdlc3RfbGF0LG5vcnRoZWFzdF9sbmcsbm9ydGhlYXN0X2xhdCcgZm9ybWF0LiBVc2VmdWwgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gd2ViIHNlcnZpY2VzIHRoYXQgcmV0dXJuIGdlbyBkYXRhLlxyXG4gIFx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzLCBtYXhNYXJnaW4pIHtcclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpLCBtYXhNYXJnaW4pICYmXHJcbiAgXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG4gIFx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gVE9ETyBJbnRlcm5hdGlvbmFsIGRhdGUgbGluZT9cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4gIC8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuICBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcbiAgXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG4gIH1cblxuICAvKiBAY2xhc3MgTGF0TG5nXHJcbiAgICogQGFrYSBMLkxhdExuZ1xyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAgICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAgICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAgICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcbiAgXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG4gIFx0Ly8gTGF0aXR1ZGUgaW4gZGVncmVlc1xyXG4gIFx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG4gIFx0Ly8gTG9uZ2l0dWRlIGluIGRlZ3JlZXNcclxuICBcdHRoaXMubG5nID0gK2xuZztcclxuXHJcbiAgXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuICBcdC8vIEFsdGl0dWRlIGluIG1ldGVycyAob3B0aW9uYWwpXHJcbiAgXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0dGhpcy5hbHQgPSArYWx0O1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyTGF0TG5nOiBMYXRMbmcsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuICBcdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuICBcdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG4gIFx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcbiAgXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlckxhdExuZzogTGF0TG5nKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuICBcdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gIFx0XHRyZXR1cm4gRWFydGguZGlzdGFuY2UodGhpcywgdG9MYXRMbmcob3RoZXIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nYCBvYmplY3Qgd2l0aCB0aGUgbG9uZ2l0dWRlIHdyYXBwZWQgc28gaXQncyBhbHdheXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcbiAgXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG4gIFx0dG9Cb3VuZHM6IGZ1bmN0aW9uIChzaXplSW5NZXRlcnMpIHtcclxuICBcdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcbiAgXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuICBcdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuICBcdH1cclxuICB9O1xyXG5cclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIHRoZSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChhbmQgb3B0aW9uYWxseSBhbHRpdHVkZSkuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuICAvLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbTnVtYmVyLCBOdW1iZXJdYCBvciBgW051bWJlciwgTnVtYmVyLCBOdW1iZXJdYCBpbnN0ZWFkLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4gIC8vIEV4cGVjdHMgYW4gcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfWAgb3IgYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXIsIGFsdDogTnVtYmVyfWAgaW5zdGVhZC5cclxuXHJcbiAgZnVuY3Rpb24gdG9MYXRMbmcoYSwgYiwgYykge1xyXG4gIFx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRpZiAoaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuICBcdFx0aWYgKGEubGVuZ3RoID09PSAzKSB7XHJcbiAgXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XHJcbiAgXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG51bGw7XHJcbiAgXHR9XHJcbiAgXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uLCBhLmFsdCk7XHJcbiAgXHR9XHJcbiAgXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHJldHVybiBudWxsO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkJhc2VcclxuICAgKiBPYmplY3QgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICAgKiBnZW9ncmFwaGljYWwgcG9pbnRzIGludG8gcGl4ZWwgKHNjcmVlbikgY29vcmRpbmF0ZXMgYW5kIGJhY2sgKGFuZCB0b1xyXG4gICAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAgICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BhdGlhbF9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICAgKlxyXG4gICAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAgICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gICAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gICAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICB2YXIgQ1JTID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb1BvaW50KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuICBcdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKSxcclxuICBcdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcbiAgXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuICBcdC8vIHpvb20gaW50byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcbiAgXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIHVudHJhbnNmb3JtZWRQb2ludCA9IHRoaXMudHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcbiAgXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuICBcdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG4gIFx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNjYWxlKHpvb206IE51bWJlcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG4gIFx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG4gIFx0Ly8gYDI1NiAqIDJeem9vbWAgZm9yIE1lcmNhdG9yLWJhc2VkIENSUy5cclxuICBcdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuICBcdC8vIGZhY3RvciBvZiBgc2NhbGVgLlxyXG4gIFx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcbiAgXHRnZXRQcm9qZWN0ZWRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG4gIFx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcbiAgXHRcdCAgICBzID0gdGhpcy5zY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuICBcdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKG1pbiwgbWF4KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuICBcdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG4gIFx0Ly9cclxuICBcdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG4gIFx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcbiAgXHQvLyBheGlzIHdyYXBzIGFyb3VuZCBhIGdpdmVuIHJhbmdlIGFuZCBob3cuIERlZmF1bHRzIHRvIGBbLTE4MCwgMTgwXWAgaW4gbW9zdFxyXG4gIFx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcbiAgXHQvL1xyXG4gIFx0Ly8gQHByb3BlcnR5IHdyYXBMYXQ6IE51bWJlcltdXHJcbiAgXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuICBcdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcbiAgXHQvLyB3cmFwTGF0OiBbbWluLCBtYXhdLFxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG4gIFx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuICBcdGluZmluaXRlOiBmYWxzZSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuICBcdC8vIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlIENSUydzIGJvdW5kcy5cclxuICBcdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IHdyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcbiAgXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyB3cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG4gIFx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKGxhdCwgbG5nLCBhbHQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmdcclxuICBcdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuICBcdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcbiAgXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuICBcdFx0ICAgIGxhdFNoaWZ0ID0gY2VudGVyLmxhdCAtIG5ld0NlbnRlci5sYXQsXHJcbiAgXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuICBcdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGJvdW5kcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcbiAgXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuICBcdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMobmV3U3csIG5ld05lKTtcclxuICBcdH1cclxuICB9O1xuXG4gIC8qXG4gICAqIEBuYW1lc3BhY2UgQ1JTXG4gICAqIEBjcnMgTC5DUlMuRWFydGhcbiAgICpcbiAgICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAgICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAgICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gICAqIG1ldGVycy5cbiAgICovXG5cbiAgdmFyIEVhcnRoID0gZXh0ZW5kKHt9LCBDUlMsIHtcbiAgXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuICBcdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG4gIFx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcbiAgXHQvLyBzZWUgaHR0cHM6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuICBcdFI6IDYzNzEwMDAsXG5cbiAgXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG4gIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG4gIFx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcbiAgXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG4gIFx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuICBcdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcbiAgXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG4gIFx0XHQgICAgYSA9IHNpbkRMYXQgKiBzaW5ETGF0ICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIHNpbkRMb24gKiBzaW5ETG9uLFxuICBcdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuICBcdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gICAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gICAqXHJcbiAgICogU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IGNvbW1vbiBwcm9qZWN0aW9uIGZvciBvbmxpbmUgbWFwcyxcclxuICAgKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAgICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbiAgdmFyIFNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuICBcdFI6IGVhcnRoUmFkaXVzLFxyXG4gIFx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcbiAgXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuICBcdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0XHR0aGlzLlIgKiBsYXRsbmcubG5nICogZCxcclxuICBcdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcbiAgXHR9LFxyXG5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG4gIFx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuICBcdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcbiAgXHR9LFxyXG5cclxuICBcdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG4gIFx0fSkoKVxyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICAgKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAgICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gICAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAgICogXHRwID0gTC5wb2ludCgxLCAyKSxcclxuICAgKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gICAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG5cclxuICAvLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuICAvLyBDcmVhdGVzIGEgYFRyYW5zZm9ybWF0aW9uYCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuICBcdGlmIChpc0FycmF5KGEpKSB7XHJcbiAgXHRcdC8vIHVzZSBhcnJheSBwcm9wZXJ0aWVzXHJcbiAgXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG4gIFx0XHR0aGlzLl9iID0gYVsxXTtcclxuICBcdFx0dGhpcy5fYyA9IGFbMl07XHJcbiAgXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG4gIFx0XHRyZXR1cm47XHJcbiAgXHR9XHJcbiAgXHR0aGlzLl9hID0gYTtcclxuICBcdHRoaXMuX2IgPSBiO1xyXG4gIFx0dGhpcy5fYyA9IGM7XHJcbiAgXHR0aGlzLl9kID0gZDtcclxuICB9XHJcblxyXG4gIFRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG4gIFx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG4gIFx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcbiAgXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcbiAgXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuICBcdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcbiAgXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG4gIFx0XHRyZXR1cm4gcG9pbnQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCwgb3B0aW9uYWxseSBkaXZpZGVkXHJcbiAgXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuICBcdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcbiAgXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG4gIFx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbiAgLy8gRXhwZWN0cyBhbiBjb2VmZmljaWVudHMgYXJyYXkgb2YgdGhlIGZvcm1cclxuICAvLyBgW2E6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcl1gLlxyXG5cclxuICBmdW5jdGlvbiB0b1RyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuICBcdHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAgICpcclxuICAgKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICAgKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICAgKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAgICovXHJcblxyXG4gIHZhciBFUFNHMzg1NyA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuICBcdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG4gIFx0cHJvamVjdGlvbjogU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG4gIFx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcbiAgXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuICBcdH0oKSlcclxuICB9KTtcclxuXHJcbiAgdmFyIEVQU0c5MDA5MTMgPSBleHRlbmQoe30sIEVQU0czODU3LCB7XHJcbiAgXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbiAgfSk7XG5cbiAgLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4gIC8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5cbiAgLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4gIC8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuICAvLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuICAvLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG4gIGZ1bmN0aW9uIHN2Z0NyZWF0ZShuYW1lKSB7XG4gIFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbiAgfVxuXG4gIC8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuICAvLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4gIC8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbiAgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcbiAgXHR2YXIgc3RyID0gJycsXG4gIFx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cbiAgXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gIFx0XHRcdHAgPSBwb2ludHNbal07XG4gIFx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcbiAgXHRcdHN0ciArPSBjbG9zZWQgPyAoQnJvd3Nlci5zdmcgPyAneicgOiAneCcpIDogJyc7XG4gIFx0fVxuXG4gIFx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3NcbiAgXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAgICogQGFrYSBMLkJyb3dzZXJcclxuICAgKlxyXG4gICAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAgICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuICB2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuICAvLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbiAgdmFyIGllbHQ5ID0gaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG4gIHZhciBlZGdlID0gJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbiAgLy8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcbiAgdmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuICAvLyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbiAgdmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuOyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbiAgdmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4gIC8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxuICB2YXIgd2Via2l0VmVyID0gcGFyc2VJbnQoL1dlYktpdFxcLyhbMC05XSspfCQvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMV0sIDEwKTsgLy8gYWxzbyBtYXRjaGVzIEFwcGxlV2ViS2l0XHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgdGhlIEFuZHJvaWQgc3RvY2sgYnJvd3NlciAoaS5lLiBub3QgQ2hyb21lKVxyXG4gIHZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgb3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXJcclxuICB2YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGNocm9tZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQ2hyb21lIGJyb3dzZXIuXHJcbiAgdmFyIGNocm9tZSA9ICFlZGdlICYmIHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cclxuICB2YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG4gIHZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbiAgdmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcbiAgdmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlO1xyXG5cclxuICAvLyBAcHJvcGVydHkgd2luOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG4gIHZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZTNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbiAgLy8gQHByb3BlcnR5IGdlY2tvM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBhbnkzZDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b207XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG4gIHZhciBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdtb2JpbGUnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlV2Via2l0ID0gbW9iaWxlICYmIHdlYmtpdDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxyXG4gIHZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG4gIHZhciBwb2ludGVyID0gISEod2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgdG91Y2hOYXRpdmU6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4gIC8vICoqVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuKiogdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4gIC8vIGEgdG91Y2hzY3JlZW4sIGl0IG9ubHkgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIHVuZGVyc3RhbmRpbmdcclxuICAvLyB0b3VjaCBldmVudHMuXHJcbiAgdmFyIHRvdWNoTmF0aXZlID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8ICEhd2luZG93LlRvdWNoRXZlbnQ7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgZWl0aGVyIFt0b3VjaF0oI2Jyb3dzZXItdG91Y2gpIG9yIFtwb2ludGVyXSgjYnJvd3Nlci1wb2ludGVyKSBldmVudHMuXHJcbiAgLy8gTm90ZTogcG9pbnRlciBldmVudHMgd2lsbCBiZSBwcmVmZXJyZWQgKGlmIGF2YWlsYWJsZSksIGFuZCBwcm9jZXNzZWQgZm9yIGFsbCBgdG91Y2gqYCBsaXN0ZW5lcnMuXHJcbiAgdmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmICh0b3VjaE5hdGl2ZSB8fCBwb2ludGVyKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlT3BlcmEgPSBtb2JpbGUgJiYgb3BlcmE7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAgdmFyIG1vYmlsZUdlY2tvID0gbW9iaWxlICYmIGdlY2tvO1xyXG5cclxuICAvLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxuICB2YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuICAvLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHBhc3NpdmUgZXZlbnRzLlxyXG4gIHZhciBwYXNzaXZlRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICBcdHZhciBzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSBmYWxzZTtcclxuICBcdHRyeSB7XHJcbiAgXHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuICBcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnZXR0ZXItcmV0dXJuXHJcbiAgXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSk7XHJcbiAgXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIGZhbHNlRm4sIG9wdHMpO1xyXG4gIFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBmYWxzZUZuLCBvcHRzKTtcclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0Ly8gRXJyb3JzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBzaW5jZSB0aGlzIGlzIG9ubHkgYSBicm93c2VyIHN1cHBvcnQgdGVzdC5cclxuICBcdH1cclxuICBcdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGNhbnZhczogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbiAgdmFyIGNhbnZhcyQxID0gKGZ1bmN0aW9uICgpIHtcclxuICBcdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbiAgdmFyIHN2ZyQxID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG4gIHZhciBpbmxpbmVTdmcgPSAhIXN2ZyQxICYmIChmdW5jdGlvbiAoKSB7XHJcbiAgXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRkaXYuaW5uZXJIVE1MID0gJzxzdmcvPic7XHJcbiAgXHRyZXR1cm4gKGRpdi5maXJzdENoaWxkICYmIGRpdi5maXJzdENoaWxkLm5hbWVzcGFjZVVSSSkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxuICB2YXIgdm1sID0gIXN2ZyQxICYmIChmdW5jdGlvbiAoKSB7XHJcbiAgXHR0cnkge1xyXG4gIFx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuICBcdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XHJcbiAgXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcbiAgXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fVxyXG4gIH0oKSk7XHJcblxyXG5cclxuICAvLyBAcHJvcGVydHkgbWFjOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgTWFjIHBsYXRmb3JtXHJcbiAgdmFyIG1hYyA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdNYWMnKSA9PT0gMDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1hYzogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIExpbnV4IHBsYXRmb3JtXHJcbiAgdmFyIGxpbnV4ID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ0xpbnV4JykgPT09IDA7XHJcblxyXG4gIGZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG4gIFx0cmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cikgPj0gMDtcclxuICB9XHJcblxyXG5cclxuICB2YXIgQnJvd3NlciA9IHtcclxuICBcdGllOiBpZSxcclxuICBcdGllbHQ5OiBpZWx0OSxcclxuICBcdGVkZ2U6IGVkZ2UsXHJcbiAgXHR3ZWJraXQ6IHdlYmtpdCxcclxuICBcdGFuZHJvaWQ6IGFuZHJvaWQsXHJcbiAgXHRhbmRyb2lkMjM6IGFuZHJvaWQyMyxcclxuICBcdGFuZHJvaWRTdG9jazogYW5kcm9pZFN0b2NrLFxyXG4gIFx0b3BlcmE6IG9wZXJhLFxyXG4gIFx0Y2hyb21lOiBjaHJvbWUsXHJcbiAgXHRnZWNrbzogZ2Vja28sXHJcbiAgXHRzYWZhcmk6IHNhZmFyaSxcclxuICBcdHBoYW50b206IHBoYW50b20sXHJcbiAgXHRvcGVyYTEyOiBvcGVyYTEyLFxyXG4gIFx0d2luOiB3aW4sXHJcbiAgXHRpZTNkOiBpZTNkLFxyXG4gIFx0d2Via2l0M2Q6IHdlYmtpdDNkLFxyXG4gIFx0Z2Vja28zZDogZ2Vja28zZCxcclxuICBcdGFueTNkOiBhbnkzZCxcclxuICBcdG1vYmlsZTogbW9iaWxlLFxyXG4gIFx0bW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXHJcbiAgXHRtb2JpbGVXZWJraXQzZDogbW9iaWxlV2Via2l0M2QsXHJcbiAgXHRtc1BvaW50ZXI6IG1zUG9pbnRlcixcclxuICBcdHBvaW50ZXI6IHBvaW50ZXIsXHJcbiAgXHR0b3VjaDogdG91Y2gsXHJcbiAgXHR0b3VjaE5hdGl2ZTogdG91Y2hOYXRpdmUsXHJcbiAgXHRtb2JpbGVPcGVyYTogbW9iaWxlT3BlcmEsXHJcbiAgXHRtb2JpbGVHZWNrbzogbW9iaWxlR2Vja28sXHJcbiAgXHRyZXRpbmE6IHJldGluYSxcclxuICBcdHBhc3NpdmVFdmVudHM6IHBhc3NpdmVFdmVudHMsXHJcbiAgXHRjYW52YXM6IGNhbnZhcyQxLFxyXG4gIFx0c3ZnOiBzdmckMSxcclxuICBcdHZtbDogdm1sLFxyXG4gIFx0aW5saW5lU3ZnOiBpbmxpbmVTdmcsXHJcbiAgXHRtYWM6IG1hYyxcclxuICBcdGxpbnV4OiBsaW51eFxyXG4gIH07XG5cbiAgLypcbiAgICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAgICovXG5cbiAgdmFyIFBPSU5URVJfRE9XTiA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG4gIHZhciBQT0lOVEVSX01PVkUgPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnO1xuICB2YXIgUE9JTlRFUl9VUCA9ICAgICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgICAgIDogJ3BvaW50ZXJ1cCc7XG4gIHZhciBQT0lOVEVSX0NBTkNFTCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG4gIHZhciBwRXZlbnQgPSB7XG4gIFx0dG91Y2hzdGFydCAgOiBQT0lOVEVSX0RPV04sXG4gIFx0dG91Y2htb3ZlICAgOiBQT0lOVEVSX01PVkUsXG4gIFx0dG91Y2hlbmQgICAgOiBQT0lOVEVSX1VQLFxuICBcdHRvdWNoY2FuY2VsIDogUE9JTlRFUl9DQU5DRUxcbiAgfTtcbiAgdmFyIGhhbmRsZSA9IHtcbiAgXHR0b3VjaHN0YXJ0ICA6IF9vblBvaW50ZXJTdGFydCxcbiAgXHR0b3VjaG1vdmUgICA6IF9oYW5kbGVQb2ludGVyLFxuICBcdHRvdWNoZW5kICAgIDogX2hhbmRsZVBvaW50ZXIsXG4gIFx0dG91Y2hjYW5jZWwgOiBfaGFuZGxlUG9pbnRlclxuICB9O1xuICB2YXIgX3BvaW50ZXJzID0ge307XG4gIHZhciBfcG9pbnRlckRvY0xpc3RlbmVyID0gZmFsc2U7XG5cbiAgLy8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuICAvLyByZWYgaHR0cHM6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvIGh0dHBzOi8vd3d3LnczLm9yZy9CdWdzL1B1YmxpYy9zaG93X2J1Zy5jZ2k/aWQ9MjI4OTBcblxuICBmdW5jdGlvbiBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG4gIFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICBcdFx0X2FkZFBvaW50ZXJEb2NMaXN0ZW5lcigpO1xuICBcdH1cbiAgXHRpZiAoIWhhbmRsZVt0eXBlXSkge1xuICBcdFx0Y29uc29sZS53YXJuKCd3cm9uZyBldmVudCBzcGVjaWZpZWQ6JywgdHlwZSk7XG4gIFx0XHRyZXR1cm4gZmFsc2VGbjtcbiAgXHR9XG4gIFx0aGFuZGxlciA9IGhhbmRsZVt0eXBlXS5iaW5kKHRoaXMsIGhhbmRsZXIpO1xuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKHBFdmVudFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xuICBcdHJldHVybiBoYW5kbGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcikge1xuICBcdGlmICghcEV2ZW50W3R5cGVdKSB7XG4gIFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGV2ZW50IHNwZWNpZmllZDonLCB0eXBlKTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG4gIFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlckRvd24oZSkge1xuICBcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJNb3ZlKGUpIHtcbiAgXHRpZiAoX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuICBcdFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJVcChlKSB7XG4gIFx0ZGVsZXRlIF9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG4gIH1cblxuICBmdW5jdGlvbiBfYWRkUG9pbnRlckRvY0xpc3RlbmVyKCkge1xuICBcdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGF0IHBvaW50ZXJzIGFuZCBob3cgbWFueSBhcmUgYWN0aXZlIHRvIHByb3ZpZGUgZS50b3VjaGVzIGVtdWxhdGlvblxuICBcdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuICBcdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIF9nbG9iYWxQb2ludGVyRG93biwgdHJ1ZSk7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblxuICBcdFx0X3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSkge1xuICBcdGlmIChlLnBvaW50ZXJUeXBlID09PSAoZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCAnbW91c2UnKSkgeyByZXR1cm47IH1cblxuICBcdGUudG91Y2hlcyA9IFtdO1xuICBcdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG4gIFx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuICBcdH1cbiAgXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG4gIFx0aGFuZGxlcihlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vblBvaW50ZXJTdGFydChoYW5kbGVyLCBlKSB7XG4gIFx0Ly8gSUUxMCBzcGVjaWZpYzogTXNUb3VjaCBuZWVkcyBwcmV2ZW50RGVmYXVsdC4gU2VlICMyMDAwXG4gIFx0aWYgKGUuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggJiYgZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9UT1VDSCkge1xuICBcdFx0cHJldmVudERlZmF1bHQoZSk7XG4gIFx0fVxuICBcdF9oYW5kbGVQb2ludGVyKGhhbmRsZXIsIGUpO1xuICB9XG5cbiAgLypcclxuICAgKiBFeHRlbmRzIHRoZSBldmVudCBoYW5kbGluZyBjb2RlIHdpdGggZG91YmxlIHRhcCBzdXBwb3J0IGZvciBtb2JpbGUgYnJvd3NlcnMuXHJcbiAgICpcclxuICAgKiBOb3RlOiBjdXJyZW50bHkgbW9zdCBicm93c2VycyBmaXJlIG5hdGl2ZSBkYmxjbGljaywgd2l0aCBvbmx5IGEgZmV3IGV4Y2VwdGlvbnNcclxuICAgKiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzcwMTIjaXNzdWVjb21tZW50LTU5NTA4NzM4NilcclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gbWFrZURibGNsaWNrKGV2ZW50KSB7XHJcbiAgXHQvLyBpbiBtb2Rlcm4gYnJvd3NlcnMgYHR5cGVgIGNhbm5vdCBiZSBqdXN0IG92ZXJyaWRkZW46XHJcbiAgXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvR2V0dGVyX29ubHlcclxuICBcdHZhciBuZXdFdmVudCA9IHt9LFxyXG4gIFx0ICAgIHByb3AsIGk7XHJcbiAgXHRmb3IgKGkgaW4gZXZlbnQpIHtcclxuICBcdFx0cHJvcCA9IGV2ZW50W2ldO1xyXG4gIFx0XHRuZXdFdmVudFtpXSA9IHByb3AgJiYgcHJvcC5iaW5kID8gcHJvcC5iaW5kKGV2ZW50KSA6IHByb3A7XHJcbiAgXHR9XHJcbiAgXHRldmVudCA9IG5ld0V2ZW50O1xyXG4gIFx0bmV3RXZlbnQudHlwZSA9ICdkYmxjbGljayc7XHJcbiAgXHRuZXdFdmVudC5kZXRhaWwgPSAyO1xyXG4gIFx0bmV3RXZlbnQuaXNUcnVzdGVkID0gZmFsc2U7XHJcbiAgXHRuZXdFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTsgLy8gZm9yIGRlYnVnIHB1cnBvc2VzXHJcbiAgXHRyZXR1cm4gbmV3RXZlbnQ7XHJcbiAgfVxyXG5cclxuICB2YXIgZGVsYXkgPSAyMDA7XHJcbiAgZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKSB7XHJcbiAgXHQvLyBNb3N0IGJyb3dzZXJzIGhhbmRsZSBkb3VibGUgdGFwIG5hdGl2ZWx5XHJcbiAgXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyKTtcclxuXHJcbiAgXHQvLyBPbiBzb21lIHBsYXRmb3JtcyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgbmF0aXZlIGRibGNsaWNrcyBmb3IgdG91Y2ggZXZlbnRzLlxyXG4gIFx0Ly8gSXQgc2VlbXMgdGhhdCBpbiBhbGwgc3VjaCBjYXNlcyBgZGV0YWlsYCBwcm9wZXJ0eSBvZiBgY2xpY2tgIGV2ZW50IGlzIGFsd2F5cyBgMWAuXHJcbiAgXHQvLyBTbyBoZXJlIHdlIHJlbHkgb24gdGhhdCBmYWN0IHRvIGF2b2lkIGV4Y2Vzc2l2ZSAnZGJsY2xpY2snIHNpbXVsYXRpb24gd2hlbiBub3QgbmVlZGVkLlxyXG4gIFx0dmFyIGxhc3QgPSAwLFxyXG4gIFx0ICAgIGRldGFpbDtcclxuICBcdGZ1bmN0aW9uIHNpbURibGNsaWNrKGUpIHtcclxuICBcdFx0aWYgKGUuZGV0YWlsICE9PSAxKSB7XHJcbiAgXHRcdFx0ZGV0YWlsID0gZS5kZXRhaWw7IC8vIGtlZXAgaW4gc3luYyB0byBhdm9pZCBmYWxzZSBkYmxjbGljayBpbiBzb21lIGNhc2VzXHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fFxyXG4gIFx0XHRcdChlLnNvdXJjZUNhcGFiaWxpdGllcyAmJiAhZS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykpIHtcclxuXHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBXaGVuIGNsaWNraW5nIG9uIGFuIDxpbnB1dD4sIHRoZSBicm93c2VyIGdlbmVyYXRlcyBhIGNsaWNrIG9uIGl0c1xyXG4gIFx0XHQvLyA8bGFiZWw+IChhbmQgdmljZSB2ZXJzYSkgdHJpZ2dlcmluZyB0d28gY2xpY2tzIGluIHF1aWNrIHN1Y2Nlc3Npb24uXHJcbiAgXHRcdC8vIFRoaXMgaWdub3JlcyBjbGlja3Mgb24gZWxlbWVudHMgd2hpY2ggYXJlIGEgbGFiZWwgd2l0aCBhICdmb3InXHJcbiAgXHRcdC8vIGF0dHJpYnV0ZSAob3IgY2hpbGRyZW4gb2Ygc3VjaCBhIGxhYmVsKSwgYnV0IG5vdCBjaGlsZHJlbiBvZlxyXG4gIFx0XHQvLyBhIDxpbnB1dD4uXHJcbiAgXHRcdHZhciBwYXRoID0gZ2V0UHJvcGFnYXRpb25QYXRoKGUpO1xyXG4gIFx0XHRpZiAocGF0aC5zb21lKGZ1bmN0aW9uIChlbCkge1xyXG4gIFx0XHRcdHJldHVybiBlbCBpbnN0YW5jZW9mIEhUTUxMYWJlbEVsZW1lbnQgJiYgZWwuYXR0cmlidXRlcy5mb3I7XHJcbiAgXHRcdH0pICYmXHJcbiAgXHRcdFx0IXBhdGguc29tZShmdW5jdGlvbiAoZWwpIHtcclxuICBcdFx0XHRcdHJldHVybiAoXHJcbiAgXHRcdFx0XHRcdGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fFxyXG4gIFx0XHRcdFx0XHRlbCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50XHJcbiAgXHRcdFx0XHQpO1xyXG4gIFx0XHRcdH0pXHJcbiAgXHRcdCkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG5vdyA9IERhdGUubm93KCk7XHJcbiAgXHRcdGlmIChub3cgLSBsYXN0IDw9IGRlbGF5KSB7XHJcbiAgXHRcdFx0ZGV0YWlsKys7XHJcbiAgXHRcdFx0aWYgKGRldGFpbCA9PT0gMikge1xyXG4gIFx0XHRcdFx0aGFuZGxlcihtYWtlRGJsY2xpY2soZSkpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRkZXRhaWwgPSAxO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGxhc3QgPSBub3c7XHJcbiAgXHR9XHJcblxyXG4gIFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2ltRGJsY2xpY2spO1xyXG5cclxuICBcdHJldHVybiB7XHJcbiAgXHRcdGRibGNsaWNrOiBoYW5kbGVyLFxyXG4gIFx0XHRzaW1EYmxjbGljazogc2ltRGJsY2xpY2tcclxuICBcdH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXJzKSB7XHJcbiAgXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVycy5kYmxjbGljayk7XHJcbiAgXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVycy5zaW1EYmxjbGljayk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBEb21VdGlsXHJcbiAgICpcclxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAgICogdHJlZSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICpcclxuICAgKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAgICogU1ZHIGVsZW1lbnRzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgY2xhc3NlcyByZWZlciB0byBDU1MgY2xhc3Nlc1xyXG4gICAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICAgKi9cclxuXHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG4gIC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG4gIHZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuICBcdFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcbiAgLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4gIC8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuICAvLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcbiAgLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb24gc3R5bGUgbmFtZS5cclxuICB2YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG4gIFx0Wyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXHJcbiAgLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxuICB2YXIgVFJBTlNJVElPTl9FTkQgPVxyXG4gIFx0VFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IFRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgPyBUUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIC8vIFJldHVybnMgYW4gZWxlbWVudCBnaXZlbiBpdHMgRE9NIGlkLCBvciByZXR1cm5zIHRoZSBlbGVtZW50IGl0c2VsZlxyXG4gIC8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcbiAgZnVuY3Rpb24gZ2V0KGlkKSB7XHJcbiAgXHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4gIC8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXHJcbiAgLy8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxyXG4gIGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG4gIFx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSk7XHJcblxyXG4gIFx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuICBcdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG4gIFx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbiAgZnVuY3Rpb24gY3JlYXRlJDEodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuICBcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcbiAgXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG4gIFx0aWYgKGNvbnRhaW5lcikge1xyXG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGVsO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcbiAgZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcbiAgXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICBcdGlmIChwYXJlbnQpIHtcclxuICBcdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG4gIGZ1bmN0aW9uIGVtcHR5KGVsKSB7XHJcbiAgXHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG4gIFx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG4gIGZ1bmN0aW9uIHRvRnJvbnQoZWwpIHtcclxuICBcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0aWYgKHBhcmVudCAmJiBwYXJlbnQubGFzdENoaWxkICE9PSBlbCkge1xyXG4gIFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiZWhpbmQgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG4gIGZ1bmN0aW9uIHRvQmFjayhlbCkge1xyXG4gIFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHRpZiAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbCkge1xyXG4gIFx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpOiBCb29sZWFuXHJcbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuICBcdH1cclxuICBcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcbiAgXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4gIC8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0dmFyIGNsYXNzZXMgPSBzcGxpdFdvcmRzKG5hbWUpO1xyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcbiAgXHRcdH1cclxuICBcdH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG4gIFx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4gIC8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuICBcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0c2V0Q2xhc3MoZWwsIHRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbiAgLy8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG4gIGZ1bmN0aW9uIHNldENsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG4gIFx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcbiAgLy8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG4gIGZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcbiAgXHQvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkdFbGVtZW50SW5zdGFuY2UgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZ0VsZW1lbnQgaW5zdGVhZFxyXG4gIFx0Ly8gKFJlcXVpcmVkIGZvciBsaW5rZWQgU1ZHIGVsZW1lbnRzIGluIElFMTEuKVxyXG4gIFx0aWYgKGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50KSB7XHJcbiAgXHRcdGVsID0gZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcbiAgLy8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcbiAgLy8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG4gIGZ1bmN0aW9uIHNldE9wYWNpdHkoZWwsIHZhbHVlKSB7XHJcbiAgXHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcbiAgXHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuICBcdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuICBcdFx0X3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcclxuICBcdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuICBcdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcbiAgXHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuICBcdHRyeSB7XHJcbiAgXHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcbiAgXHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcbiAgXHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuICBcdH1cclxuXHJcbiAgXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuICBcdGlmIChmaWx0ZXIpIHtcclxuICBcdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcbiAgXHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG4gIC8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuICAvLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG4gIC8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG4gIGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XHJcbiAgXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuICBcdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICBcdHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuICAvLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG4gIC8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuICAvLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuICBcdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cclxuICBcdGVsLnN0eWxlW1RSQU5TRk9STV0gPVxyXG4gIFx0XHQoQnJvd3Nlci5pZTNkID9cclxuICBcdFx0XHQndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6XHJcbiAgXHRcdFx0J3RyYW5zbGF0ZTNkKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgsMCknKSArXHJcbiAgXHRcdChzY2FsZSA/ICcgc2NhbGUoJyArIHNjYWxlICsgJyknIDogJycpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG4gIC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcbiAgLy8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuICAvLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcbiAgZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHBvaW50KSB7XHJcblxyXG4gIFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG4gIFx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcbiAgXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblxyXG4gIFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcclxuICBcdFx0c2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcbiAgXHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbiAgLy8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cclxuICBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG4gIFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcbiAgXHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuICBcdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IFBvaW50KDAsIDApO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVUZXh0U2VsZWN0aW9uKClcclxuICAvLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG4gIC8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIG1vdXNlIHRocm91Z2ggYSBwYWdlIHdpdGggdGV4dC4gVXNlZCBpbnRlcm5hbGx5XHJcbiAgLy8gYnkgTGVhZmxldCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3VyIG9mIGFueSBjbGljay1hbmQtZHJhZyBpbnRlcmFjdGlvbiBvblxyXG4gIC8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuICAvLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXHJcbiAgLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG4gIHZhciBkaXNhYmxlVGV4dFNlbGVjdGlvbjtcclxuICB2YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcclxuICB2YXIgX3VzZXJTZWxlY3Q7XHJcbiAgaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xyXG4gIFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdG9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0fTtcclxuICBcdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdG9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICBcdH07XHJcbiAgfSBlbHNlIHtcclxuICBcdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSB0ZXN0UHJvcChcclxuICBcdFx0Wyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG4gIFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuICBcdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcbiAgXHRcdFx0X3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG4gIFx0XHRcdHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcbiAgXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcbiAgXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcclxuICBcdFx0XHRfdXNlclNlbGVjdCA9IHVuZGVmaW5lZDtcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKClcclxuICAvLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcbiAgLy8gZm9yIGBkcmFnc3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYW4gaW1hZ2UuXHJcbiAgZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpIHtcclxuICBcdG9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG4gIC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG4gIGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpIHtcclxuICBcdG9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgfVxyXG5cclxuICB2YXIgX291dGxpbmVFbGVtZW50LCBfb3V0bGluZVN0eWxlO1xyXG4gIC8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuICAvLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG4gIC8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuICAvLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcbiAgZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWxlbWVudCkge1xyXG4gIFx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XHJcbiAgXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgXHR9XHJcbiAgXHRpZiAoIWVsZW1lbnQuc3R5bGUpIHsgcmV0dXJuOyB9XHJcbiAgXHRyZXN0b3JlT3V0bGluZSgpO1xyXG4gIFx0X291dGxpbmVFbGVtZW50ID0gZWxlbWVudDtcclxuICBcdF9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmVTdHlsZTtcclxuICBcdGVsZW1lbnQuc3R5bGUub3V0bGluZVN0eWxlID0gJ25vbmUnO1xyXG4gIFx0b24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcbiAgLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuICBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpIHtcclxuICBcdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG4gIFx0X291dGxpbmVFbGVtZW50LnN0eWxlLm91dGxpbmVTdHlsZSA9IF9vdXRsaW5lU3R5bGU7XHJcbiAgXHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgXHRfb3V0bGluZVN0eWxlID0gdW5kZWZpbmVkO1xyXG4gIFx0b2ZmKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgLy8gRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgd2hpY2ggc2l6ZSAod2lkdGggYW5kIGhlaWdodCkgaXMgbm90IG51bGwuXHJcbiAgZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsZW1lbnQpIHtcclxuICBcdGRvIHtcclxuICBcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuICBcdH0gd2hpbGUgKCghZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAhZWxlbWVudC5vZmZzZXRIZWlnaHQpICYmIGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpO1xyXG4gIFx0cmV0dXJuIGVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0U2NhbGUoZWw6IEhUTUxFbGVtZW50KTogT2JqZWN0XHJcbiAgLy8gQ29tcHV0ZXMgdGhlIENTUyBzY2FsZSBjdXJyZW50bHkgYXBwbGllZCBvbiB0aGUgZWxlbWVudC5cclxuICAvLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIG1lbWJlcnMgYXMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2NhbGVzIHJlc3BlY3RpdmVseSxcclxuICAvLyBhbmQgYGJvdW5kaW5nQ2xpZW50UmVjdGAgYXMgdGhlIHJlc3VsdCBvZiBbYGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0Qm91bmRpbmdDbGllbnRSZWN0KS5cclxuICBmdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XHJcbiAgXHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFJlYWQtb25seSBpbiBvbGQgYnJvd3NlcnMuXHJcblxyXG4gIFx0cmV0dXJuIHtcclxuICBcdFx0eDogcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSxcclxuICBcdFx0eTogcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxLFxyXG4gIFx0XHRib3VuZGluZ0NsaWVudFJlY3Q6IHJlY3RcclxuICBcdH07XHJcbiAgfVxuXG4gIHZhciBEb21VdGlsID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBUUkFOU0ZPUk06IFRSQU5TRk9STSxcbiAgICBUUkFOU0lUSU9OOiBUUkFOU0lUSU9OLFxuICAgIFRSQU5TSVRJT05fRU5EOiBUUkFOU0lUSU9OX0VORCxcbiAgICBnZXQ6IGdldCxcbiAgICBnZXRTdHlsZTogZ2V0U3R5bGUsXG4gICAgY3JlYXRlOiBjcmVhdGUkMSxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICBlbXB0eTogZW1wdHksXG4gICAgdG9Gcm9udDogdG9Gcm9udCxcbiAgICB0b0JhY2s6IHRvQmFjayxcbiAgICBoYXNDbGFzczogaGFzQ2xhc3MsXG4gICAgYWRkQ2xhc3M6IGFkZENsYXNzLFxuICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICBzZXRDbGFzczogc2V0Q2xhc3MsXG4gICAgZ2V0Q2xhc3M6IGdldENsYXNzLFxuICAgIHNldE9wYWNpdHk6IHNldE9wYWNpdHksXG4gICAgdGVzdFByb3A6IHRlc3RQcm9wLFxuICAgIHNldFRyYW5zZm9ybTogc2V0VHJhbnNmb3JtLFxuICAgIHNldFBvc2l0aW9uOiBzZXRQb3NpdGlvbixcbiAgICBnZXRQb3NpdGlvbjogZ2V0UG9zaXRpb24sXG4gICAgZ2V0IGRpc2FibGVUZXh0U2VsZWN0aW9uICgpIHsgcmV0dXJuIGRpc2FibGVUZXh0U2VsZWN0aW9uOyB9LFxuICAgIGdldCBlbmFibGVUZXh0U2VsZWN0aW9uICgpIHsgcmV0dXJuIGVuYWJsZVRleHRTZWxlY3Rpb247IH0sXG4gICAgZGlzYWJsZUltYWdlRHJhZzogZGlzYWJsZUltYWdlRHJhZyxcbiAgICBlbmFibGVJbWFnZURyYWc6IGVuYWJsZUltYWdlRHJhZyxcbiAgICBwcmV2ZW50T3V0bGluZTogcHJldmVudE91dGxpbmUsXG4gICAgcmVzdG9yZU91dGxpbmU6IHJlc3RvcmVPdXRsaW5lLFxuICAgIGdldFNpemVkUGFyZW50Tm9kZTogZ2V0U2l6ZWRQYXJlbnROb2RlLFxuICAgIGdldFNjYWxlOiBnZXRTY2FsZVxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gICAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqL1xyXG5cclxuICAvLyBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICAvLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuICAvLyBlbGVtZW50IGBlbGAuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lclxyXG4gIC8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbiAgLy8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG4gIGZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0aWYgKHR5cGVzICYmIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdGFkZE9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdH1cclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICB2YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uXHJcbiAgLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4gIC8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZyk6IHRoaXNcclxuICAvLyBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVycyBvZiBnaXZlbiB0eXBlcy5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMgZnJvbSBnaXZlbiBIVE1MRWxlbWVudFxyXG4gIGZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgXHRcdGJhdGNoUmVtb3ZlKG9iaik7XHJcbiAgXHRcdGRlbGV0ZSBvYmpbZXZlbnRzS2V5XTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKHR5cGVzICYmIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuICBcdFx0XHRiYXRjaFJlbW92ZShvYmosIGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gaW5kZXhPZih0eXBlcywgdHlwZSkgIT09IC0xO1xyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGJhdGNoUmVtb3ZlKG9iaiwgZmlsdGVyRm4pIHtcclxuICBcdGZvciAodmFyIGlkIGluIG9ialtldmVudHNLZXldKSB7XHJcbiAgXHRcdHZhciB0eXBlID0gaWQuc3BsaXQoL1xcZC8pWzBdO1xyXG4gIFx0XHRpZiAoIWZpbHRlckZuIHx8IGZpbHRlckZuKHR5cGUpKSB7XHJcbiAgXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgbnVsbCwgbnVsbCwgaWQpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICB2YXIgbW91c2VTdWJzdCA9IHtcclxuICBcdG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxyXG4gIFx0bW91c2VsZWF2ZTogJ21vdXNlb3V0JyxcclxuICBcdHdoZWVsOiAhKCdvbndoZWVsJyBpbiB3aW5kb3cpICYmICdtb3VzZXdoZWVsJ1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGFkZE9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcbiAgXHR2YXIgaWQgPSB0eXBlICsgc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBzdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcbiAgXHRpZiAob2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG4gIFx0fTtcclxuXHJcbiAgXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcbiAgXHRpZiAoIUJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG4gIFx0XHQvLyBOZWVkcyBEb21FdmVudC5Qb2ludGVyLmpzXHJcbiAgXHRcdGhhbmRsZXIgPSBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpKSB7XHJcbiAgXHRcdGhhbmRsZXIgPSBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuICBcdFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCB0eXBlID09PSAndG91Y2htb3ZlJyB8fCB0eXBlID09PSAnd2hlZWwnIHx8ICB0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuICBcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZWVudGVyJyB8fCB0eXBlID09PSAnbW91c2VsZWF2ZScpIHtcclxuICBcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuICBcdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuICBcdFx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyKGUpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH07XHJcbiAgXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvcmlnaW5hbEhhbmRsZXIsIGZhbHNlKTtcclxuICBcdFx0fVxyXG5cclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcbiAgXHR9XHJcblxyXG4gIFx0b2JqW2V2ZW50c0tleV0gPSBvYmpbZXZlbnRzS2V5XSB8fCB7fTtcclxuICBcdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCwgaWQpIHtcclxuICBcdGlkID0gaWQgfHwgdHlwZSArIHN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcbiAgXHR2YXIgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcbiAgXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRpZiAoIUJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG4gIFx0XHRyZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpKSB7XHJcbiAgXHRcdHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcik7XHJcblxyXG4gIFx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG4gIFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG4gIFx0fVxyXG5cclxuICBcdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuICAvLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuICAvLyBgYGBqc1xyXG4gIC8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuICAvLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuICAvLyB9KTtcclxuICAvLyBgYGBcclxuICBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xyXG5cclxuICBcdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG4gIFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIFx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHsgIC8vIEluIGNhc2Ugb2YgTGVhZmxldCBldmVudC5cclxuICBcdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4gIC8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ3doZWVsJ2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG4gIGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbCkge1xyXG4gIFx0YWRkT25lKGVsLCAnd2hlZWwnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4gIC8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ2NsaWNrJ2AsIGAnZGJsY2xpY2snYCwgYCdjb250ZXh0bWVudSdgLFxyXG4gIC8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuICBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbCkge1xyXG4gIFx0b24oZWwsICdtb3VzZWRvd24gdG91Y2hzdGFydCBkYmxjbGljayBjb250ZXh0bWVudScsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRlbFsnX2xlYWZsZXRfZGlzYWJsZV9jbGljayddID0gdHJ1ZTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2OiBET01FdmVudCk6IHRoaXNcclxuICAvLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcbiAgLy8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG4gIC8vIHdpdGggcGFnZSByZWxvYWQgd2hlbiBhIGA8Zm9ybT5gIGlzIHN1Ym1pdHRlZCkuXHJcbiAgLy8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xyXG4gIFx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuICBcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc3RvcChldjogRE9NRXZlbnQpOiB0aGlzXHJcbiAgLy8gRG9lcyBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gIGZ1bmN0aW9uIHN0b3AoZSkge1xyXG4gIFx0cHJldmVudERlZmF1bHQoZSk7XHJcbiAgXHRzdG9wUHJvcGFnYXRpb24oZSk7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRQcm9wYWdhdGlvblBhdGgoZXY6IERPTUV2ZW50KTogQXJyYXlcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbYEV2ZW50LmNvbXBvc2VkUGF0aCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50L2NvbXBvc2VkUGF0aCkuXHJcbiAgLy8gUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBgSFRNTEVsZW1lbnRgcyB0aGF0IHRoZSBnaXZlbiBET00gZXZlbnRcclxuICAvLyBzaG91bGQgcHJvcGFnYXRlIHRvIChpZiBub3Qgc3RvcHBlZCkuXHJcbiAgZnVuY3Rpb24gZ2V0UHJvcGFnYXRpb25QYXRoKGV2KSB7XHJcbiAgXHRpZiAoZXYuY29tcG9zZWRQYXRoKSB7XHJcbiAgXHRcdHJldHVybiBldi5jb21wb3NlZFBhdGgoKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgcGF0aCA9IFtdO1xyXG4gIFx0dmFyIGVsID0gZXYudGFyZ2V0O1xyXG5cclxuICBcdHdoaWxlIChlbCkge1xyXG4gIFx0XHRwYXRoLnB1c2goZWwpO1xyXG4gIFx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gcGF0aDtcclxuICB9XHJcblxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuICAvLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuICAvLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gIGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSwgY29udGFpbmVyKSB7XHJcbiAgXHRpZiAoIWNvbnRhaW5lcikge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgc2NhbGUgPSBnZXRTY2FsZShjb250YWluZXIpLFxyXG4gIFx0ICAgIG9mZnNldCA9IHNjYWxlLmJvdW5kaW5nQ2xpZW50UmVjdDsgLy8gbGVmdCBhbmQgdG9wICB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgdGhlIGV2ZW50IGNsaWVudFgvWSlcclxuXHJcbiAgXHRyZXR1cm4gbmV3IFBvaW50KFxyXG4gIFx0XHQvLyBvZmZzZXQubGVmdC90b3AgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIGNsaWVudFgvWSksXHJcbiAgXHRcdC8vIHdoZXJlYXMgY2xpZW50TGVmdC9Ub3AgKGJvcmRlciB3aWR0aCkgdmFsdWVzIGFyZSB0aGUgb3JpZ2luYWwgdmFsdWVzIChiZWZvcmUgQ1NTIHNjYWxlIGFwcGxpZXMpLlxyXG4gIFx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG4gIFx0XHQoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcFxyXG4gIFx0KTtcclxuICB9XHJcblxyXG5cclxuICAvLyAgZXhjZXB0ICwgU2FmYXJpIGFuZFxyXG4gIC8vIFdlIG5lZWQgZG91YmxlIHRoZSBzY3JvbGwgcGl4ZWxzIChzZWUgIzc0MDMgYW5kICM0NTM4KSBmb3IgYWxsIEJyb3dzZXJzXHJcbiAgLy8gZXhjZXB0IE9TWCAoTWFjKSAtPiAzeCwgQ2hyb21lIHJ1bm5pbmcgb24gTGludXggMXhcclxuXHJcbiAgdmFyIHdoZWVsUHhGYWN0b3IgPVxyXG4gIFx0KEJyb3dzZXIubGludXggJiYgQnJvd3Nlci5jaHJvbWUpID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG4gIFx0QnJvd3Nlci5tYWMgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAqIDMgOlxyXG4gIFx0d2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAwID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuICAvLyBAZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShldjogRE9NRXZlbnQpOiBOdW1iZXJcclxuICAvLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIHdoZWVsIERPTSBldmVudCwgaW4gdmVydGljYWxcclxuICAvLyBwaXhlbHMgc2Nyb2xsZWQgKG5lZ2F0aXZlIGlmIHNjcm9sbGluZyBkb3duKS5cclxuICAvLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG4gIC8vIGEgYmVzdCBndWVzcyBvZiA2MCBwaXhlbHMuXHJcbiAgZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcbiAgXHRyZXR1cm4gKEJyb3dzZXIuZWRnZSkgPyBlLndoZWVsRGVsdGFZIC8gMiA6IC8vIERvbid0IHRydXN0IHdpbmRvdy1nZW9tZXRyeS1iYXNlZCBkZWx0YVxyXG4gIFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyB3aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcbiAgXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuICBcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDIpID8gLWUuZGVsdGFZICogNjAgOiAvLyBQYWdlc1xyXG4gIFx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuICBcdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuICBcdCAgICAgICAoZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUpID8gLWUuZGV0YWlsICogMjAgOiAvLyBMZWdhY3kgTW96IGxpbmVzXHJcbiAgXHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG4gIFx0ICAgICAgIDA7XHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuICBmdW5jdGlvbiBpc0V4dGVybmFsVGFyZ2V0KGVsLCBlKSB7XHJcblxyXG4gIFx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG4gIFx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG4gIFx0dHJ5IHtcclxuICBcdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG4gIFx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcbiAgXHRcdH1cclxuICBcdH0gY2F0Y2ggKGVycikge1xyXG4gIFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxuICB9XG5cbiAgdmFyIERvbUV2ZW50ID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBvbjogb24sXG4gICAgb2ZmOiBvZmYsXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBzdG9wUHJvcGFnYXRpb24sXG4gICAgZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uOiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24sXG4gICAgZGlzYWJsZUNsaWNrUHJvcGFnYXRpb246IGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uLFxuICAgIHByZXZlbnREZWZhdWx0OiBwcmV2ZW50RGVmYXVsdCxcbiAgICBzdG9wOiBzdG9wLFxuICAgIGdldFByb3BhZ2F0aW9uUGF0aDogZ2V0UHJvcGFnYXRpb25QYXRoLFxuICAgIGdldE1vdXNlUG9zaXRpb246IGdldE1vdXNlUG9zaXRpb24sXG4gICAgZ2V0V2hlZWxEZWx0YTogZ2V0V2hlZWxEZWx0YSxcbiAgICBpc0V4dGVybmFsVGFyZ2V0OiBpc0V4dGVybmFsVGFyZ2V0LFxuICAgIGFkZExpc3RlbmVyOiBvbixcbiAgICByZW1vdmVMaXN0ZW5lcjogb2ZmXG4gIH07XG5cbiAgLypcbiAgICogQGNsYXNzIFBvc0FuaW1hdGlvblxuICAgKiBAYWthIEwuUG9zQW5pbWF0aW9uXG4gICAqIEBpbmhlcml0cyBFdmVudGVkXG4gICAqIFVzZWQgaW50ZXJuYWxseSBmb3IgcGFubmluZyBhbmltYXRpb25zLCB1dGlsaXppbmcgQ1NTMyBUcmFuc2l0aW9ucyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBhIHRpbWVyIGZhbGxiYWNrIGZvciBJRTYtOS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogdmFyIG15UG9zaXRpb25NYXJrZXIgPSBMLm1hcmtlcihbNDguODY0NzE2LCAyLjI5NDY5NF0pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIG15UG9zaXRpb25NYXJrZXIub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICogXHR2YXIgcG9zID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChteVBvc2l0aW9uTWFya2VyLmdldExhdExuZygpKTtcbiAgICogXHRwb3MueSAtPSAyNTtcbiAgICogXHR2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAgICpcbiAgICogXHRmeC5vbmNlKCdlbmQnLGZ1bmN0aW9uKCkge1xuICAgKiBcdFx0cG9zLnkgKz0gMjU7XG4gICAqIFx0XHRmeC5ydW4obXlQb3NpdGlvbk1hcmtlci5faWNvbiwgcG9zLCAwLjgpO1xuICAgKiBcdH0pO1xuICAgKlxuICAgKiBcdGZ4LnJ1bihteVBvc2l0aW9uTWFya2VyLl9pY29uLCBwb3MsIDAuMyk7XG4gICAqIH0pO1xuICAgKlxuICAgKiBgYGBcbiAgICpcbiAgICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAgICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAgICpcbiAgICovXG5cbiAgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuICBcdC8vIEBtZXRob2QgcnVuKGVsOiBIVE1MRWxlbWVudCwgbmV3UG9zOiBQb2ludCwgZHVyYXRpb24/OiBOdW1iZXIsIGVhc2VMaW5lYXJpdHk/OiBOdW1iZXIpXG4gIFx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuICBcdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuICBcdC8vIGFyZ3VtZW50IG9mIHRoZSBbY3ViaWMgYmV6aWVyIGN1cnZlXShodHRwczovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcbiAgXHQvLyBgMC41YCBieSBkZWZhdWx0KS5cbiAgXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuICBcdFx0dGhpcy5zdG9wKCk7XG5cbiAgXHRcdHRoaXMuX2VsID0gZWw7XG4gIFx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcbiAgXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcbiAgXHRcdHRoaXMuX2Vhc2VPdXRQb3dlciA9IDEgLyBNYXRoLm1heChlYXNlTGluZWFyaXR5IHx8IDAuNSwgMC4yKTtcblxuICBcdFx0dGhpcy5fc3RhcnRQb3MgPSBnZXRQb3NpdGlvbihlbCk7XG4gIFx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuICBcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgXHRcdC8vIEBldmVudCBzdGFydDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcbiAgXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuICBcdFx0dGhpcy5fYW5pbWF0ZSgpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHN0b3AoKVxuICBcdC8vIFN0b3BzIHRoZSBhbmltYXRpb24gKGlmIGN1cnJlbnRseSBydW5uaW5nKS5cbiAgXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX3N0ZXAodHJ1ZSk7XG4gIFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuICBcdH0sXG5cbiAgXHRfYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gYW5pbWF0aW9uIGxvb3BcbiAgXHRcdHRoaXMuX2FuaW1JZCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG4gIFx0XHR0aGlzLl9zdGVwKCk7XG4gIFx0fSxcblxuICBcdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcbiAgXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcbiAgXHRcdCAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uICogMTAwMDtcblxuICBcdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuICBcdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuICBcdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkocHJvZ3Jlc3MpKTtcbiAgXHRcdGlmIChyb3VuZCkge1xuICBcdFx0XHRwb3MuX3JvdW5kKCk7XG4gIFx0XHR9XG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9lbCwgcG9zKTtcblxuICBcdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG4gIFx0XHR0aGlzLmZpcmUoJ3N0ZXAnKTtcbiAgXHR9LFxuXG4gIFx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuICBcdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuICBcdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuICBcdFx0dGhpcy5maXJlKCdlbmQnKTtcbiAgXHR9LFxuXG4gIFx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgTWFwXHJcbiAgICogQGFrYSBMLk1hcFxyXG4gICAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAgICpcclxuICAgKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICAgKiBcdGNlbnRlcjogWzUxLjUwNSwgLTAuMDldLFxyXG4gICAqIFx0em9vbTogMTNcclxuICAgKiB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqL1xyXG5cclxuICB2YXIgTWFwID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQHNlY3Rpb24gTWFwIFN0YXRlIE9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcbiAgXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuICBcdFx0Ly8gc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG4gIFx0XHRjcnM6IEVQU0czODU3LFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG4gIFx0XHQvLyBJbml0aWFsIGdlb2dyYXBoaWMgY2VudGVyIG9mIHRoZSBtYXBcclxuICBcdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG4gIFx0XHQvLyBJbml0aWFsIG1hcCB6b29tIGxldmVsXHJcbiAgXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gKlxyXG4gIFx0XHQvLyBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuICBcdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcbiAgXHRcdC8vIHRoZSBsb3dlc3Qgb2YgdGhlaXIgYG1pblpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgXHRcdG1pblpvb206IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gKlxyXG4gIFx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuICBcdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcbiAgXHRcdC8vIHRoZSBoaWdoZXN0IG9mIHRoZWlyIGBtYXhab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gIFx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGxheWVyczogTGF5ZXJbXSA9IFtdXHJcbiAgXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuICBcdFx0bGF5ZXJzOiBbXSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWF4Qm91bmRzOiBMYXRMbmdCb3VuZHMgPSBudWxsXHJcbiAgXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuICBcdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayBpZiB0aGUgdXNlciB0cmllcyB0byBwYW5cclxuICBcdFx0Ly8gb3V0c2lkZSB0aGUgdmlldy4gVG8gc2V0IHRoZSByZXN0cmljdGlvbiBkeW5hbWljYWxseSwgdXNlXHJcbiAgXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuICBcdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlciA9ICpcclxuICBcdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG4gIFx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuICBcdFx0cmVuZGVyZXI6IHVuZGVmaW5lZCxcclxuXHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCB6b29tIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG4gIFx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcbiAgXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcclxuICBcdFx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxyXG4gIFx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBmYWRlQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcbiAgXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0ZmFkZUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuICBcdFx0Ly8gdGhleSB3aWxsIGRpc2FwcGVhciBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0J3NcclxuICBcdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcbiAgXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYW5zZm9ybTNETGltaXQ6IE51bWJlciA9IDJeMjNcclxuICBcdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuICBcdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuICBcdFx0Ly8gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGRvaW5nIGEgbGFyZ2UgYHBhbkJ5YC5cclxuICBcdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbVNuYXA6IE51bWJlciA9IDFcclxuICBcdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG4gIFx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG4gIFx0XHQvLyBCeSBkZWZhdWx0LCB0aGUgem9vbSBsZXZlbCBzbmFwcyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyOyBsb3dlciB2YWx1ZXNcclxuICBcdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG4gIFx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuICBcdFx0em9vbVNuYXA6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG4gIFx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcbiAgXHRcdC8vIFtgem9vbUluKClgXSgjbWFwLXpvb21pbiksIFtgem9vbU91dCgpYF0oI21hcC16b29tb3V0KSwgcHJlc3NpbmcgYCtgXHJcbiAgXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcbiAgXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuICBcdFx0em9vbURlbHRhOiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuICBcdFx0dHJhY2tSZXNpemU6IHRydWVcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuICBcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHQvLyBNYWtlIHN1cmUgdG8gYXNzaWduIGludGVybmFsIGZsYWdzIGF0IHRoZSBiZWdpbm5pbmcsXHJcbiAgXHRcdC8vIHRvIGF2b2lkIGluY29uc2lzdGVudCBzdGF0ZSBpbiBzb21lIGVkZ2UgY2FzZXMuXHJcbiAgXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG4gIFx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuICBcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuICBcdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcbiAgXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcbiAgXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuICBcdFx0dGhpcy5fb25SZXNpemUgPSBiaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLm1heEJvdW5kcykge1xyXG4gIFx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aGlzLnNldFZpZXcodG9MYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcbiAgXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxyXG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBUUkFOU0lUSU9OICYmIEJyb3dzZXIuYW55M2QgJiYgIUJyb3dzZXIubW9iaWxlT3BlcmEgJiZcclxuICBcdFx0XHRcdHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuICBcdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXHJcbiAgXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fY3JlYXRlQW5pbVByb3h5KCk7XHJcbiAgXHRcdFx0b24odGhpcy5fcHJveHksIFRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSB3aXRoIHRoZSBnaXZlblxyXG4gIFx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcbiAgXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuICBcdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIodG9MYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBcdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XHJcblxyXG4gIFx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdFx0b3B0aW9ucy56b29tID0gZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xyXG4gIFx0XHRcdFx0b3B0aW9ucy5wYW4gPSBleHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXHJcbiAgXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cclxuICBcdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcclxuICBcdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xyXG5cclxuICBcdFx0XHRpZiAobW92ZWQpIHtcclxuICBcdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcclxuICBcdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xyXG4gIFx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tLCBvcHRpb25zLnBhbiAmJiBvcHRpb25zLnBhbi5ub01vdmVTdGFydCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcbiAgXHRzZXRab29tOiBmdW5jdGlvbiAoem9vbSwgb3B0aW9ucykge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuICBcdHpvb21JbjogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcbiAgXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcbiAgXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuICBcdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcbiAgXHQvLyBzdGF0aW9uYXJ5IChlLmcuIHVzZWQgaW50ZXJuYWxseSBmb3Igc2Nyb2xsIHpvb20gYW5kIGRvdWJsZS1jbGljayB6b29tKS5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIHBpeGVsIG9uIHRoZSBtYXAgKHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIpIHN0YXRpb25hcnkuXHJcbiAgXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG4gIFx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuICBcdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcbiAgXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuICBcdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyh2aWV3SGFsZi5hZGQoY2VudGVyT2Zmc2V0KSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldEJvdW5kc0NlbnRlclpvb206IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIFx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcbiAgXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuICBcdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcbiAgXHRcdHpvb20gPSAodHlwZW9mIG9wdGlvbnMubWF4Wm9vbSA9PT0gJ251bWJlcicpID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG4gIFx0XHRpZiAoem9vbSA9PT0gSW5maW5pdHkpIHtcclxuICBcdFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdFx0Y2VudGVyOiBib3VuZHMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdFx0XHR6b29tOiB6b29tXHJcbiAgXHRcdFx0fTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcbiAgXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcbiAgXHRcdCAgICBuZVBvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcbiAgXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuICBcdFx0cmV0dXJuIHtcclxuICBcdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuICBcdFx0XHR6b29tOiB6b29tXHJcbiAgXHRcdH07XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG4gIFx0Ly8gbWF4aW11bSB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG4gIFx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZml0V29ybGQob3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcbiAgXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG4gIFx0Zml0V29ybGQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhblRvKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcbiAgXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5fem9vbSwge3Bhbjogb3B0aW9uc30pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFBhbnMgdGhlIG1hcCBieSBhIGdpdmVuIG51bWJlciBvZiBwaXhlbHMgKGFuaW1hdGVkKS5cclxuICBcdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XHJcbiAgXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xyXG4gIFx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7XHJcbiAgXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XHJcbiAgXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcbiAgXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XHJcbiAgXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXHJcbiAgXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcbiAgXHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcbiAgXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGFuaW1hdGUgcGFuIHVubGVzcyBhbmltYXRlOiBmYWxzZSBzcGVjaWZpZWRcclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuICBcdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcclxuICBcdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXHJcbiAgXHQvLyBwYW4tem9vbSBhbmltYXRpb24uXHJcbiAgXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8ICFCcm93c2VyLmFueTNkKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG4gIFx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuICBcdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXHJcbiAgXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXHJcbiAgXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuICBcdFx0dGFyZ2V0Q2VudGVyID0gdG9MYXRMbmcodGFyZ2V0Q2VudGVyKTtcclxuICBcdFx0dGFyZ2V0Wm9vbSA9IHRhcmdldFpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHRhcmdldFpvb207XHJcblxyXG4gIFx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcbiAgXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcclxuICBcdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXHJcbiAgXHRcdCAgICByaG8gPSAxLjQyLFxyXG4gIFx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIHIoaSkge1xyXG4gIFx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcbiAgXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXHJcbiAgXHRcdFx0ICAgIHQxID0gdzEgKiB3MSAtIHcwICogdzAgKyBzMSAqIHJobzIgKiByaG8yICogdTEgKiB1MSxcclxuICBcdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcbiAgXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxyXG4gIFx0XHRcdCAgICBzcSA9IE1hdGguc3FydChiICogYiArIDEpIC0gYjtcclxuXHJcbiAgXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuICBcdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cclxuICBcdFx0XHQgICAgdmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XHJcblxyXG4gIFx0XHRcdHJldHVybiBsb2c7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuICBcdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG4gIFx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XHJcblxyXG4gIFx0XHR2YXIgcjAgPSByKDApO1xyXG5cclxuICBcdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuICBcdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cclxuXHJcbiAgXHRcdGZ1bmN0aW9uIGVhc2VPdXQodCkgeyByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCAxLjUpOyB9XHJcblxyXG4gIFx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG4gIFx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxyXG4gIFx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG4gIFx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcclxuICBcdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xyXG5cclxuICBcdFx0XHRpZiAodCA8PSAxKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XHJcblxyXG4gIFx0XHRcdFx0dGhpcy5fbW92ZShcclxuICBcdFx0XHRcdFx0dGhpcy51bnByb2plY3QoZnJvbS5hZGQodG8uc3VidHJhY3QoZnJvbSkubXVsdGlwbHlCeSh1KHMpIC8gdTEpKSwgc3RhcnRab29tKSxcclxuICBcdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxyXG4gIFx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdHRoaXNcclxuICBcdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuICBcdFx0XHRcdFx0Ll9tb3ZlRW5kKHRydWUpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZVN0YXJ0KHRydWUsIG9wdGlvbnMubm9Nb3ZlU3RhcnQpO1xyXG5cclxuICBcdFx0ZnJhbWUuY2FsbCh0aGlzKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuICBcdC8vIGJ1dCB0YWtlcyBhIGJvdW5kcyBwYXJhbWV0ZXIgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuICBcdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgXHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcbiAgXHQvLyBSZXN0cmljdHMgdGhlIG1hcCB2aWV3IHRvIHRoZSBnaXZlbiBib3VuZHMgKHNlZSB0aGUgW21heEJvdW5kc10oI21hcC1tYXhib3VuZHMpIG9wdGlvbikuXHJcbiAgXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLmxpc3RlbnMoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpKSB7XHJcbiAgXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuICBcdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1pblpvb207XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuICBcdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuICBcdHNldE1heFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuICBcdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIHRvIHRoZSBjbG9zZXN0IHZpZXcgdGhhdCB3b3VsZCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBib3VuZHMgKGlmIGl0J3Mgbm90IGFscmVhZHkpLCBjb250cm9sbGluZyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBvcHRpb25zIHNwZWNpZmljLCBpZiBhbnkuXHJcbiAgXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuICBcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuICBcdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuICBcdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuICBcdFx0XHR0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5JbnNpZGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBwYWRkaW5nIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBQYW5zIHRoZSBtYXAgdGhlIG1pbmltdW0gYW1vdW50IHRvIG1ha2UgdGhlIGBsYXRsbmdgIHZpc2libGUuIFVzZVxyXG4gIFx0Ly8gcGFkZGluZyBvcHRpb25zIHRvIGZpdCB0aGUgZGlzcGxheSB0byBtb3JlIHJlc3RyaWN0ZWQgYm91bmRzLlxyXG4gIFx0Ly8gSWYgYGxhdGxuZ2AgaXMgYWxyZWFkeSB3aXRoaW4gdGhlIChvcHRpb25hbGx5IHBhZGRlZCkgZGlzcGxheSBib3VuZHMsXHJcbiAgXHQvLyB0aGUgbWFwIHdpbGwgbm90IGJlIHBhbm5lZC5cclxuICBcdHBhbkluc2lkZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcbiAgXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG4gIFx0XHQgICAgcGl4ZWxDZW50ZXIgPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcbiAgXHRcdCAgICBwaXhlbFBvaW50ID0gdGhpcy5wcm9qZWN0KGxhdGxuZyksXHJcbiAgXHRcdCAgICBwaXhlbEJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuICBcdFx0ICAgIHBhZGRlZEJvdW5kcyA9IHRvQm91bmRzKFtwaXhlbEJvdW5kcy5taW4uYWRkKHBhZGRpbmdUTCksIHBpeGVsQm91bmRzLm1heC5zdWJ0cmFjdChwYWRkaW5nQlIpXSksXHJcbiAgXHRcdCAgICBwYWRkZWRTaXplID0gcGFkZGVkQm91bmRzLmdldFNpemUoKTtcclxuXHJcbiAgXHRcdGlmICghcGFkZGVkQm91bmRzLmNvbnRhaW5zKHBpeGVsUG9pbnQpKSB7XHJcbiAgXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuICBcdFx0XHR2YXIgY2VudGVyT2Zmc2V0ID0gcGl4ZWxQb2ludC5zdWJ0cmFjdChwYWRkZWRCb3VuZHMuZ2V0Q2VudGVyKCkpO1xyXG4gIFx0XHRcdHZhciBvZmZzZXQgPSBwYWRkZWRCb3VuZHMuZXh0ZW5kKHBpeGVsUG9pbnQpLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkZWRTaXplKTtcclxuICBcdFx0XHRwaXhlbENlbnRlci54ICs9IGNlbnRlck9mZnNldC54IDwgMCA/IC1vZmZzZXQueCA6IG9mZnNldC54O1xyXG4gIFx0XHRcdHBpeGVsQ2VudGVyLnkgKz0gY2VudGVyT2Zmc2V0LnkgPCAwID8gLW9mZnNldC55IDogb2Zmc2V0Lnk7XHJcbiAgXHRcdFx0dGhpcy5wYW5Ubyh0aGlzLnVucHJvamVjdChwaXhlbENlbnRlciksIG9wdGlvbnMpO1xyXG4gIFx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKG9wdGlvbnM6IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcbiAgXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuICBcdC8vIHBhbiBieSBkZWZhdWx0LiBJZiBgb3B0aW9ucy5wYW5gIGlzIGBmYWxzZWAsIHBhbm5pbmcgd2lsbCBub3Qgb2NjdXIuXHJcbiAgXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuICBcdC8vIHRoYXQgaXQgZG9lc24ndCBoYXBwZW4gb2Z0ZW4gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtYW55XHJcbiAgXHQvLyB0aW1lcyBpbiBhIHJvdy5cclxuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuICBcdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG4gIFx0Ly8gcGFuIGJ5IGRlZmF1bHQuXHJcbiAgXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBleHRlbmQoe1xyXG4gIFx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG4gIFx0XHRcdHBhbjogdHJ1ZVxyXG4gIFx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG4gIFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcbiAgXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuICBcdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuICBcdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuICBcdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuICBcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuICBcdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG4gIFx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuICBcdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuICBcdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG4gIFx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgncmVzaXplJywge1xyXG4gIFx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcbiAgXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG4gIFx0Ly8gQG1ldGhvZCBzdG9wKCk6IHRoaXNcclxuICBcdC8vIFN0b3BzIHRoZSBjdXJyZW50bHkgcnVubmluZyBgcGFuVG9gIG9yIGBmbHlUb2AgYW5pbWF0aW9uLCBpZiBhbnkuXHJcbiAgXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xyXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy56b29tU25hcCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMuX3N0b3AoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gR2VvbG9jYXRpb24gbWV0aG9kc1xyXG4gIFx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuICBcdC8vIGV2ZW50IHdpdGggbG9jYXRpb24gZGF0YSBvbiBzdWNjZXNzIG9yIGEgW2Bsb2NhdGlvbmVycm9yYF0oI21hcC1sb2NhdGlvbmVycm9yKSBldmVudCBvbiBmYWlsdXJlLFxyXG4gIFx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuICBcdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuICBcdC8vIE5vdGUgdGhhdCwgaWYgeW91ciBwYWdlIGRvZXNuJ3QgdXNlIEhUVFBTLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgaW5cclxuICBcdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuICBcdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgXHRsb2NhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IGV4dGVuZCh7XHJcbiAgXHRcdFx0dGltZW91dDogMTAwMDAsXHJcbiAgXHRcdFx0d2F0Y2g6IGZhbHNlXHJcbiAgXHRcdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuICBcdFx0XHQvLyBtYXhab29tOiA8TnVtYmVyPlxyXG4gIFx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuICBcdFx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcbiAgXHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcbiAgXHRcdFx0dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7XHJcbiAgXHRcdFx0XHRjb2RlOiAwLFxyXG4gIFx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgb25SZXNwb25zZSA9IGJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcbiAgXHRcdCAgICBvbkVycm9yID0gYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcbiAgXHRcdFx0dGhpcy5fbG9jYXRpb25XYXRjaElkID1cclxuICBcdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcbiAgXHQvLyBTdG9wcyB3YXRjaGluZyBsb2NhdGlvbiBwcmV2aW91c2x5IGluaXRpYXRlZCBieSBgbWFwLmxvY2F0ZSh7d2F0Y2g6IHRydWV9KWBcclxuICBcdC8vIGFuZCBhYm9ydHMgcmVzZXR0aW5nIHRoZSBtYXAgdmlldyBpZiBtYXAubG9jYXRlIHdhcyBjYWxsZWQgd2l0aFxyXG4gIFx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcbiAgXHRzdG9wTG9jYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gJiYgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2gpIHtcclxuICBcdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcbiAgXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9oYW5kbGVHZW9sb2NhdGlvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcbiAgXHRcdCAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fFxyXG4gIFx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG4gIFx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgJiYgIXRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gTG9jYXRpb24gZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuICBcdFx0dGhpcy5maXJlKCdsb2NhdGlvbmVycm9yJywge1xyXG4gIFx0XHRcdGNvZGU6IGMsXHJcbiAgXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuICBcdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG4gIFx0XHQgICAgbGF0bG5nID0gbmV3IExhdExuZyhsYXQsIGxuZyksXHJcbiAgXHRcdCAgICBib3VuZHMgPSBsYXRsbmcudG9Cb3VuZHMocG9zLmNvb3Jkcy5hY2N1cmFjeSAqIDIpLFxyXG4gIFx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcbiAgXHRcdFx0dmFyIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzKTtcclxuICBcdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBkYXRhID0ge1xyXG4gIFx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG4gIFx0XHRcdGJvdW5kczogYm91bmRzLFxyXG4gIFx0XHRcdHRpbWVzdGFtcDogcG9zLnRpbWVzdGFtcFxyXG4gIFx0XHR9O1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcbiAgXHRcdFx0aWYgKHR5cGVvZiBwb3MuY29vcmRzW2ldID09PSAnbnVtYmVyJykge1xyXG4gIFx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKVxyXG4gIFx0XHQvLyB3ZW50IHN1Y2Nlc3NmdWxseS5cclxuICBcdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIFRPRE8gQXBwcm9wcmlhdGUgZG9jcyBzZWN0aW9uP1xyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG4gIFx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcclxuICBcdC8vIEFkZHMgYSBuZXcgYEhhbmRsZXJgIHRvIHRoZSBtYXAsIGdpdmVuIGl0cyBuYW1lIGFuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuICBcdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuICBcdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdHZhciBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG4gIFx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcbiAgXHQvLyBEZXN0cm95cyB0aGUgbWFwIGFuZCBjbGVhcnMgYWxsIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG4gIFx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm1heEJvdW5kcykgeyB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7IH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRyeSB7XHJcbiAgXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZDtcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVySWQ7XHJcbiAgXHRcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0XHQvKmVzbGludC1kaXNhYmxlICovXHJcbiAgXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkID0gdW5kZWZpbmVkO1xyXG4gIFx0XHRcdC8qIGVzbGludC1lbmFibGUgKi9cclxuICBcdFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHVuZGVmaW5lZDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0dGhpcy5zdG9wTG9jYXRlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuICBcdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5fcmVzaXplUmVxdWVzdCkge1xyXG4gIFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuICBcdFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gbnVsbDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHVubG9hZDogRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgZGVzdHJveWVkIHdpdGggW3JlbW92ZV0oI21hcC1yZW1vdmUpIG1ldGhvZC5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgaTtcclxuICBcdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpXS5yZW1vdmUoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuICBcdFx0XHRyZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuICBcdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuICBcdFx0ZGVsZXRlIHRoaXMuX21hcFBhbmU7XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9yZW5kZXJlcjtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcbiAgXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBDcmVhdGVzIGEgbmV3IFttYXAgcGFuZV0oI21hcC1wYW5lKSB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSxcclxuICBcdC8vIHRoZW4gcmV0dXJucyBpdC4gVGhlIHBhbmUgaXMgY3JlYXRlZCBhcyBhIGNoaWxkIG9mIGBjb250YWluZXJgLCBvclxyXG4gIFx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG4gIFx0Y3JlYXRlUGFuZTogZnVuY3Rpb24gKG5hbWUsIGNvbnRhaW5lcikge1xyXG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuICBcdFx0ICAgIHBhbmUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG4gIFx0XHRpZiAobmFtZSkge1xyXG4gIFx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gcGFuZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjZW50ZXIgb2YgdGhlIG1hcCB2aWV3XHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlci5jbG9uZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFpvb20oKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcbiAgXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBtYXAgdmlld1xyXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcbiAgXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG4gIFx0Z2V0TWluWm9vbTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE1heFpvb20oKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcbiAgXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuICBcdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcbiAgXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbiwgcGFkZGluZz86IFBvaW50KTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG4gIFx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG4gIFx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG4gIFx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcbiAgXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcbiAgXHRcdHBhZGRpbmcgPSB0b1BvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcbiAgXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuICBcdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcbiAgXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuICBcdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG4gIFx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG4gIFx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuICBcdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMSxcclxuICBcdFx0ICAgIHNjYWxleCA9IHNpemUueCAvIGJvdW5kc1NpemUueCxcclxuICBcdFx0ICAgIHNjYWxleSA9IHNpemUueSAvIGJvdW5kc1NpemUueSxcclxuICBcdFx0ICAgIHNjYWxlID0gaW5zaWRlID8gTWF0aC5tYXgoc2NhbGV4LCBzY2FsZXkpIDogTWF0aC5taW4oc2NhbGV4LCBzY2FsZXkpO1xyXG5cclxuICBcdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcbiAgXHRcdGlmIChzbmFwKSB7XHJcbiAgXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG4gIFx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG4gIFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuICBcdFx0XHR0aGlzLl9zaXplID0gbmV3IFBvaW50KFxyXG4gIFx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDAsXHJcbiAgXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDApO1xyXG5cclxuICBcdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW4gcHJvamVjdGVkIHBpeGVsXHJcbiAgXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG4gIFx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludChjZW50ZXIsIHpvb20pO1xyXG4gIFx0XHRyZXR1cm4gbmV3IEJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gVE9ETzogQ2hlY2sgc2VtYW50aWNzIC0gaXNuJ3QgdGhlIHBpeGVsIG9yaWdpbiB0aGUgMCwwIGNvb3JkIHJlbGF0aXZlIHRvXHJcbiAgXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcbiAgXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGl4ZWxPcmlnaW4oKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuICBcdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuICBcdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG4gIFx0Ly8gSWYgYHpvb21gIGlzIG9taXR0ZWQsIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwgaXMgdXNlZC5cclxuICBcdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgW21hcCBwYW5lXSgjbWFwLXBhbmUpLCBnaXZlbiBpdHMgbmFtZSBvciBpdHMgSFRNTCBlbGVtZW50IChpdHMgaWRlbnRpdHkpLlxyXG4gIFx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuICBcdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuICBcdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG4gIFx0Ly8gdGhlIHBhbmVzIGFzIHZhbHVlcy5cclxuICBcdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG4gIFx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBDb252ZXJzaW9uIE1ldGhvZHNcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuICBcdC8vIGBmcm9tWm9vbWAgdG8gYHRvWm9vbWAuIFVzZWQgaW50ZXJuYWxseSB0byBoZWxwIHdpdGggem9vbSBhbmltYXRpb25zLlxyXG4gIFx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG4gIFx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuICBcdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcbiAgXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuICBcdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcbiAgXHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxyXG4gIFx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcbiAgXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuICBcdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcbiAgXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuICBcdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xyXG4gIFx0XHRyZXR1cm4gaXNOYU4oem9vbSkgPyBJbmZpbml0eSA6IHpvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFByb2plY3RzIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgYExhdExuZ2AgYWNjb3JkaW5nIHRvIHRoZSBwcm9qZWN0aW9uXHJcbiAgXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuICBcdC8vIGBUcmFuc2Zvcm1hdGlvbmAuIFRoZSByZXN1bHQgaXMgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG4gIFx0Ly8gdGhlIENSUyBvcmlnaW4uXHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcbiAgXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludCh0b0xhdExuZyhsYXRsbmcpLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuICBcdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcbiAgXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyh0b1BvaW50KHBvaW50KSwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG4gIFx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuICBcdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuICBcdGxheWVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuICBcdC8vIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuICBcdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QodG9MYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcbiAgXHRcdHJldHVybiBwcm9qZWN0ZWRQb2ludC5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG4gIFx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcclxuICBcdC8vIENSUydzIGJvdW5kcy5cclxuICBcdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG4gIFx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcbiAgXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcodG9MYXRMbmcobGF0bG5nKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZyB0aGF0XHJcbiAgXHQvLyBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG4gIFx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIHRoZSBjZW50ZXIgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuICBcdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLCBhbmQgdGhlIG1ham9yaXR5IG9mIHRoZSBib3VuZHNcclxuICBcdC8vIG92ZXJsYXBzIHRoZSBDUlMncyBib3VuZHMuXHJcbiAgXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHModG9MYXRMbmdCb3VuZHMobGF0bG5nKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG9cclxuICBcdC8vIHRoZSBtYXAncyBDUlMuIEJ5IGRlZmF1bHQgdGhpcyBtZWFzdXJlcyBkaXN0YW5jZSBpbiBtZXRlcnMuXHJcbiAgXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UodG9MYXRMbmcobGF0bG5nMSksIHRvTGF0TG5nKGxhdGxuZzIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgXHQvLyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuICBcdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuICBcdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuICBcdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuICBcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG4gIFx0Ly8gdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuICBcdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodG9Qb2ludChwb2ludCkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuICBcdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG4gIFx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9Db250YWluZXJQb2ludCh0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludCh0b0xhdExuZyhsYXRsbmcpKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGVcclxuICBcdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcbiAgXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0cmV0dXJuIGdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuICBcdC8vIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuICBcdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG4gIFx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuICBcdC8vIGV2ZW50IHRvb2sgcGxhY2UuXHJcbiAgXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZ2V0KGlkKTtcclxuXHJcbiAgXHRcdGlmICghY29udGFpbmVyKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIG5vdCBmb3VuZC4nKTtcclxuICBcdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0b24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHN0YW1wKGNvbnRhaW5lcik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG4gIFx0XHR0aGlzLl9mYWRlQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiAmJiBCcm93c2VyLmFueTNkO1xyXG5cclxuICBcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuICBcdFx0XHQoQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG4gIFx0XHRcdChCcm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuICBcdFx0XHQoQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG4gIFx0XHRcdChCcm93c2VyLnNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuICBcdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuICBcdFx0dmFyIHBvc2l0aW9uID0gZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcbiAgXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJyAmJiBwb3NpdGlvbiAhPT0gJ3N0aWNreScpIHtcclxuICBcdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG4gIFx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG4gIFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvblxyXG4gIFx0XHQvL1xyXG4gIFx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG4gIFx0XHQvLyBjYW4gYWNjZXNzIHBhbmVzIHdpdGggW2BtYXAuZ2V0UGFuZWBdKCNtYXAtZ2V0cGFuZSkgb3JcclxuICBcdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuICBcdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG4gIFx0XHQvL1xyXG4gIFx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuICBcdFx0Ly9cclxuICBcdFx0Ly8gQHBhbmUgbWFwUGFuZTogSFRNTEVsZW1lbnQgPSAnYXV0bydcclxuICBcdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcbiAgXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuICBcdFx0Ly8gQHBhbmUgdGlsZVBhbmU6IEhUTUxFbGVtZW50ID0gMjAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgb3ZlcmxheVBhbmU6IEhUTUxFbGVtZW50ID0gNDAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIHZlY3RvcnMgKGBQYXRoYHMsIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHMpLCBgSW1hZ2VPdmVybGF5YHMgYW5kIGBWaWRlb092ZXJsYXlgc1xyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIHNoYWRvd1BhbmU6IEhUTUxFbGVtZW50ID0gNTAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIG92ZXJsYXkgc2hhZG93cyAoZS5nLiBgTWFya2VyYCBzaGFkb3dzKVxyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgbWFya2VyUGFuZTogSFRNTEVsZW1lbnQgPSA2MDBcclxuICBcdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIHRvb2x0aXBQYW5lOiBIVE1MRWxlbWVudCA9IDY1MFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgVG9vbHRpcGBzLlxyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIHBvcHVwUGFuZTogSFRNTEVsZW1lbnQgPSA3MDBcclxuICBcdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3MocGFuZXMubWFya2VyUGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcbiAgXHRcdFx0YWRkQ2xhc3MocGFuZXMuc2hhZG93UGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIHByaXZhdGUgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG4gIFx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcbiAgXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuICBcdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuICBcdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcbiAgXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG4gIFx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG4gIFx0XHR0aGlzXHJcbiAgXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KVxyXG4gIFx0XHRcdC5fbW92ZShjZW50ZXIsIHpvb20pXHJcbiAgXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBuZWVkcyB0byByZWRyYXcgaXRzIGNvbnRlbnQgKHRoaXMgdXN1YWxseSBoYXBwZW5zXHJcbiAgXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuICBcdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuICBcdFx0aWYgKGxvYWRpbmcpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcbiAgXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG4gIFx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICghbm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSwgc3VwcmVzc0V2ZW50KSB7XHJcbiAgXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuICBcdFx0fVxyXG4gIFx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuICBcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcbiAgXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBjZW50ZXI7XHJcbiAgXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcbiAgXHRcdGlmICghc3VwcmVzc0V2ZW50KSB7XHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLFxyXG4gIFx0XHRcdC8vIGluY2x1ZGluZyB6b29tIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuICBcdFx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcbiAgXHRcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLFxyXG4gIFx0XHRcdC8vIGluY2x1ZGluZyBwYW4gYW5kIGZseSBhbmltYXRpb25zLlxyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG4gIFx0XHR9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5waW5jaCkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcbiAgXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmdcclxuICBcdFx0Ly8gKGUuZy4gdXNlciBzdG9wcGVkIGRyYWdnaW5nIHRoZSBtYXAgb3IgYWZ0ZXIgbm9uLWNlbnRlcmVkIHpvb20pLlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuICBcdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuICBcdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcbiAgXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuICBcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG4gIFx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuICBcdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG4gIFx0XHR0aGlzLl90YXJnZXRzW3N0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcbiAgXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/IG9mZiA6IG9uO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuICBcdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG4gIFx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcbiAgXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcbiAgXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgdGhhdCBwcm9kdWNlcyBhIGNoYXJhY3RlciB2YWx1ZSB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcbiAgXHRcdC8vIEBldmVudCBrZXlkb3duOiBLZXlib2FyZEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuIFVubGlrZSB0aGUgYGtleXByZXNzYCBldmVudCxcclxuICBcdFx0Ly8gdGhlIGBrZXlkb3duYCBldmVudCBpcyBmaXJlZCBmb3Iga2V5cyB0aGF0IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUgYW5kIGZvciBrZXlzXHJcbiAgXHRcdC8vIHRoYXQgZG8gbm90IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUuXHJcbiAgXHRcdC8vIEBldmVudCBrZXl1cDogS2V5Ym9hcmRFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuICBcdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcbiAgXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3Mga2V5ZG93biBrZXl1cCcsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuICBcdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChCcm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcbiAgXHRcdFx0KHJlbW92ZSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuICBcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUoXHJcbiAgXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG4gIFx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcbiAgXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG4gIFx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvZGc2cjVoaGIvXHJcbiAgXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuICBcdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuICBcdFx0ICAgIHRhcmdldCxcclxuICBcdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG4gIFx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG4gIFx0XHQgICAgZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgXHRcdHdoaWxlIChzcmMpIHtcclxuICBcdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3N0YW1wKHNyYyldO1xyXG4gIFx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG4gIFx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcbiAgXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcbiAgXHRcdFx0XHRicmVhaztcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG4gIFx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIWlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG4gIFx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcbiAgXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuICBcdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiB0aGlzLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0YXJnZXRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaXNDbGlja0Rpc2FibGVkOiBmdW5jdGlvbiAoZWwpIHtcclxuICBcdFx0d2hpbGUgKGVsICYmIGVsICE9PSB0aGlzLl9jb250YWluZXIpIHtcclxuICBcdFx0XHRpZiAoZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gIFx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBlbCA9IChlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBlbFsnX2xlYWZsZXRfZGlzYWJsZV9ldmVudHMnXSB8fCBlLnR5cGUgPT09ICdjbGljaycgJiYgdGhpcy5faXNDbGlja0Rpc2FibGVkKGVsKSkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuICBcdFx0XHQvLyBwcmV2ZW50cyBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIGVsZW1lbnRcclxuICBcdFx0XHRwcmV2ZW50T3V0bGluZShlbCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuICBcdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCBjYW52YXNUYXJnZXRzKSB7XHJcblxyXG4gIFx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcbiAgXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG4gIFx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcbiAgXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuICBcdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuICBcdFx0XHR2YXIgc3ludGggPSBleHRlbmQoe30sIGUpO1xyXG4gIFx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG4gIFx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgY2FudmFzVGFyZ2V0cyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuICBcdFx0dmFyIHRhcmdldHMgPSB0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpO1xyXG5cclxuICBcdFx0aWYgKGNhbnZhc1RhcmdldHMpIHtcclxuICBcdFx0XHR2YXIgZmlsdGVyZWQgPSBbXTsgLy8gcGljayBvbmx5IHRhcmdldHMgd2l0aCBsaXN0ZW5lcnNcclxuICBcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbnZhc1RhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRcdGlmIChjYW52YXNUYXJnZXRzW2ldLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHRcdFx0ZmlsdGVyZWQucHVzaChjYW52YXNUYXJnZXRzW2ldKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0dGFyZ2V0cyA9IGZpbHRlcmVkLmNvbmNhdCh0YXJnZXRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnKSB7XHJcbiAgXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdO1xyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnICYmIGUudHlwZSAhPT0gJ2tleWRvd24nICYmIGUudHlwZSAhPT0gJ2tleXVwJykge1xyXG4gIFx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcbiAgXHRcdFx0ZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cclxuICBcdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuICBcdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG4gIFx0XHRcdGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuICBcdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcbiAgXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIGluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuICBcdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuICBcdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG4gIFx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcbiAgXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcbiAgXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuICBcdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBnZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG4gIFx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcbiAgXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcbiAgXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG4gIFx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcbiAgXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuICBcdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcbiAgXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuICBcdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcbiAgXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuICBcdFx0XSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG4gIFx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG4gIFx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcbiAgXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuICBcdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG4gIFx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuICBcdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcbiAgXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuICBcdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcbiAgXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgPD0gMSAmJiBNYXRoLmFicyhvZmZzZXQueSkgPD0gMSkge1xyXG4gIFx0XHRcdHJldHVybiBjZW50ZXI7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuICBcdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcbiAgXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcbiAgXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG4gIFx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG4gIFx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuICBcdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG4gIFx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcbiAgXHRcdCAgICApLFxyXG4gIFx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG4gIFx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuICBcdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuICBcdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoZHgsIGR5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG4gIFx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcbiAgXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcbiAgXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcbiAgXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcbiAgXHRcdGlmIChzbmFwKSB7XHJcbiAgXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG4gIFx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG4gIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX3RydW5jKCk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuICBcdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcbiAgXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuICBcdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdHZhciBwcm9wID0gVFJBTlNGT1JNLFxyXG4gIFx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcbiAgXHRcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuICBcdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG4gIFx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuICBcdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmUodGhpcy5fcHJveHkpO1xyXG4gIFx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcbiAgXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuICBcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuICBcdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcclxuICBcdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdFx0dGhpc1xyXG4gIFx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0IHx8IGZhbHNlKVxyXG4gIFx0XHRcdCAgICAuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgdHJ1ZSk7XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRydWU7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgc3RhcnRBbmltLCBub1VwZGF0ZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAoc3RhcnRBbmltKSB7XHJcbiAgXHRcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IHRydWU7XHJcblxyXG4gIFx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG4gIFx0XHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcclxuICBcdFx0XHR0aGlzLl9hbmltYXRlVG9ab29tID0gem9vbTtcclxuXHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIE90aGVyIEV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgem9vbWFuaW06IFpvb21BbmltRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgYXQgbGVhc3Qgb25jZSBwZXIgem9vbSBhbmltYXRpb24uIEZvciBjb250aW51b3VzIHpvb20sIGxpa2UgcGluY2ggem9vbWluZywgZmlyZWQgb25jZSBwZXIgZnJhbWUgZHVyaW5nIHpvb20uXHJcbiAgXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XHJcbiAgXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcbiAgXHRcdFx0em9vbTogem9vbSxcclxuICBcdFx0XHRub1VwZGF0ZTogbm9VcGRhdGVcclxuICBcdFx0fSk7XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50KSB7XHJcbiAgXHRcdFx0dGhpcy5fdGVtcEZpcmVab29tRXZlbnQgPSB0aGlzLl96b29tICE9PSB0aGlzLl9hbmltYXRlVG9ab29tO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuXHJcbiAgXHRcdC8vIFdvcmsgYXJvdW5kIHdlYmtpdCBub3QgZmlyaW5nICd0cmFuc2l0aW9uZW5kJywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzM2ODksIDI2OTNcclxuICBcdFx0c2V0VGltZW91dChiaW5kKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsIHRoaXMpLCAyNTApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwUGFuZSkge1xyXG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XHJcblxyXG4gIFx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbScpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl90ZW1wRmlyZVpvb21FdmVudDtcclxuXHJcbiAgXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuICBcdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQHNlY3Rpb25cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gdGhlIERPTSBJRCBvZiBhIGA8ZGl2PmAgZWxlbWVudFxyXG4gIC8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuICAvL1xyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubWFwKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4gIC8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuICBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgTWFwKGlkLCBvcHRpb25zKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgQ29udHJvbFxyXG4gICAqIEBha2EgTC5Db250cm9sXHJcbiAgICogQGluaGVyaXRzIENsYXNzXHJcbiAgICpcclxuICAgKiBMLkNvbnRyb2wgaXMgYSBiYXNlIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbWFwIGNvbnRyb2xzLiBIYW5kbGVzIHBvc2l0aW9uaW5nLlxyXG4gICAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gICAqL1xyXG5cclxuICB2YXIgQ29udHJvbCA9IENsYXNzLmV4dGVuZCh7XHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBDb250cm9sIE9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG4gIFx0XHQvLyBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgKG9uZSBvZiB0aGUgbWFwIGNvcm5lcnMpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAndG9wbGVmdCdgLFxyXG4gIFx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG4gIFx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvKiBAc2VjdGlvblxyXG4gIFx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcbiAgXHQgKlxyXG4gIFx0ICogQG1ldGhvZCBnZXRQb3NpdGlvbjogc3RyaW5nXHJcbiAgXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuICBcdCAqL1xyXG4gIFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcbiAgXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG4gIFx0XHRpZiAobWFwKSB7XHJcbiAgXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuICBcdFx0aWYgKG1hcCkge1xyXG4gIFx0XHRcdG1hcC5hZGRDb250cm9sKHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG4gIFx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkVG8obWFwOiBNYXApOiB0aGlzXHJcbiAgXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcbiAgXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLnJlbW92ZSgpO1xyXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG4gIFx0XHQgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG4gIFx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuICBcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG4gIFx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG4gIFx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX21hcC5vbigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG4gIFx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuICBcdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuICBcdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHQvLyBpZiBtYXAgZXhpc3RzIGFuZCBldmVudCBpcyBub3QgYSBrZXlib2FyZCBldmVudFxyXG4gIFx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgdmFyIGNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG4gIH07XHJcblxyXG4gIC8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAgICogQHVuaW5oZXJpdGFibGVcclxuICAgKlxyXG4gICAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAgICpcclxuICAgKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogSFRNTEVsZW1lbnRcclxuICAgKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICAgKlxyXG4gICAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApXHJcbiAgICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gICAqL1xyXG5cclxuICAvKiBAbmFtZXNwYWNlIE1hcFxyXG4gICAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICAgKi9cclxuICBNYXAuaW5jbHVkZSh7XHJcbiAgXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG4gIFx0YWRkQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICBcdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuICBcdHJlbW92ZUNvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG4gIFx0XHQgICAgbCA9ICdsZWFmbGV0LScsXHJcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuICBcdFx0ICAgICAgICAgICAgY3JlYXRlJDEoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuICBcdFx0ZnVuY3Rpb24gY3JlYXRlQ29ybmVyKHZTaWRlLCBoU2lkZSkge1xyXG4gIFx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG4gIFx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcbiAgXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcbiAgXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuICBcdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2NvbnRyb2xDb3JuZXJzKSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX2NvbnRyb2xDb3JuZXJzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29ybmVycztcclxuICBcdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb250YWluZXI7XHJcbiAgXHR9XHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICAgKiBAYWthIEwuQ29udHJvbC5MYXllcnNcclxuICAgKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gICAqXHJcbiAgICogVGhlIGxheWVycyBjb250cm9sIGdpdmVzIHVzZXJzIHRoZSBhYmlsaXR5IHRvIHN3aXRjaCBiZXR3ZWVuIGRpZmZlcmVudCBiYXNlIGxheWVycyBhbmQgc3dpdGNoIG92ZXJsYXlzIG9uL29mZiAoY2hlY2sgb3V0IHRoZSBbZGV0YWlsZWQgZXhhbXBsZV0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2xheWVycy1jb250cm9sLykpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBiYXNlTGF5ZXJzID0ge1xyXG4gICAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gICAqIFx0XCJPcGVuU3RyZWV0TWFwXCI6IG9zbVxyXG4gICAqIH07XHJcbiAgICpcclxuICAgKiB2YXIgb3ZlcmxheXMgPSB7XHJcbiAgICogXHRcIk1hcmtlclwiOiBtYXJrZXIsXHJcbiAgICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICAgKiB9O1xyXG4gICAqXHJcbiAgICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICoge1xyXG4gICAqICAgICBcIjxzb21lTmFtZTE+XCI6IGxheWVyMSxcclxuICAgKiAgICAgXCI8c29tZU5hbWUyPlwiOiBsYXllcjJcclxuICAgKiB9XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIExheWVycyA9IENvbnRyb2wuZXh0ZW5kKHtcclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIENvbnRyb2wuTGF5ZXJzIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBjb2xsYXBzZWQ6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBiZSBjb2xsYXBzZWQgaW50byBhbiBpY29uIGFuZCBleHBhbmRlZCBvbiBtb3VzZSBob3ZlciwgdG91Y2gsIG9yIGtleWJvYXJkIGFjdGl2YXRpb24uXHJcbiAgXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuICBcdFx0cG9zaXRpb246ICd0b3ByaWdodCcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9aSW5kZXg6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcbiAgXHRcdGF1dG9aSW5kZXg6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGhpZGVTaW5nbGVCYXNlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuICBcdFx0aGlkZVNpbmdsZUJhc2U6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzb3J0TGF5ZXJzOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuICBcdFx0Ly8gaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkIHRvIHRoZSBjb250cm9sLlxyXG4gIFx0XHRzb3J0TGF5ZXJzOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuICBcdFx0Ly8gQSBbY29tcGFyZSBmdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydClcclxuICBcdFx0Ly8gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHNvcnRpbmcgdGhlIGxheWVycywgd2hlbiBgc29ydExheWVyc2AgaXMgYHRydWVgLlxyXG4gIFx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcbiAgXHRcdC8vIGBzb3J0RnVuY3Rpb24obGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQilgLlxyXG4gIFx0XHQvLyBCeSBkZWZhdWx0LCBpdCBzb3J0cyBsYXllcnMgYWxwaGFiZXRpY2FsbHkgYnkgdGhlaXIgbmFtZS5cclxuICBcdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG4gIFx0XHRcdHJldHVybiBuYW1lQSA8IG5hbWVCID8gLTEgOiAobmFtZUIgPCBuYW1lQSA/IDEgOiAwKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGFzdFpJbmRleCA9IDA7XHJcbiAgXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuICBcdFx0dGhpcy5fcHJldmVudENsaWNrID0gZmFsc2U7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuICBcdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcbiAgXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcbiAgXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuICBcdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcbiAgXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG4gIFx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcbiAgXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG4gIFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAobGF5ZXIpKTtcclxuICBcdFx0aWYgKG9iaikge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcbiAgXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuICBcdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcbiAgXHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuICBcdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuICBcdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG4gIFx0XHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcbiAgXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcbiAgXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXHJcbiAgXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuICBcdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG4gIFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG4gIFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG4gIFx0XHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbiA9IGNyZWF0ZSQxKCdzZWN0aW9uJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG4gIFx0XHRpZiAoY29sbGFwc2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuICBcdFx0XHRvbihjb250YWluZXIsIHtcclxuICBcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuX2V4cGFuZFNhZmVseSxcclxuICBcdFx0XHRcdG1vdXNlbGVhdmU6IHRoaXMuY29sbGFwc2VcclxuICBcdFx0XHR9LCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gY3JlYXRlJDEoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcbiAgXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuICBcdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG4gIFx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHJcbiAgXHRcdG9uKGxpbmssIHtcclxuICBcdFx0XHRrZXlkb3duOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcclxuICBcdFx0XHRcdFx0dGhpcy5fZXhwYW5kU2FmZWx5KCk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fSxcclxuICBcdFx0XHQvLyBDZXJ0YWluIHNjcmVlbiByZWFkZXJzIGludGVyY2VwdCB0aGUga2V5IGV2ZW50IGFuZCBpbnN0ZWFkIHNlbmQgYSBjbGljayBldmVudFxyXG4gIFx0XHRcdGNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XHJcbiAgXHRcdFx0XHR0aGlzLl9leHBhbmRTYWZlbHkoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG5cclxuICBcdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuICBcdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBzZWN0aW9uKTtcclxuICBcdFx0dGhpcy5fc2VwYXJhdG9yID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgc2VjdGlvbik7XHJcbiAgXHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUgKyAnLW92ZXJsYXlzJywgc2VjdGlvbik7XHJcblxyXG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gIFx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lLCBvdmVybGF5KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcbiAgXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG4gIFx0XHRcdG5hbWU6IG5hbWUsXHJcbiAgXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG4gIFx0XHR9KTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuc29ydExheWVycykge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVycy5zb3J0KGJpbmQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuICBcdFx0XHR9LCB0aGlzKSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuICBcdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcbiAgXHRcdFx0bGF5ZXIuc2V0WkluZGV4KHRoaXMuX2xhc3RaSW5kZXgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRlbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcbiAgXHRcdGVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuICBcdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRvYmogPSB0aGlzLl9sYXllcnNbaV07XHJcbiAgXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG4gIFx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuICBcdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50IHx8ICFvYmoub3ZlcmxheTtcclxuICBcdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEhpZGUgYmFzZSBsYXllcnMgc2VjdGlvbiBpZiB0aGVyZSdzIG9ubHkgb25lIGxheWVyLlxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcbiAgXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG4gIFx0XHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0LnN0eWxlLmRpc3BsYXkgPSBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2hhbmRsaW5nQ2xpY2spIHtcclxuICBcdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKHN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIFx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGJhc2UgbGF5ZXIgaXMgY2hhbmdlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcbiAgXHRcdC8vIEBldmVudCBvdmVybGF5YWRkOiBMYXllcnNDb250cm9sRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQGV2ZW50IG92ZXJsYXlyZW1vdmU6IExheWVyc0NvbnRyb2xFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuICBcdFx0dmFyIHR5cGUgPSBvYmoub3ZlcmxheSA/XHJcbiAgXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuICBcdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG4gIFx0XHRpZiAodHlwZSkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE5MDc5KVxyXG4gIFx0X2NyZWF0ZVJhZGlvRWxlbWVudDogZnVuY3Rpb24gKG5hbWUsIGNoZWNrZWQpIHtcclxuXHJcbiAgXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuICBcdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcbiAgXHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuICBcdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuICBcdFx0ICAgIGNoZWNrZWQgPSB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSxcclxuICBcdFx0ICAgIGlucHV0O1xyXG5cclxuICBcdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcbiAgXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gIFx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG4gIFx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuICBcdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnNfJyArIHN0YW1wKHRoaXMpLCBjaGVja2VkKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLnB1c2goaW5wdXQpO1xyXG4gIFx0XHRpbnB1dC5sYXllcklkID0gc3RhbXAob2JqLmxheWVyKTtcclxuXHJcbiAgXHRcdG9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuICBcdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG4gIFx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG4gIFx0XHR2YXIgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cclxuICBcdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaG9sZGVyKTtcclxuICBcdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuICBcdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IG9iai5vdmVybGF5ID8gdGhpcy5fb3ZlcmxheXNMaXN0IDogdGhpcy5fYmFzZUxheWVyc0xpc3Q7XHJcbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG4gIFx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcbiAgXHRcdHJldHVybiBsYWJlbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBleHBhbmRpbmcgdGhlIGNvbnRyb2wgb24gbW9iaWxlIHdpdGggYSBjbGljayBjYW4gY2F1c2UgYWRkaW5nIGEgbGF5ZXIgLSB3ZSBkb24ndCB3YW50IHRoaXNcclxuICBcdFx0aWYgKHRoaXMuX3ByZXZlbnRDbGljaykge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuICBcdFx0ICAgIGlucHV0LCBsYXllcjtcclxuICBcdFx0dmFyIGFkZGVkTGF5ZXJzID0gW10sXHJcbiAgXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG4gIFx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICBcdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cclxuICBcdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCkge1xyXG4gIFx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcbiAgXHRcdFx0fSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCkge1xyXG4gIFx0XHRcdFx0cmVtb3ZlZExheWVycy5wdXNoKGxheWVyKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEJ1Z2ZpeCBpc3N1ZSAyMzE4OiBTaG91bGQgcmVtb3ZlIGFsbCBvbGQgbGF5ZXJzIGJlZm9yZSByZWFkZGluZyBuZXcgb25lc1xyXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIocmVtb3ZlZExheWVyc1tpXSkpIHtcclxuICBcdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihyZW1vdmVkTGF5ZXJzW2ldKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IGFkZGVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0aWYgKCF0aGlzLl9tYXAuaGFzTGF5ZXIoYWRkZWRMYXllcnNbaV0pKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIoYWRkZWRMYXllcnNbaV0pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuICBcdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jaGVja0Rpc2FibGVkTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcbiAgXHRcdCAgICBpbnB1dCxcclxuICBcdFx0ICAgIGxheWVyLFxyXG4gIFx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuICBcdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG4gIFx0XHRcdCAgICAgICAgICAgICAgICAgKGxheWVyLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPiBsYXllci5vcHRpb25zLm1heFpvb20pO1xyXG5cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfZXhwYW5kSWZOb3RDb2xsYXBzZWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG4gIFx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9leHBhbmRTYWZlbHk6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uO1xyXG4gIFx0XHR0aGlzLl9wcmV2ZW50Q2xpY2sgPSB0cnVlO1xyXG4gIFx0XHRvbihzZWN0aW9uLCAnY2xpY2snLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgXHRcdHRoaXMuZXhwYW5kKCk7XHJcbiAgXHRcdHZhciB0aGF0ID0gdGhpcztcclxuICBcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdFx0b2ZmKHNlY3Rpb24sICdjbGljaycsIHByZXZlbnREZWZhdWx0KTtcclxuICBcdFx0XHR0aGF0Ll9wcmV2ZW50Q2xpY2sgPSBmYWxzZTtcclxuICBcdFx0fSk7XHJcbiAgXHR9XHJcblxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhIGxheWVycyBjb250cm9sIHdpdGggdGhlIGdpdmVuIGxheWVycy4gQmFzZSBsYXllcnMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIHJhZGlvIGJ1dHRvbnMsIHdoaWxlIG92ZXJsYXlzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCBjaGVja2JveGVzLiBOb3RlIHRoYXQgYWxsIGJhc2UgbGF5ZXJzIHNob3VsZCBiZSBwYXNzZWQgaW4gdGhlIGJhc2UgbGF5ZXJzIG9iamVjdCwgYnV0IG9ubHkgb25lIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFwIGR1cmluZyBtYXAgaW5zdGFudGlhdGlvbi5cclxuICB2YXIgbGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IExheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICAgKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAgICogQGluaGVyaXRzIENvbnRyb2xcclxuICAgKlxyXG4gICAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICAgKi9cclxuXHJcbiAgdmFyIFpvb20gPSBDb250cm9sLmV4dGVuZCh7XHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nXHJcbiAgXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuICBcdFx0em9vbUluVGV4dDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPis8L3NwYW4+JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG4gIFx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG4gIFx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPidcclxuICBcdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuICBcdFx0em9vbU91dFRleHQ6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mI3gyMjEyOzwvc3Bhbj4nLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuICBcdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcbiAgXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG4gIFx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG4gIFx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcbiAgXHRcdHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tT3V0VGV4dCwgb3B0aW9ucy56b29tT3V0VGl0bGUsXHJcbiAgXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG4gIFx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG4gIFx0XHRtYXAub24oJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiBjb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcclxuICBcdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC56b29tSW4odGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF96b29tT3V0OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuICBcdFx0dmFyIGxpbmsgPSBjcmVhdGUkMSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuICBcdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG4gIFx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcbiAgXHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcclxuXHJcbiAgXHRcdC8qXHJcbiAgXHRcdCAqIFdpbGwgZm9yY2Ugc2NyZWVuIHJlYWRlcnMgbGlrZSBWb2ljZU92ZXIgdG8gcmVhZCB0aGlzIGFzIFwiWm9vbSBpbiAtIGJ1dHRvblwiXHJcbiAgXHRcdCAqL1xyXG4gIFx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuICBcdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcblxyXG4gIFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihsaW5rKTtcclxuICBcdFx0b24obGluaywgJ2NsaWNrJywgc3RvcCk7XHJcbiAgXHRcdG9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKTtcclxuICBcdFx0b24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiBsaW5rO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuICBcdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICBcdFx0dGhpcy5fem9vbUluQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xyXG4gIFx0XHR0aGlzLl96b29tT3V0QnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdFx0dGhpcy5fem9vbU91dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdFx0dGhpcy5fem9vbUluQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBNYXBcclxuICAvLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuICAvLyBAb3B0aW9uIHpvb21Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4gIC8vIFdoZXRoZXIgYSBbem9vbSBjb250cm9sXSgjY29udHJvbC16b29tKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XHJcbiAgXHR6b29tQ29udHJvbDogdHJ1ZVxyXG4gIH0pO1xyXG5cclxuICBNYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG4gIFx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG4gIFx0XHQvLyBAc2VjdGlvbiBDb250cm9sc1xyXG4gIFx0XHQvLyBAcHJvcGVydHkgem9vbUNvbnRyb2w6IENvbnRyb2wuWm9vbVxyXG4gIFx0XHQvLyBUaGUgZGVmYXVsdCB6b29tIGNvbnRyb2wgKG9ubHkgYXZhaWxhYmxlIGlmIHRoZVxyXG4gIFx0XHQvLyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHdhcyBgdHJ1ZWAgd2hlbiBjcmVhdGluZyB0aGUgbWFwKS5cclxuICBcdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcbiAgXHRcdHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBDb250cm9sLlpvb21cclxuICAvLyBAZmFjdG9yeSBMLmNvbnRyb2wuem9vbShvcHRpb25zOiBDb250cm9sLlpvb20gb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbiAgdmFyIHpvb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBab29tKG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcbiAgICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAgICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAgICogQGluaGVyaXRzIENvbnRyb2xcbiAgICpcbiAgICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIENvbnRyb2wuU2NhbGUgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDEwMFxuICBcdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG4gIFx0XHRtYXhXaWR0aDogMTAwLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1ldHJpYzogQm9vbGVhbiA9IFRydWVcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuICBcdFx0bWV0cmljOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGltcGVyaWFsOiBCb29sZWFuID0gVHJ1ZVxuICBcdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG4gIFx0XHRpbXBlcmlhbDogdHJ1ZVxuXG4gIFx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cbiAgXHR9LFxuXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcbiAgXHRcdCAgICBjb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKSxcbiAgXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIFx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuICBcdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gIFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cbiAgXHRcdHJldHVybiBjb250YWluZXI7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcbiAgXHRcdFx0dGhpcy5fbVNjYWxlID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcbiAgXHRcdH1cbiAgXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG4gIFx0XHRcdHRoaXMuX2lTY2FsZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cbiAgXHRcdHZhciBtYXhNZXRlcnMgPSBtYXAuZGlzdGFuY2UoXG4gIFx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG4gIFx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm1ldHJpYyAmJiBtYXhNZXRlcnMpIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG4gIFx0XHR9XG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmltcGVyaWFsICYmIG1heE1ldGVycykge1xuICBcdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG4gIFx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcbiAgXHRcdCAgICBsYWJlbCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xuICBcdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG4gIFx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG4gIFx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcbiAgXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcbiAgXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgbWlsZXMgKyAnIG1pJywgbWlsZXMgLyBtYXhNaWxlcyk7XG5cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBmZWV0ICsgJyBmdCcsIGZlZXQgLyBtYXhGZWV0KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUsIHRleHQsIHJhdGlvKSB7XG4gIFx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4JztcbiAgXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG4gIFx0fSxcblxuICBcdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuICBcdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG4gIFx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG4gIFx0XHRkID0gZCA+PSAxMCA/IDEwIDpcbiAgXHRcdCAgICBkID49IDUgPyA1IDpcbiAgXHRcdCAgICBkID49IDMgPyAzIDpcbiAgXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuICBcdFx0cmV0dXJuIHBvdzEwICogZDtcbiAgXHR9XG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4gIC8vIENyZWF0ZXMgYW4gc2NhbGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICB2YXIgc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgU2NhbGUob3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIHVrcmFpbmlhbkZsYWcgPSAnPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjhcIiB2aWV3Qm94PVwiMCAwIDEyIDhcIiBjbGFzcz1cImxlYWZsZXQtYXR0cmlidXRpb24tZmxhZ1wiPjxwYXRoIGZpbGw9XCIjNEM3QkUxXCIgZD1cIk0wIDBoMTJ2NEgwelwiLz48cGF0aCBmaWxsPVwiI0ZGRDUwMFwiIGQ9XCJNMCA0aDEydjNIMHpcIi8+PHBhdGggZmlsbD1cIiNFMEJDMDBcIiBkPVwiTTAgN2gxMnYxSDB6XCIvPjwvc3ZnPic7XHJcblxyXG5cclxuICAvKlxyXG4gICAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuQXR0cmlidXRpb25cclxuICAgKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gICAqXHJcbiAgICogVGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wgYWxsb3dzIHlvdSB0byBkaXNwbGF5IGF0dHJpYnV0aW9uIGRhdGEgaW4gYSBzbWFsbCB0ZXh0IGJveCBvbiBhIG1hcC4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2BhdHRyaWJ1dGlvbkNvbnRyb2xgIG9wdGlvbl0oI21hcC1hdHRyaWJ1dGlvbmNvbnRyb2wpIHRvIGBmYWxzZWAsIGFuZCBpdCBmZXRjaGVzIGF0dHJpYnV0aW9uIHRleHRzIGZyb20gbGF5ZXJzIHdpdGggdGhlIFtgZ2V0QXR0cmlidXRpb25gIG1ldGhvZF0oI2xheWVyLWdldGF0dHJpYnV0aW9uKSBhdXRvbWF0aWNhbGx5LiBFeHRlbmRzIENvbnRyb2wuXHJcbiAgICovXHJcblxyXG4gIHZhciBBdHRyaWJ1dGlvbiA9IENvbnRyb2wuZXh0ZW5kKHtcclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmd8ZmFsc2UgPSAnTGVhZmxldCdcclxuICBcdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcbiAgXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwczovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+JyArIChCcm93c2VyLmlubGluZVN2ZyA/IHVrcmFpbmlhbkZsYWcgKyAnICcgOiAnJykgKyAnTGVhZmxldDwvYT4nXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uJyk7XHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG4gIFx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuICBcdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuICBcdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgXHRcdG1hcC5vbignbGF5ZXJhZGQnLCB0aGlzLl9hZGRBdHRyaWJ1dGlvbiwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAub2ZmKCdsYXllcmFkZCcsIHRoaXMuX2FkZEF0dHJpYnV0aW9uLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoZXYpIHtcclxuICBcdFx0aWYgKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKSB7XHJcbiAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihldi5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuICBcdFx0XHRldi5sYXllci5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdFx0XHR0aGlzLnJlbW92ZUF0dHJpYnV0aW9uKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG4gIFx0XHRcdH0sIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nfGZhbHNlKTogdGhpc1xyXG4gIFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcbiAgXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICBcdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIEFkZHMgYW4gYXR0cmlidXRpb24gdGV4dCAoZS5nLiBgJyZjb3B5OyBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9ycydgKS5cclxuICBcdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG4gIFx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG4gIFx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG4gIFx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG4gIFx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuICBcdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG4gIFx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuICBcdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnw8L3NwYW4+ICcpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIC8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4gIC8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4gIC8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuICBNYXAubWVyZ2VPcHRpb25zKHtcclxuICBcdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG4gIH0pO1xyXG5cclxuICBNYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG4gIFx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuICBcdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5hdHRyaWJ1dGlvbihvcHRpb25zOiBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG4gIHZhciBhdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG4gIENvbnRyb2wuWm9vbSA9IFpvb207XG4gIENvbnRyb2wuU2NhbGUgPSBTY2FsZTtcbiAgQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG4gIGNvbnRyb2wubGF5ZXJzID0gbGF5ZXJzO1xuICBjb250cm9sLnpvb20gPSB6b29tO1xuICBjb250cm9sLnNjYWxlID0gc2NhbGU7XG4gIGNvbnRyb2wuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcblxuICAvKlxuICBcdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG4gIFx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4gICovXG5cbiAgLy8gQGNsYXNzIEhhbmRsZXJcbiAgLy8gQGFrYSBMLkhhbmRsZXJcbiAgLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG4gIHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcbiAgXHQvLyBFbmFibGVzIHRoZSBoYW5kbGVyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG4gIFx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgXHRcdHRoaXMuYWRkSG9va3MoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuICBcdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG4gIFx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGVuYWJsZWQoKTogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcbiAgXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuICBcdH1cblxuICBcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gIFx0Ly8gQ2xhc3NlcyBpbmhlcml0aW5nIGZyb20gYEhhbmRsZXJgIG11c3QgaW1wbGVtZW50IHRoZSB0d28gZm9sbG93aW5nIG1ldGhvZHM6XG4gIFx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG4gIFx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKClcbiAgXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gVGhlcmUgaXMgc3RhdGljIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuSGFuZGxlcjpcbiAgLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4gIC8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gIEhhbmRsZXIuYWRkVG8gPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG4gIFx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG4gIFx0cmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIE1peGluID0ge0V2ZW50czogRXZlbnRzfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICAgKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICAgKlxyXG4gICAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAgICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICAgKiB0aGF0IHdlcmUgcG9zaXRpb25lZCB3aXRoIFtgTC5Eb21VdGlsLnNldFBvc2l0aW9uYF0oI2RvbXV0aWwtc2V0cG9zaXRpb24pLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAgICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG5cclxuICB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQHNlY3Rpb25cclxuICBcdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcbiAgXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcbiAgXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuICBcdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuICBcdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUsIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG4gIFx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuICBcdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG4gIFx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0b24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG4gIFx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuICBcdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG4gIFx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuICBcdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuICBcdFx0XHR0aGlzLmZpbmlzaERyYWcodHJ1ZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG4gIFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcbiAgXHRcdGlmIChoYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xyXG4gIFx0XHRcdC8vIEZpbmlzaCBkcmFnZ2luZyB0byBhdm9pZCBjb25mbGljdCB3aXRoIHRvdWNoWm9vbVxyXG4gIFx0XHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuICBcdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG4gIFx0XHRcdHByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XHJcbiAgXHRcdGRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcbiAgXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXHJcbiAgXHRcdCAgICBzaXplZFBhcmVudCA9IGdldFNpemVkUGFyZW50Tm9kZSh0aGlzLl9lbGVtZW50KTtcclxuXHJcbiAgXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcbiAgXHRcdHRoaXMuX3N0YXJ0UG9zID0gZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCk7XHJcblxyXG4gIFx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcbiAgXHRcdHRoaXMuX3BhcmVudFNjYWxlID0gZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuICBcdFx0dmFyIG1vdXNlZXZlbnQgPSBlLnR5cGUgPT09ICdtb3VzZWRvd24nO1xyXG4gIFx0XHRvbihkb2N1bWVudCwgbW91c2VldmVudCA/ICdtb3VzZW1vdmUnIDogJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcbiAgXHRcdG9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcbiAgXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuICBcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuICBcdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG4gIFx0XHQvLyBhbmQgd2UgY2FuIHVzZSB0aGUgY2FjaGVkIHZhbHVlIGZvciB0aGUgc2NhbGUuXHJcbiAgXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcbiAgXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuICBcdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHJcbiAgXHRcdFx0YWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcbiAgXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuICBcdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuICBcdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuICBcdFx0XHRpZiAod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSAmJiB0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG4gIFx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuICBcdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuICBcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuICBcdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcbiAgXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcbiAgXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25VcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG4gIFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG4gIFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKG5vSW5lcnRpYSkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG4gIFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUgdG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuICBcdFx0b2ZmKGRvY3VtZW50LCAnbW91c2V1cCB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cclxuICBcdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XHJcbiAgXHRcdGVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcbiAgXHRcdHZhciBmaXJlRHJhZ2VuZCA9IHRoaXMuX21vdmVkICYmIHRoaXMuX21vdmluZztcclxuXHJcbiAgXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG4gIFx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gIFx0XHRpZiAoZmlyZURyYWdlbmQpIHtcclxuICBcdFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG4gIFx0XHRcdHRoaXMuZmlyZSgnZHJhZ2VuZCcsIHtcclxuICBcdFx0XHRcdG5vSW5lcnRpYTogbm9JbmVydGlhLFxyXG4gIFx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gICAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICAgKi9cclxuXHJcbiAgLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICAgKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gICAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAgICogcGVyZm9ybWFuY2UuIE5vdGUgdGhhdCBwb2x5Z29uIHBvaW50cyBuZWVkcyBkaWZmZXJlbnQgYWxnb3JpdGhtIGZvciBjbGlwcGluZ1xyXG4gICAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG4gIFx0dmFyIGNsaXBwZWRQb2ludHMsXHJcbiAgXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcbiAgXHQgICAgaSwgaiwgayxcclxuICBcdCAgICBhLCBiLFxyXG4gIFx0ICAgIGxlbiwgZWRnZSwgcDtcclxuXHJcbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0cG9pbnRzW2ldLl9jb2RlID0gX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuICBcdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuICBcdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG4gIFx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG4gIFx0XHRcdGEgPSBwb2ludHNbaV07XHJcbiAgXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcbiAgXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcbiAgXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcbiAgXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuICBcdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG4gIFx0XHRcdFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcbiAgXHRcdFx0XHRcdHAuX2NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG4gIFx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG4gIFx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG4gIFx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuICBcdFx0XHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuICBcdFx0XHRcdHAuX2NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG4gIFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRwb2ludHMgPSBjbGlwcGVkUG9pbnRzO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBwb2ludHM7XHJcbiAgfVxyXG5cclxuICAvKiBAZnVuY3Rpb24gcG9seWdvbkNlbnRlcihsYXRsbmdzOiBMYXRMbmdbXSwgY3JzOiBDUlMpOiBMYXRMbmdcclxuICAgKiBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwYXNzZWQgTGF0TG5ncyAoZmlyc3QgcmluZykgZnJvbSBhIHBvbHlnb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcG9seWdvbkNlbnRlcihsYXRsbmdzLCBjcnMpIHtcclxuICBcdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcjtcclxuXHJcbiAgXHRpZiAoIWxhdGxuZ3MgfHwgbGF0bG5ncy5sZW5ndGggPT09IDApIHtcclxuICBcdFx0dGhyb3cgbmV3IEVycm9yKCdsYXRsbmdzIG5vdCBwYXNzZWQnKTtcclxuICBcdH1cclxuXHJcbiAgXHRpZiAoIWlzRmxhdChsYXRsbmdzKSkge1xyXG4gIFx0XHRjb25zb2xlLndhcm4oJ2xhdGxuZ3MgYXJlIG5vdCBmbGF0ISBPbmx5IHRoZSBmaXJzdCByaW5nIHdpbGwgYmUgdXNlZCcpO1xyXG4gIFx0XHRsYXRsbmdzID0gbGF0bG5nc1swXTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgY2VudHJvaWRMYXRMbmcgPSB0b0xhdExuZyhbMCwgMF0pO1xyXG5cclxuICBcdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRsbmdzKTtcclxuICBcdHZhciBhcmVhQm91bmRzID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldFNvdXRoV2VzdCgpKSAqIGJvdW5kcy5nZXROb3J0aEVhc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXROb3J0aFdlc3QoKSk7XHJcbiAgXHQvLyB0ZXN0cyBzaG93ZWQgdGhhdCBiZWxvdyAxNzAwIHJvdW5kaW5nIGVycm9ycyBhcmUgaGFwcGVuaW5nXHJcbiAgXHRpZiAoYXJlYUJvdW5kcyA8IDE3MDApIHtcclxuICBcdFx0Ly8gZ2V0dGluZyBhIGluZXhhY3QgY2VudGVyLCB0byBtb3ZlIHRoZSBsYXRsbmdzIG5lYXIgdG8gWzAsIDBdIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzXHJcbiAgXHRcdGNlbnRyb2lkTGF0TG5nID0gY2VudHJvaWQobGF0bG5ncyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIGxlbiA9IGxhdGxuZ3MubGVuZ3RoO1xyXG4gIFx0dmFyIHBvaW50cyA9IFtdO1xyXG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdHZhciBsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcclxuICBcdFx0cG9pbnRzLnB1c2goY3JzLnByb2plY3QodG9MYXRMbmcoW2xhdGxuZy5sYXQgLSBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZy5sbmcgLSBjZW50cm9pZExhdExuZy5sbmddKSkpO1xyXG4gIFx0fVxyXG5cclxuICBcdGFyZWEgPSB4ID0geSA9IDA7XHJcblxyXG4gIFx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07XHJcbiAgXHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG4gIFx0XHRwMSA9IHBvaW50c1tpXTtcclxuICBcdFx0cDIgPSBwb2ludHNbal07XHJcblxyXG4gIFx0XHRmID0gcDEueSAqIHAyLnggLSBwMi55ICogcDEueDtcclxuICBcdFx0eCArPSAocDEueCArIHAyLngpICogZjtcclxuICBcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcclxuICBcdFx0YXJlYSArPSBmICogMztcclxuICBcdH1cclxuXHJcbiAgXHRpZiAoYXJlYSA9PT0gMCkge1xyXG4gIFx0XHQvLyBQb2x5Z29uIGlzIHNvIHNtYWxsIHRoYXQgYWxsIHBvaW50cyBhcmUgb24gc2FtZSBwaXhlbC5cclxuICBcdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0Y2VudGVyID0gW3ggLyBhcmVhLCB5IC8gYXJlYV07XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIGxhdGxuZ0NlbnRlciA9IGNycy51bnByb2plY3QodG9Qb2ludChjZW50ZXIpKTtcclxuICBcdHJldHVybiB0b0xhdExuZyhbbGF0bG5nQ2VudGVyLmxhdCArIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nQ2VudGVyLmxuZyArIGNlbnRyb2lkTGF0TG5nLmxuZ10pO1xyXG4gIH1cclxuXHJcbiAgLyogQGZ1bmN0aW9uIGNlbnRyb2lkKGxhdGxuZ3M6IExhdExuZ1tdKTogTGF0TG5nXHJcbiAgICogUmV0dXJucyB0aGUgJ2NlbnRlciBvZiBtYXNzJyBvZiB0aGUgcGFzc2VkIExhdExuZ3MuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2VudHJvaWQoY29vcmRzKSB7XHJcbiAgXHR2YXIgbGF0U3VtID0gMDtcclxuICBcdHZhciBsbmdTdW0gPSAwO1xyXG4gIFx0dmFyIGxlbiA9IDA7XHJcbiAgXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcoY29vcmRzW2ldKTtcclxuICBcdFx0bGF0U3VtICs9IGxhdGxuZy5sYXQ7XHJcbiAgXHRcdGxuZ1N1bSArPSBsYXRsbmcubG5nO1xyXG4gIFx0XHRsZW4rKztcclxuICBcdH1cclxuICBcdHJldHVybiB0b0xhdExuZyhbbGF0U3VtIC8gbGVuLCBsbmdTdW0gLyBsZW5dKTtcclxuICB9XG5cbiAgdmFyIFBvbHlVdGlsID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjbGlwUG9seWdvbjogY2xpcFBvbHlnb24sXG4gICAgcG9seWdvbkNlbnRlcjogcG9seWdvbkNlbnRlcixcbiAgICBjZW50cm9pZDogY2VudHJvaWRcbiAgfTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgTGluZVV0aWxcclxuICAgKlxyXG4gICAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlsaW5lIHBvaW50cyBwcm9jZXNzaW5nLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBtYWtlIHBvbHlsaW5lcyBsaWdodG5pbmctZmFzdC5cclxuICAgKi9cclxuXHJcbiAgLy8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcbiAgLy8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50czogUG9pbnRbXSwgdG9sZXJhbmNlOiBOdW1iZXIpOiBQb2ludFtdXHJcbiAgLy8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuICAvLyBpdHMgc2hhcGUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2ltcGxpZmllZCBwb2ludHMsIHVzaW5nIHRoZVxyXG4gIC8vIFtSYW1lci1Eb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtKS5cclxuICAvLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcbiAgLy8gZWFjaCB6b29tIGxldmVsIGFuZCBhbHNvIHJlZHVjaW5nIHZpc3VhbCBub2lzZS4gdG9sZXJhbmNlIGFmZmVjdHMgdGhlIGFtb3VudCBvZlxyXG4gIC8vIHNpbXBsaWZpY2F0aW9uIChsZXNzZXIgdmFsdWUgbWVhbnMgaGlnaGVyIHF1YWxpdHkgYnV0IHNsb3dlciBhbmQgd2l0aCBtb3JlIHBvaW50cykuXHJcbiAgLy8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cHM6Ly9tb3VybmVyLmdpdGh1Yi5pby9zaW1wbGlmeS1qcy8pLlxyXG4gIGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XHJcbiAgXHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG4gIFx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuICBcdCAgICAvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcbiAgXHQgICAgcG9pbnRzID0gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcbiAgXHQgICAgLy8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcbiAgXHQgICAgcG9pbnRzID0gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG4gIFx0cmV0dXJuIHBvaW50cztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4gIC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgYHBgIGFuZCBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuICBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHAxLCBwMikge1xyXG4gIFx0cmV0dXJuIE1hdGguc3FydChfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4gIC8vIFJldHVybnMgdGhlIGNsb3Nlc3QgcG9pbnQgZnJvbSBhIHBvaW50IGBwYCBvbiBhIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG4gIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpIHtcclxuICBcdHJldHVybiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKTtcclxuICB9XHJcblxyXG4gIC8vIFJhbWVyLURvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuICBmdW5jdGlvbiBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG4gIFx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcbiAgXHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuICBcdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcbiAgXHQgICAgbWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuICBcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcbiAgXHR2YXIgaSxcclxuICBcdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0aWYgKG1hcmtlcnNbaV0pIHtcclxuICBcdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIG5ld1BvaW50cztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgbGFzdCkge1xyXG5cclxuICBcdHZhciBtYXhTcURpc3QgPSAwLFxyXG4gIFx0aW5kZXgsIGksIHNxRGlzdDtcclxuXHJcbiAgXHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG4gIFx0XHRzcURpc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuICBcdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG4gIFx0XHRcdGluZGV4ID0gaTtcclxuICBcdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuICBcdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuICBcdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcbiAgXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcbiAgZnVuY3Rpb24gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcbiAgXHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdGlmIChfc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcbiAgXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcbiAgXHRcdFx0cHJldiA9IGk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICBcdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG4gIFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuICBcdH1cclxuICBcdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG4gIH1cclxuXHJcbiAgdmFyIF9sYXN0Q29kZTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcbiAgLy8gQ2xpcHMgdGhlIHNlZ21lbnQgYSB0byBiIGJ5IHJlY3Rhbmd1bGFyIGJvdW5kcyB3aXRoIHRoZVxyXG4gIC8vIFtDb2hlbi1TdXRoZXJsYW5kIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29oZW4lRTIlODAlOTNTdXRoZXJsYW5kX2FsZ29yaXRobSlcclxuICAvLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcbiAgLy8gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cclxuICBmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG4gIFx0dmFyIGNvZGVBID0gdXNlTGFzdENvZGUgPyBfbGFzdENvZGUgOiBfZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxyXG4gIFx0ICAgIGNvZGVCID0gX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcbiAgXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcbiAgXHQgICAgLy8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcbiAgXHQgICAgX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG4gIFx0d2hpbGUgKHRydWUpIHtcclxuICBcdFx0Ly8gaWYgYSxiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgYWNjZXB0KVxyXG4gIFx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG4gIFx0XHRcdHJldHVybiBbYSwgYl07XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcbiAgXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBvdGhlciBjYXNlc1xyXG4gIFx0XHRjb2RlT3V0ID0gY29kZUEgfHwgY29kZUI7XHJcbiAgXHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMsIHJvdW5kKTtcclxuICBcdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG4gIFx0XHRpZiAoY29kZU91dCA9PT0gY29kZUEpIHtcclxuICBcdFx0XHRhID0gcDtcclxuICBcdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0YiA9IHA7XHJcbiAgXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlLCBib3VuZHMsIHJvdW5kKSB7XHJcbiAgXHR2YXIgZHggPSBiLnggLSBhLngsXHJcbiAgXHQgICAgZHkgPSBiLnkgLSBhLnksXHJcbiAgXHQgICAgbWluID0gYm91bmRzLm1pbixcclxuICBcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG4gIFx0ICAgIHgsIHk7XHJcblxyXG4gIFx0aWYgKGNvZGUgJiA4KSB7IC8vIHRvcFxyXG4gIFx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcbiAgXHRcdHkgPSBtYXgueTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKGNvZGUgJiA0KSB7IC8vIGJvdHRvbVxyXG4gIFx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcbiAgXHRcdHkgPSBtaW4ueTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKGNvZGUgJiAyKSB7IC8vIHJpZ2h0XHJcbiAgXHRcdHggPSBtYXgueDtcclxuICBcdFx0eSA9IGEueSArIGR5ICogKG1heC54IC0gYS54KSAvIGR4O1xyXG5cclxuICBcdH0gZWxzZSBpZiAoY29kZSAmIDEpIHsgLy8gbGVmdFxyXG4gIFx0XHR4ID0gbWluLng7XHJcbiAgXHRcdHkgPSBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeDtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xyXG4gIFx0dmFyIGNvZGUgPSAwO1xyXG5cclxuICBcdGlmIChwLnggPCBib3VuZHMubWluLngpIHsgLy8gbGVmdFxyXG4gIFx0XHRjb2RlIHw9IDE7XHJcbiAgXHR9IGVsc2UgaWYgKHAueCA+IGJvdW5kcy5tYXgueCkgeyAvLyByaWdodFxyXG4gIFx0XHRjb2RlIHw9IDI7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKHAueSA8IGJvdW5kcy5taW4ueSkgeyAvLyBib3R0b21cclxuICBcdFx0Y29kZSB8PSA0O1xyXG4gIFx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcbiAgXHRcdGNvZGUgfD0gODtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gY29kZTtcclxuICB9XHJcblxyXG4gIC8vIHNxdWFyZSBkaXN0YW5jZSAodG8gYXZvaWQgdW5uZWNlc3NhcnkgTWF0aC5zcXJ0IGNhbGxzKVxyXG4gIGZ1bmN0aW9uIF9zcURpc3QocDEsIHAyKSB7XHJcbiAgXHR2YXIgZHggPSBwMi54IC0gcDEueCxcclxuICBcdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG4gIFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG4gIH1cclxuXHJcbiAgLy8gcmV0dXJuIGNsb3Nlc3QgcG9pbnQgb24gc2VnbWVudCBvciBkaXN0YW5jZSB0byB0aGF0IHBvaW50XHJcbiAgZnVuY3Rpb24gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgc3FEaXN0KSB7XHJcbiAgXHR2YXIgeCA9IHAxLngsXHJcbiAgXHQgICAgeSA9IHAxLnksXHJcbiAgXHQgICAgZHggPSBwMi54IC0geCxcclxuICBcdCAgICBkeSA9IHAyLnkgLSB5LFxyXG4gIFx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG4gIFx0ICAgIHQ7XHJcblxyXG4gIFx0aWYgKGRvdCA+IDApIHtcclxuICBcdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcbiAgXHRcdGlmICh0ID4gMSkge1xyXG4gIFx0XHRcdHggPSBwMi54O1xyXG4gIFx0XHRcdHkgPSBwMi55O1xyXG4gIFx0XHR9IGVsc2UgaWYgKHQgPiAwKSB7XHJcbiAgXHRcdFx0eCArPSBkeCAqIHQ7XHJcbiAgXHRcdFx0eSArPSBkeSAqIHQ7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHRkeCA9IHAueCAtIHg7XHJcbiAgXHRkeSA9IHAueSAtIHk7XHJcblxyXG4gIFx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IFBvaW50KHgsIHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBpc0ZsYXQobGF0bG5nczogTGF0TG5nW10pOiBCb29sZWFuXHJcbiAgLy8gUmV0dXJucyB0cnVlIGlmIGBsYXRsbmdzYCBpcyBhIGZsYXQgYXJyYXksIGZhbHNlIGlzIG5lc3RlZC5cclxuICBmdW5jdGlvbiBpc0ZsYXQobGF0bG5ncykge1xyXG4gIFx0cmV0dXJuICFpc0FycmF5KGxhdGxuZ3NbMF0pIHx8ICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICd1bmRlZmluZWQnKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9mbGF0KGxhdGxuZ3MpIHtcclxuICBcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCB1c2Ugb2YgX2ZsYXQsIHBsZWFzZSB1c2UgTC5MaW5lVXRpbC5pc0ZsYXQgaW5zdGVhZC4nKTtcclxuICBcdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbiAgfVxyXG5cclxuICAvKiBAZnVuY3Rpb24gcG9seWxpbmVDZW50ZXIobGF0bG5nczogTGF0TG5nW10sIGNyczogQ1JTKTogTGF0TG5nXHJcbiAgICogUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcGFzc2VkIExhdExuZ3MgKGZpcnN0IHJpbmcpIGZyb20gYSBwb2x5bGluZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzLCBjcnMpIHtcclxuICBcdHZhciBpLCBoYWxmRGlzdCwgc2VnRGlzdCwgZGlzdCwgcDEsIHAyLCByYXRpbywgY2VudGVyO1xyXG5cclxuICBcdGlmICghbGF0bG5ncyB8fCBsYXRsbmdzLmxlbmd0aCA9PT0gMCkge1xyXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xhdGxuZ3Mgbm90IHBhc3NlZCcpO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmICghaXNGbGF0KGxhdGxuZ3MpKSB7XHJcbiAgXHRcdGNvbnNvbGUud2FybignbGF0bG5ncyBhcmUgbm90IGZsYXQhIE9ubHkgdGhlIGZpcnN0IHJpbmcgd2lsbCBiZSB1c2VkJyk7XHJcbiAgXHRcdGxhdGxuZ3MgPSBsYXRsbmdzWzBdO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBjZW50cm9pZExhdExuZyA9IHRvTGF0TG5nKFswLCAwXSk7XHJcblxyXG4gIFx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdGxuZ3MpO1xyXG4gIFx0dmFyIGFyZWFCb3VuZHMgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICogYm91bmRzLmdldE5vcnRoRWFzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldE5vcnRoV2VzdCgpKTtcclxuICBcdC8vIHRlc3RzIHNob3dlZCB0aGF0IGJlbG93IDE3MDAgcm91bmRpbmcgZXJyb3JzIGFyZSBoYXBwZW5pbmdcclxuICBcdGlmIChhcmVhQm91bmRzIDwgMTcwMCkge1xyXG4gIFx0XHQvLyBnZXR0aW5nIGEgaW5leGFjdCBjZW50ZXIsIHRvIG1vdmUgdGhlIGxhdGxuZ3MgbmVhciB0byBbMCwgMF0gdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnNcclxuICBcdFx0Y2VudHJvaWRMYXRMbmcgPSBjZW50cm9pZChsYXRsbmdzKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgbGVuID0gbGF0bG5ncy5sZW5ndGg7XHJcbiAgXHR2YXIgcG9pbnRzID0gW107XHJcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0dmFyIGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xyXG4gIFx0XHRwb2ludHMucHVzaChjcnMucHJvamVjdCh0b0xhdExuZyhbbGF0bG5nLmxhdCAtIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nLmxuZyAtIGNlbnRyb2lkTGF0TG5nLmxuZ10pKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XHJcbiAgXHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcclxuICBcdH1cclxuXHJcbiAgXHQvLyBUaGUgbGluZSBpcyBzbyBzbWFsbCBpbiB0aGUgY3VycmVudCB2aWV3IHRoYXQgYWxsIHBvaW50cyBhcmUgb24gdGhlIHNhbWUgcGl4ZWwuXHJcbiAgXHRpZiAoaGFsZkRpc3QgPT09IDApIHtcclxuICBcdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuICBcdFx0XHRwMSA9IHBvaW50c1tpXTtcclxuICBcdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XHJcbiAgXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xyXG4gIFx0XHRcdGRpc3QgKz0gc2VnRGlzdDtcclxuXHJcbiAgXHRcdFx0aWYgKGRpc3QgPiBoYWxmRGlzdCkge1xyXG4gIFx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XHJcbiAgXHRcdFx0XHRjZW50ZXIgPSBbXHJcbiAgXHRcdFx0XHRcdHAyLnggLSByYXRpbyAqIChwMi54IC0gcDEueCksXHJcbiAgXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcclxuICBcdFx0XHRcdF07XHJcbiAgXHRcdFx0XHRicmVhaztcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHR2YXIgbGF0bG5nQ2VudGVyID0gY3JzLnVucHJvamVjdCh0b1BvaW50KGNlbnRlcikpO1xyXG4gIFx0cmV0dXJuIHRvTGF0TG5nKFtsYXRsbmdDZW50ZXIubGF0ICsgY2VudHJvaWRMYXRMbmcubGF0LCBsYXRsbmdDZW50ZXIubG5nICsgY2VudHJvaWRMYXRMbmcubG5nXSk7XHJcbiAgfVxuXG4gIHZhciBMaW5lVXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgc2ltcGxpZnk6IHNpbXBsaWZ5LFxuICAgIHBvaW50VG9TZWdtZW50RGlzdGFuY2U6IHBvaW50VG9TZWdtZW50RGlzdGFuY2UsXG4gICAgY2xvc2VzdFBvaW50T25TZWdtZW50OiBjbG9zZXN0UG9pbnRPblNlZ21lbnQsXG4gICAgY2xpcFNlZ21lbnQ6IGNsaXBTZWdtZW50LFxuICAgIF9nZXRFZGdlSW50ZXJzZWN0aW9uOiBfZ2V0RWRnZUludGVyc2VjdGlvbixcbiAgICBfZ2V0Qml0Q29kZTogX2dldEJpdENvZGUsXG4gICAgX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50OiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG4gICAgaXNGbGF0OiBpc0ZsYXQsXG4gICAgX2ZsYXQ6IF9mbGF0LFxuICAgIHBvbHlsaW5lQ2VudGVyOiBwb2x5bGluZUNlbnRlclxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHNlY3Rpb25cclxuICAgKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gICAqXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gICAqXHJcbiAgICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAgICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICAgKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gICAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAgICovXHJcblxyXG4gIHZhciBMb25MYXQgPSB7XHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZywgbGF0bG5nLmxhdCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAgICpcclxuICAgKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzIGFuIGVsbGlwc29pZC4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIE1lcmNhdG9yID0ge1xyXG4gIFx0UjogNjM3ODEzNyxcclxuICBcdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cclxuICBcdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcbiAgXHRcdCAgICByID0gdGhpcy5SLFxyXG4gIFx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG4gIFx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuICBcdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcbiAgXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG4gIFx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG4gIFx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG4gIFx0XHQgICAgciA9IHRoaXMuUixcclxuICBcdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcbiAgXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG4gIFx0XHQgICAgdHMgPSBNYXRoLmV4cCgtcG9pbnQueSAvIHIpLFxyXG4gIFx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG4gIFx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xyXG4gIFx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG4gIFx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG4gIFx0XHRcdHBoaSArPSBkcGhpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG4gIFx0fVxyXG4gIH07XG5cbiAgLypcbiAgICogQGNsYXNzIFByb2plY3Rpb25cblxuICAgKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICAgKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBfcHJvamVjdGlvbikuXG5cbiAgICogQHByb3BlcnR5IGJvdW5kczogQm91bmRzXG4gICAqIFRoZSBib3VuZHMgKHNwZWNpZmllZCBpbiBDUlMgdW5pdHMpIHdoZXJlIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkXG5cbiAgICogQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcbiAgICogUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gYSAyRCBwb2ludC5cbiAgICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICAgKiBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcbiAgICogVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLiBQcm9qZWN0cyBhIDJEIHBvaW50IGludG8gYSBnZW9ncmFwaGljYWwgbG9jYXRpb24uXG4gICAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICAgKiBOb3RlIHRoYXQgdGhlIHByb2plY3Rpb24gaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxuICAgKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcbiAgICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAgICovXG5cbiAgdmFyIGluZGV4ID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBMb25MYXQ6IExvbkxhdCxcbiAgICBNZXJjYXRvcjogTWVyY2F0b3IsXG4gICAgU3BoZXJpY2FsTWVyY2F0b3I6IFNwaGVyaWNhbE1lcmNhdG9yXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICAgKlxyXG4gICAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAgICovXHJcbiAgdmFyIEVQU0czMzk1ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG4gIFx0Y29kZTogJ0VQU0c6MzM5NScsXHJcbiAgXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcbiAgXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBNZXJjYXRvci5SKTtcclxuICBcdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG4gIFx0fSgpKVxyXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAgICpcclxuICAgKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICAgKlxyXG4gICAqIExlYWZsZXQgMS4wLnggY29tcGxpZXMgd2l0aCB0aGUgW1RNUyBjb29yZGluYXRlIHNjaGVtZSBmb3IgRVBTRzo0MzI2XShodHRwczovL3dpa2kub3NnZW8ub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZV9TcGVjaWZpY2F0aW9uI2dsb2JhbC1nZW9kZXRpYyksXHJcbiAgICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICAgKiB3aXRoIHRoaXMgQ1JTLCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgdHdvIDI1NngyNTYgcGl4ZWwgdGlsZXMgY292ZXJpbmcgdGhlXHJcbiAgICogd2hvbGUgZWFydGggYXQgem9vbSBsZXZlbCB6ZXJvLCBhbmQgdGhhdCB0aGUgdGlsZSBjb29yZGluYXRlIG9yaWdpbiBpcyAoLTE4MCwrOTApLFxyXG4gICAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gICAqL1xyXG5cclxuICB2YXIgRVBTRzQzMjYgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcbiAgXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuICBcdHByb2plY3Rpb246IExvbkxhdCxcclxuICBcdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbiAgfSk7XG5cbiAgLypcbiAgICogQG5hbWVzcGFjZSBDUlNcbiAgICogQGNycyBMLkNSUy5TaW1wbGVcbiAgICpcbiAgICogQSBzaW1wbGUgQ1JTIHRoYXQgbWFwcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGludG8gYHhgIGFuZCBgeWAgZGlyZWN0bHkuXG4gICAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAgICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gICAqIHNpbXBsZSBldWNsaWRlYW4gZGlzdGFuY2UuXG4gICAqL1xuXG4gIHZhciBTaW1wbGUgPSBleHRlbmQoe30sIENSUywge1xuICBcdHByb2plY3Rpb246IExvbkxhdCxcbiAgXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cbiAgXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcbiAgXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcbiAgXHR9LFxuXG4gIFx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG4gIFx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7XG4gIFx0fSxcblxuICBcdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuICBcdFx0dmFyIGR4ID0gbGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZyxcbiAgXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cbiAgXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBcdH0sXG5cbiAgXHRpbmZpbml0ZTogdHJ1ZVxuICB9KTtcblxuICBDUlMuRWFydGggPSBFYXJ0aDtcbiAgQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG4gIENSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuICBDUlMuRVBTRzkwMDkxMyA9IEVQU0c5MDA5MTM7XG4gIENSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuICBDUlMuU2ltcGxlID0gU2ltcGxlO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBMYXllclxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxuICAgKiBAYWthIEwuTGF5ZXJcbiAgICogQGFrYSBJTGF5ZXJcbiAgICpcbiAgICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAgICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbGF5ZXIgPSBMLm1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gICAqIGxheWVyLmFkZFRvKG1hcCk7XG4gICAqIGxheWVyLnJlbW92ZSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV2ZW50IGFkZDogRXZlbnRcbiAgICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gICAqXG4gICAqIEBldmVudCByZW1vdmU6IEV2ZW50XG4gICAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAgICovXG5cblxuICB2YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cbiAgXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcbiAgXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cbiAgXHRcdHBhbmU6ICdvdmVybGF5UGFuZScsXG5cbiAgXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZS5nLiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIuIEl0IGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSBhbmQgaXMgb2Z0ZW4gYSBsZWdhbCBvYmxpZ2F0aW9uIHRvd2FyZHMgY29weXJpZ2h0IGhvbGRlcnMgYW5kIHRpbGUgcHJvdmlkZXJzLlxuICBcdFx0YXR0cmlidXRpb246IG51bGwsXG5cbiAgXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcbiAgXHR9LFxuXG4gIFx0LyogQHNlY3Rpb25cbiAgXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgXHQgKlxuICBcdCAqIEBtZXRob2QgYWRkVG8obWFwOiBNYXB8TGF5ZXJHcm91cCk6IHRoaXNcbiAgXHQgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwIG9yIGxheWVyIGdyb3VwLlxuICBcdCAqL1xuICBcdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcbiAgXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cbiAgXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnJlbW92ZUZyb20odGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIG1hcFxuICBcdC8vXG4gIFx0Ly8gQGFsdGVybmF0aXZlXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKGdyb3VwOiBMYXllckdyb3VwKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIGBMYXllckdyb3VwYFxuICBcdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcbiAgXHRcdGlmIChvYmopIHtcbiAgXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCByZXByZXNlbnRpbmcgdGhlIG5hbWVkIHBhbmUgb24gdGhlIG1hcC4gSWYgYG5hbWVgIGlzIG9taXR0ZWQsIHJldHVybnMgdGhlIHBhbmUgZm9yIHRoaXMgbGF5ZXIuXG4gIFx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcbiAgXHR9LFxuXG4gIFx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICBcdFx0dGhpcy5fbWFwLl90YXJnZXRzW3N0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbc3RhbXAodGFyZ2V0RWwpXTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcbiAgXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuICBcdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuICBcdH0sXG5cbiAgXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cbiAgXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG4gIFx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xuICBcdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cbiAgXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuICBcdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcbiAgXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG4gIFx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcbiAgXHRcdFx0fSwgdGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMub25BZGQobWFwKTtcblxuICBcdFx0dGhpcy5maXJlKCdhZGQnKTtcbiAgXHRcdG1hcC5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogdGhpc30pO1xuICBcdH1cbiAgfSk7XG5cbiAgLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAgICogQHVuaW5oZXJpdGFibGVcbiAgICpcbiAgICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICAgKlxuICAgKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICAgKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICAgKlxuICAgKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICAgKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICAgKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gICAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICAqXG4gICAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICAgKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAgICovXG5cblxuICAvKiBAbmFtZXNwYWNlIE1hcFxuICAgKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAgICpcbiAgICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gICAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAgICpcbiAgICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gICAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICAgKlxuICAgKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gICAqL1xuICBNYXAuaW5jbHVkZSh7XG4gIFx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG4gIFx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuICBcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghbGF5ZXIuX2xheWVyQWRkKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG9iamVjdCBpcyBub3QgYSBMYXllci4nKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuICBcdFx0aWYgKHRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cbiAgXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcblxuICBcdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuICBcdFx0aWYgKGxheWVyLmJlZm9yZUFkZCkge1xuICBcdFx0XHRsYXllci5iZWZvcmVBZGQodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMud2hlblJlYWR5KGxheWVyLl9sYXllckFkZCwgbGF5ZXIpO1xuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBpZCA9IHN0YW1wKGxheWVyKTtcblxuICBcdFx0aWYgKCF0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcbiAgXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG4gIFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG4gIFx0XHRcdGxheWVyLmZpcmUoJ3JlbW92ZScpO1xuICBcdFx0fVxuXG4gIFx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIG1hcFxuICBcdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHJldHVybiBzdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzO1xuICBcdH0sXG5cbiAgXHQvKiBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG4gIFx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cbiAgXHQgKiBgYGBcbiAgXHQgKiBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKXtcbiAgXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuICBcdCAqIH0pO1xuICBcdCAqIGBgYFxuICBcdCAqL1xuICBcdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG4gIFx0XHRsYXllcnMgPSBsYXllcnMgPyAoaXNBcnJheShsYXllcnMpID8gbGF5ZXJzIDogW2xheWVyc10pIDogW107XG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuICBcdFx0XHR0aGlzLl96b29tQm91bmRMYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuICBcdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZW1vdmVab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXG4gIFx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuICBcdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcbiAgXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuICBcdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcbiAgXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuICBcdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcbiAgXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuICBcdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuICBcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcbiAgXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuICBcdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG4gIFx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01heFpvb20gJiYgdGhpcy5nZXRab29tKCkgPiB0aGlzLl9sYXllcnNNYXhab29tKSB7XG4gIFx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKTtcbiAgXHRcdH1cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01pblpvb20gJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLl9sYXllcnNNaW5ab29tKSB7XG4gIFx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIExheWVyR3JvdXBcclxuICAgKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gICAqXHJcbiAgICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAgICogYW55IGxheWVycyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGdyb3VwIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgbWFwIGFzXHJcbiAgICogd2VsbC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5sYXllckdyb3VwKFttYXJrZXIxLCBtYXJrZXIyXSlcclxuICAgKiBcdC5hZGRMYXllcihwb2x5bGluZSlcclxuICAgKiBcdC5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgTGF5ZXJHcm91cCA9IExheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG4gIFx0XHR2YXIgaSwgbGVuO1xyXG5cclxuICBcdFx0aWYgKGxheWVycykge1xyXG4gIFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuICBcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcbiAgXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaWRdKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBoYXNMYXllcihpZDogTnVtYmVyKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGludGVybmFsIElEIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcbiAgXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdHZhciBsYXllcklkID0gdHlwZW9mIGxheWVyID09PSAnbnVtYmVyJyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuICBcdFx0cmV0dXJuIGxheWVySWQgaW4gdGhpcy5fbGF5ZXJzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgYWxsIHRoZSBsYXllcnMgZnJvbSB0aGUgZ3JvdXAuXHJcbiAgXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllciwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG4gIFx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG4gIFx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBsYXllcnMgY29udGFpbmVkIGRvIG5vdFxyXG4gIFx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuICBcdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICBcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG4gIFx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG4gIFx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG4gIFx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcbiAgXHQvLyBgYGBqc1xyXG4gIFx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcbiAgXHQvLyB9KTtcclxuICBcdC8vIGBgYFxyXG4gIFx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElELlxyXG4gIFx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG4gIFx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcbiAgXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGxheWVycyA9IFtdO1xyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihsYXllcnMucHVzaCwgbGF5ZXJzKTtcclxuICBcdFx0cmV0dXJuIGxheWVycztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cclxuICBcdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcbiAgXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0cmV0dXJuIHN0YW1wKGxheWVyKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4gIC8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuICB2YXIgbGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAgICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gICAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAgICpcclxuICAgKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gICAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gICAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICAgKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICAgKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICAgKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAgICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gICAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAgICogXHQuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIEZlYXR1cmVHcm91cCA9IExheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHJcbiAgXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcbiAgXHRcdExheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcbiAgXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcbiAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSBiYWNrIG9mIGFsbCBvdGhlciBsYXllcnNcclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG4gIFx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcbiAgXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gYm91bmRzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4gIC8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gIHZhciBmZWF0dXJlR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgSWNvblxyXG4gICAqIEBha2EgTC5JY29uXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAgICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAgICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAgICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICAgKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAgICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAgICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAgICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAgICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gICAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gICAqXHJcbiAgICovXHJcblxyXG4gIHZhciBJY29uID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHJcbiAgXHQvKiBAc2VjdGlvblxyXG4gIFx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcbiAgXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcbiAgXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG4gIFx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG4gIFx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0b29sdGlwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG4gIFx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuICBcdCAqL1xyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0cG9wdXBBbmNob3I6IFswLCAwXSxcclxuICBcdFx0dG9vbHRpcEFuY2hvcjogWzAsIDBdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcbiAgXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuICBcdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuICBcdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY3JlYXRlSWNvbihvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG4gIFx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuICBcdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG4gIFx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG4gIFx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcbiAgXHRcdGlmICghc3JjKSB7XHJcbiAgXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm4gbnVsbDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuICBcdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcbiAgXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBpbWc7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gIFx0XHR2YXIgc2l6ZU9wdGlvbiA9IG9wdGlvbnNbbmFtZSArICdTaXplJ107XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XHJcbiAgXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHNpemUgPSB0b1BvaW50KHNpemVPcHRpb24pLFxyXG4gIFx0XHQgICAgYW5jaG9yID0gdG9Qb2ludChuYW1lID09PSAnc2hhZG93JyAmJiBvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IgfHxcclxuICBcdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcbiAgXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyAob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpO1xyXG5cclxuICBcdFx0aWYgKGFuY2hvcikge1xyXG4gIFx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG4gIFx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoc2l6ZSkge1xyXG4gIFx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG4gIFx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcbiAgXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgXHRcdGVsLnNyYyA9IHNyYztcclxuICBcdFx0cmV0dXJuIGVsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuICBcdFx0cmV0dXJuIEJyb3dzZXIucmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGFuIGljb24gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cclxuICBmdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgSWNvbihvcHRpb25zKTtcclxuICB9XG5cbiAgLypcbiAgICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gICAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAgICogQHNlY3Rpb25cbiAgICpcbiAgICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAgICogbm8gaWNvbiBpcyBzcGVjaWZpZWQuIFBvaW50cyB0byB0aGUgYmx1ZSBtYXJrZXIgaW1hZ2UgZGlzdHJpYnV0ZWQgd2l0aCBMZWFmbGV0XG4gICAqIHJlbGVhc2VzLlxuICAgKlxuICAgKiBJbiBvcmRlciB0byBjdXN0b21pemUgdGhlIGRlZmF1bHQgaWNvbiwganVzdCBjaGFuZ2UgdGhlIHByb3BlcnRpZXMgb2YgYEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5vcHRpb25zYFxuICAgKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byBfY29tcGxldGVseV8gcmVwbGFjZSB0aGUgZGVmYXVsdCBpY29uLCBvdmVycmlkZSB0aGVcbiAgICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICAgKi9cblxuICB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRpY29uVXJsOiAgICAgICAnbWFya2VyLWljb24ucG5nJyxcbiAgXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuICBcdFx0c2hhZG93VXJsOiAgICAgJ21hcmtlci1zaGFkb3cucG5nJyxcbiAgXHRcdGljb25TaXplOiAgICBbMjUsIDQxXSxcbiAgXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcbiAgXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcbiAgXHRcdHRvb2x0aXBBbmNob3I6IFsxNiwgLTI4XSxcbiAgXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuICBcdH0sXG5cbiAgXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdGlmICh0eXBlb2YgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoICE9PSAnc3RyaW5nJykge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuICBcdFx0XHRJY29uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG4gIFx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgbG9jYXRpb24gb2YgdGhlXG4gIFx0XHQvLyBibHVlIGljb24gaW1hZ2VzLiBJZiB5b3UgYXJlIHBsYWNpbmcgdGhlc2UgaW1hZ2VzIGluIGEgbm9uLXN0YW5kYXJkXG4gIFx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgcGF0aC5cbiAgXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBJY29uRGVmYXVsdC5pbWFnZVBhdGgpICsgSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcbiAgXHR9LFxuXG4gIFx0X3N0cmlwVXJsOiBmdW5jdGlvbiAocGF0aCkge1x0Ly8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gdXNlIGluIHRlc3RzXG4gIFx0XHR2YXIgc3RyaXAgPSBmdW5jdGlvbiAoc3RyLCByZSwgaWR4KSB7XG4gIFx0XHRcdHZhciBtYXRjaCA9IHJlLmV4ZWMoc3RyKTtcbiAgXHRcdFx0cmV0dXJuIG1hdGNoICYmIG1hdGNoW2lkeF07XG4gIFx0XHR9O1xuICBcdFx0cGF0aCA9IHN0cmlwKHBhdGgsIC9edXJsXFwoKFsnXCJdKT8oLispXFwxXFwpJC8sIDIpO1xuICBcdFx0cmV0dXJuIHBhdGggJiYgc3RyaXAocGF0aCwgL14oLiopbWFya2VyLWljb25cXC5wbmckLywgMSk7XG4gIFx0fSxcblxuICBcdF9kZXRlY3RJY29uUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGVsID0gY3JlYXRlJDEoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuICBcdFx0dmFyIHBhdGggPSBnZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuICBcdFx0ICAgICAgICAgICBnZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cbiAgXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICBcdFx0cGF0aCA9IHRoaXMuX3N0cmlwVXJsKHBhdGgpO1xuICBcdFx0aWYgKHBhdGgpIHsgcmV0dXJuIHBhdGg7IH1cbiAgXHRcdHZhciBsaW5rID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGlua1tocmVmJD1cImxlYWZsZXQuY3NzXCJdJyk7XG4gIFx0XHRpZiAoIWxpbmspIHsgcmV0dXJuICcnOyB9XG4gIFx0XHRyZXR1cm4gbGluay5ocmVmLnN1YnN0cmluZygwLCBsaW5rLmhyZWYubGVuZ3RoIC0gJ2xlYWZsZXQuY3NzJy5sZW5ndGggLSAxKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5NYXJrZXJEcmFnIGlzIHVzZWQgaW50ZXJuYWxseSBieSBMLk1hcmtlciB0byBtYWtlIHRoZSBtYXJrZXJzIGRyYWdnYWJsZS5cbiAgICovXG5cblxuICAvKiBAbmFtZXNwYWNlIE1hcmtlclxuICAgKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBoYW5kbGVyc1xuICAgKlxuICAgKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAgICogTWFya2VyIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS4gT25seSB2YWxpZCB3aGVuIHRoZSBtYXJrZXIgaXMgb24gdGhlIG1hcCAoT3RoZXJ3aXNlIHNldCBbYG1hcmtlci5vcHRpb25zLmRyYWdnYWJsZWBdKCNtYXJrZXItZHJhZ2dhYmxlKSkuXG4gICAqL1xuXG4gIHZhciBNYXJrZXJEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcbiAgXHR9LFxuXG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG4gIFx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuICBcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICBcdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG4gIFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG4gIFx0XHR9LCB0aGlzKS5lbmFibGUoKTtcblxuICBcdFx0YWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLm9mZih7XG4gIFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gIFx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcbiAgXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuICBcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcbiAgXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuICBcdFx0aWYgKHRoaXMuX21hcmtlci5faWNvbikge1xuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcbiAgXHR9LFxuXG4gIFx0X2FkanVzdFBhbjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG4gIFx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG4gIFx0XHQgICAgc3BlZWQgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuU3BlZWQsXG4gIFx0XHQgICAgcGFkZGluZyA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5QYWRkaW5nLFxuICBcdFx0ICAgIGljb25Qb3MgPSBnZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuICBcdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxuICBcdFx0ICAgIG9yaWdpbiA9IG1hcC5nZXRQaXhlbE9yaWdpbigpO1xuXG4gIFx0XHR2YXIgcGFuQm91bmRzID0gdG9Cb3VuZHMoXG4gIFx0XHRcdGJvdW5kcy5taW4uX3N1YnRyYWN0KG9yaWdpbikuYWRkKHBhZGRpbmcpLFxuICBcdFx0XHRib3VuZHMubWF4Ll9zdWJ0cmFjdChvcmlnaW4pLnN1YnRyYWN0KHBhZGRpbmcpXG4gIFx0XHQpO1xuXG4gIFx0XHRpZiAoIXBhbkJvdW5kcy5jb250YWlucyhpY29uUG9zKSkge1xuICBcdFx0XHQvLyBDb21wdXRlIGluY3JlbWVudGFsIG1vdmVtZW50XG4gIFx0XHRcdHZhciBtb3ZlbWVudCA9IHRvUG9pbnQoXG4gIFx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5tYXgueCkgLyAoYm91bmRzLm1heC54IC0gcGFuQm91bmRzLm1heC54KSAtXG4gIFx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5taW4ueCkgLyAoYm91bmRzLm1pbi54IC0gcGFuQm91bmRzLm1pbi54KSxcblxuICBcdFx0XHRcdChNYXRoLm1heChwYW5Cb3VuZHMubWF4LnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWF4LnkpIC8gKGJvdW5kcy5tYXgueSAtIHBhbkJvdW5kcy5tYXgueSkgLVxuICBcdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSlcbiAgXHRcdFx0KS5tdWx0aXBseUJ5KHNwZWVkKTtcblxuICBcdFx0XHRtYXAucGFuQnkobW92ZW1lbnQsIHthbmltYXRlOiBmYWxzZX0pO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobW92ZW1lbnQpO1xuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLl9hZGQobW92ZW1lbnQpO1xuXG4gIFx0XHRcdHNldFBvc2l0aW9uKG1hcmtlci5faWNvbiwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MpO1xuICBcdFx0XHR0aGlzLl9vbkRyYWcoZSk7XG5cbiAgXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIEBzZWN0aW9uIERyYWdnaW5nIGV2ZW50c1xuICBcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cbiAgXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cbiAgXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblxuICBcdFx0Ly8gV2hlbiB1c2luZyBFUzYgaW1wb3J0cyBpdCBjb3VsZCBub3QgYmUgc2V0IHdoZW4gYFBvcHVwYCB3YXMgbm90IGltcG9ydGVkIGFzIHdlbGxcbiAgXHRcdHRoaXMuX21hcmtlci5jbG9zZVBvcHVwICYmIHRoaXMuX21hcmtlci5jbG9zZVBvcHVwKCk7XG5cbiAgXHRcdHRoaXMuX21hcmtlclxuICBcdFx0XHQuZmlyZSgnbW92ZXN0YXJ0JylcbiAgXHRcdFx0LmZpcmUoJ2RyYWdzdGFydCcpO1xuICBcdH0sXG5cbiAgXHRfb25QcmVEcmFnOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW4pIHtcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuICBcdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuICBcdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuICBcdFx0ICAgIGljb25Qb3MgPSBnZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuICBcdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuICBcdFx0Ly8gdXBkYXRlIHNoYWRvdyBwb3NpdGlvblxuICBcdFx0aWYgKHNoYWRvdykge1xuICBcdFx0XHRzZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuICBcdFx0fVxuXG4gIFx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcbiAgXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuICBcdFx0ZS5vbGRMYXRMbmcgPSB0aGlzLl9vbGRMYXRMbmc7XG5cbiAgXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuICBcdFx0bWFya2VyXG4gIFx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuICBcdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG4gIFx0fSxcblxuICBcdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cbiAgXHRcdCBjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cbiAgXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0b3BzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG4gIFx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuICBcdFx0dGhpcy5fbWFya2VyXG4gIFx0XHQgICAgLmZpcmUoJ21vdmVlbmQnKVxuICBcdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBNYXJrZXJcclxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICAgKiBAYWthIEwuTWFya2VyXHJcbiAgICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5tYXJrZXIoWzUwLjUsIDMwLjVdKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgTWFya2VyID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBNYXJrZXIgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcbiAgXHRcdC8vIEljb24gaW5zdGFuY2UgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIG1hcmtlci5cclxuICBcdFx0Ly8gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkLCBhIGNvbW1vbiBpbnN0YW5jZSBvZiBgTC5JY29uLkRlZmF1bHRgIGlzIHVzZWQuXHJcbiAgXHRcdGljb246IG5ldyBJY29uRGVmYXVsdCgpLFxyXG5cclxuICBcdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG4gIFx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuICBcdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRpdGxlOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuICBcdFx0Ly8gW1VzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eV0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2FjY2Vzc2liaWxpdHkvI21hcmtlcnMtbXVzdC1iZS1sYWJlbGxlZCkuXHJcbiAgXHRcdHRpdGxlOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnTWFya2VyJ1xyXG4gIFx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpY29uIGltYWdlLlxyXG4gIFx0XHQvLyBbVXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5XShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvYWNjZXNzaWJpbGl0eS8jbWFya2Vycy1tdXN0LWJlLWxhYmVsbGVkKS5cclxuICBcdFx0YWx0OiAnTWFya2VyJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIG1hcmtlciBpbWFnZXMgekluZGV4IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBsYXRpdHVkZS4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSB3YW50IHRvIHB1dCB0aGUgbWFya2VyIG9uIHRvcCBvZiBhbGwgb3RoZXJzIChvciBiZWxvdyksIHNwZWNpZnlpbmcgYSBoaWdoIHZhbHVlIGxpa2UgYDEwMDBgIChvciBoaWdoIG5lZ2F0aXZlIHZhbHVlLCByZXNwZWN0aXZlbHkpLlxyXG4gIFx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG4gIFx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG4gIFx0XHRvcGFjaXR5OiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxyXG4gIFx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG4gIFx0XHQvLyBUaGUgei1pbmRleCBvZmZzZXQgdXNlZCBmb3IgdGhlIGByaXNlT25Ib3ZlcmAgZmVhdHVyZS5cclxuICBcdFx0cmlzZU9mZnNldDogMjUwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBpY29uIHdpbGwgYmUgYWRkZWQuXHJcbiAgXHRcdHBhbmU6ICdtYXJrZXJQYW5lJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc2hhZG93UGFuZTogU3RyaW5nID0gJ3NoYWRvd1BhbmUnXHJcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgc2hhZG93IHdpbGwgYmUgYWRkZWQuXHJcbiAgXHRcdHNoYWRvd1BhbmU6ICdzaGFkb3dQYW5lJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgbWFya2VyIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXHJcbiAgXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxyXG4gIFx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1Bhbk9uRm9jdXM6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZW4gYHRydWVgLCB0aGUgbWFwIHdpbGwgcGFuIHdoZW5ldmVyIHRoZSBtYXJrZXIgaXMgZm9jdXNlZCAodmlhXHJcbiAgXHRcdC8vIGUuZy4gcHJlc3NpbmcgYHRhYmAgb24gdGhlIGtleWJvYXJkKSB0byBlbnN1cmUgdGhlIG1hcmtlciBpc1xyXG4gIFx0XHQvLyB2aXNpYmxlIHdpdGhpbiB0aGUgbWFwJ3MgYm91bmRzXHJcbiAgXHRcdGF1dG9QYW5PbkZvY3VzOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gRHJhZ2dhYmxlIG1hcmtlciBvcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuICBcdFx0ZHJhZ2dhYmxlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdG8gcGFuIHRoZSBtYXAgd2hlbiBkcmFnZ2luZyB0aGlzIG1hcmtlciBuZWFyIGl0cyBlZGdlIG9yIG5vdC5cclxuICBcdFx0YXV0b1BhbjogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcclxuICBcdFx0Ly8gRGlzdGFuY2UgKGluIHBpeGVscyB0byB0aGUgbGVmdC9yaWdodCBhbmQgdG8gdGhlIHRvcC9ib3R0b20pIG9mIHRoZVxyXG4gIFx0XHQvLyBtYXAgZWRnZSB0byBzdGFydCBwYW5uaW5nIHRoZSBtYXAuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG4gIFx0XHQvLyBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBtYXAgc2hvdWxkIHBhbiBieS5cclxuICBcdFx0YXV0b1BhblNwZWVkOiAxMFxyXG4gIFx0fSxcclxuXHJcbiAgXHQvKiBAc2VjdGlvblxyXG4gIFx0ICpcclxuICBcdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuICBcdCAqL1xyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb247XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faW5pdEljb24oKTtcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICBcdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0ZGVsZXRlIHRoaXMuZHJhZ2dpbmc7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuICBcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdHpvb206IHRoaXMudXBkYXRlLFxyXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuICBcdFx0fTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuICBcdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcclxuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIFt6SW5kZXggb2Zmc2V0XSgjbWFya2VyLXppbmRleG9mZnNldCkgb2YgdGhlIG1hcmtlci5cclxuICBcdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG4gIFx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRJY29uOiBJY29uXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGljb24gdXNlZCBieSB0aGUgbWFya2VyXHJcbiAgXHRnZXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuICBcdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG4gIFx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG4gIFx0fSxcclxuXHJcbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pY29uICYmIHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuICBcdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SWNvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuICBcdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG4gIFx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG4gIFx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuICBcdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcbiAgXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG4gIFx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcbiAgXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcbiAgXHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0IHx8ICcnO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0YWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG4gIFx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcbiAgXHRcdFx0aWNvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuICBcdFx0XHR0aGlzLm9uKHtcclxuICBcdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG4gIFx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMpIHtcclxuICBcdFx0XHRvbihpY29uLCAnZm9jdXMnLCB0aGlzLl9wYW5PbkZvY3VzLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuICBcdFx0ICAgIGFkZFNoYWRvdyA9IGZhbHNlO1xyXG5cclxuICBcdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcbiAgXHRcdFx0YWRkU2hhZG93ID0gdHJ1ZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKG5ld1NoYWRvdykge1xyXG4gIFx0XHRcdGFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcbiAgXHRcdFx0bmV3U2hhZG93LmFsdCA9ICcnO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuICBcdFx0fVxyXG5cclxuXHJcbiAgXHRcdGlmIChhZGRJY29uKSB7XHJcbiAgXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5faW5pdEludGVyYWN0aW9uKCk7XHJcbiAgXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcbiAgXHRcdFx0dGhpcy5nZXRQYW5lKG9wdGlvbnMuc2hhZG93UGFuZSkuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcbiAgXHRcdFx0dGhpcy5vZmYoe1xyXG4gIFx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcbiAgXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvUGFuT25Gb2N1cykge1xyXG4gIFx0XHRcdG9mZih0aGlzLl9pY29uLCAnZm9jdXMnLCB0aGlzLl9wYW5PbkZvY3VzLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmVtb3ZlKHRoaXMuX2ljb24pO1xyXG4gIFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuICBcdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX3NoYWRvdyA9IG51bGw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG4gIFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuICBcdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG4gIFx0XHRpZiAodGhpcy5faWNvbikge1xyXG4gIFx0XHRcdHRoaXMuX2ljb24uc3R5bGUuekluZGV4ID0gdGhpcy5fekluZGV4ICsgb2Zmc2V0O1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKG9wdCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcbiAgXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG4gIFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuICBcdFx0aWYgKE1hcmtlckRyYWcpIHtcclxuICBcdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuICBcdFx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xyXG4gIFx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcbiAgXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcbiAgXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG4gIFx0XHRcdFx0dGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faWNvbikge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5faWNvbiwgb3BhY2l0eSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KDApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcGFuT25Gb2N1czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG4gIFx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBpY29uT3B0cyA9IHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnM7XHJcbiAgXHRcdHZhciBzaXplID0gaWNvbk9wdHMuaWNvblNpemUgPyB0b1BvaW50KGljb25PcHRzLmljb25TaXplKSA6IHRvUG9pbnQoMCwgMCk7XHJcbiAgXHRcdHZhciBhbmNob3IgPSBpY29uT3B0cy5pY29uQW5jaG9yID8gdG9Qb2ludChpY29uT3B0cy5pY29uQW5jaG9yKSA6IHRvUG9pbnQoMCwgMCk7XHJcblxyXG4gIFx0XHRtYXAucGFuSW5zaWRlKHRoaXMuX2xhdGxuZywge1xyXG4gIFx0XHRcdHBhZGRpbmdUb3BMZWZ0OiBhbmNob3IsXHJcbiAgXHRcdFx0cGFkZGluZ0JvdHRvbVJpZ2h0OiBzaXplLnN1YnRyYWN0KGFuY2hvcilcclxuICBcdFx0fSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRQb3B1cEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvcjtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMudG9vbHRpcEFuY2hvcjtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcbiAgZnVuY3Rpb24gbWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxuICB9XG5cbiAgLypcbiAgICogQGNsYXNzIFBhdGhcbiAgICogQGFrYSBMLlBhdGhcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXG4gICAqXG4gICAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICAgKiBvdmVybGF5cyAoUG9seWdvbiwgUG9seWxpbmUsIENpcmNsZSkuIERvIG5vdCB1c2UgaXQgZGlyZWN0bHkuIEV4dGVuZHMgYExheWVyYC5cbiAgICovXG5cbiAgdmFyIFBhdGggPSBMYXllci5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gc3Ryb2tlOiBCb29sZWFuID0gdHJ1ZVxuICBcdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG4gIFx0XHRzdHJva2U6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gY29sb3I6IFN0cmluZyA9ICcjMzM4OGZmJ1xuICBcdFx0Ly8gU3Ryb2tlIGNvbG9yXG4gIFx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHdlaWdodDogTnVtYmVyID0gM1xuICBcdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuICBcdFx0d2VpZ2h0OiAzLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuICBcdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcbiAgXHRcdG9wYWNpdHk6IDEsXG5cbiAgXHRcdC8vIEBvcHRpb24gbGluZUNhcDogU3RyaW5nPSAncm91bmQnXG4gIFx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cbiAgXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cbiAgXHRcdC8vIEBvcHRpb24gbGluZUpvaW46IFN0cmluZyA9ICdyb3VuZCdcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG4gIFx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBkYXNoQXJyYXk6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cbiAgXHRcdGRhc2hBcnJheTogbnVsbCxcblxuICBcdFx0Ly8gQG9wdGlvbiBkYXNoT2Zmc2V0OiBTdHJpbmcgPSBudWxsXG4gIFx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG4gIFx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGw6IEJvb2xlYW4gPSBkZXBlbmRzXG4gIFx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG4gIFx0XHRmaWxsOiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBmaWxsQ29sb3I6IFN0cmluZyA9ICpcbiAgXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cbiAgXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuICBcdFx0Ly8gQG9wdGlvbiBmaWxsT3BhY2l0eTogTnVtYmVyID0gMC4yXG4gIFx0XHQvLyBGaWxsIG9wYWNpdHkuXG4gIFx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxSdWxlOiBTdHJpbmcgPSAnZXZlbm9kZCdcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG4gIFx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG4gIFx0XHQvLyBjbGFzc05hbWU6ICcnLFxuXG4gIFx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG4gIFx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gdHJ1ZVxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBwYXRoIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG4gIFx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cbiAgXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcbiAgXHR9LFxuXG4gIFx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHQvLyBSZW5kZXJlciBpcyBzZXQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCByZW5kZXJlci5nZXRFdmVudHNcbiAgXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cbiAgXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuICBcdFx0dGhpcy5fcmVzZXQoKTtcbiAgXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgcmVkcmF3KCk6IHRoaXNcbiAgXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuICBcdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgYXBwZWFyYW5jZSBvZiBhIFBhdGggYmFzZWQgb24gdGhlIG9wdGlvbnMgaW4gdGhlIGBQYXRoIG9wdGlvbnNgIG9iamVjdC5cbiAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcbiAgXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuICBcdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyk7XG4gIFx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgJ3dlaWdodCcpKSB7XG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuICBcdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuICBcdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG4gIFx0fSxcblxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzXG4gIFx0XHR0aGlzLl9wcm9qZWN0KCk7XG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwKSArXG4gIFx0XHQgICh0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZSB8fCAwKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBDaXJjbGVNYXJrZXJcbiAgICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICAgKiBAaW5oZXJpdHMgUGF0aFxuICAgKlxuICAgKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gICAqL1xuXG4gIHZhciBDaXJjbGVNYXJrZXIgPSBQYXRoLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgQ2lyY2xlTWFya2VyIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRmaWxsOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyID0gMTBcbiAgXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG4gIFx0XHRyYWRpdXM6IDEwXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuICBcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYSBjaXJjbGUgbWFya2VyIHRvIGEgbmV3IGxvY2F0aW9uLlxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuICBcdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG4gIFx0XHR0aGlzLnJlZHJhdygpO1xuXG4gIFx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjY2lyY2xlbWFya2VyLXNldGxhdGxuZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmcoKTogTGF0TG5nXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXJcbiAgXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuICBcdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZSBtYXJrZXIuIFVuaXRzIGFyZSBpbiBwaXhlbHMuXG4gIFx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG4gIFx0fSxcblxuICBcdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcbiAgXHRcdFBhdGgucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLnNldFJhZGl1cyhyYWRpdXMpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgciA9IHRoaXMuX3JhZGl1cyxcbiAgXHRcdCAgICByMiA9IHRoaXMuX3JhZGl1c1kgfHwgcixcbiAgXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcbiAgXHRcdCAgICBwID0gW3IgKyB3LCByMiArIHddO1xuICBcdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LnN1YnRyYWN0KHApLCB0aGlzLl9wb2ludC5hZGQocCkpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG4gIFx0fSxcblxuICBcdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuICBcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuICBcdFx0cmV0dXJuIHAuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCkgPD0gdGhpcy5fcmFkaXVzICsgdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcbiAgXHR9XG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5jaXJjbGVNYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGVNYXJrZXIgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbiAgZnVuY3Rpb24gY2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgQ2lyY2xlXG4gICAqIEBha2EgTC5DaXJjbGVcbiAgICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICAgKlxuICAgKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAgICpcbiAgICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCB7cmFkaXVzOiAyMDB9KS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIENpcmNsZSA9IENpcmNsZU1hcmtlci5leHRlbmQoe1xuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuICBcdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICBcdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcbiAgXHRcdFx0b3B0aW9ucyA9IGV4dGVuZCh7fSwgbGVnYWN5T3B0aW9ucywge3JhZGl1czogb3B0aW9uc30pO1xuICBcdFx0fVxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cbiAgXHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTicpOyB9XG5cbiAgXHRcdC8vIEBzZWN0aW9uXG4gIFx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG4gIFx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyOyBSYWRpdXMgb2YgdGhlIGNpcmNsZSwgaW4gbWV0ZXJzLlxuICBcdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuICBcdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cbiAgXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcbiAgXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG4gIFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG4gIFx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG4gIFx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG4gIFx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuICBcdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZChoYWxmKSkpO1xuICBcdH0sXG5cbiAgXHRzZXRTdHlsZTogUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cbiAgXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG4gIFx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcbiAgXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuICBcdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cbiAgXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEVhcnRoLmRpc3RhbmNlKSB7XG4gIFx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcbiAgXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEVhcnRoLlIpIC8gZCxcbiAgXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcbiAgXHRcdFx0ICAgIGJvdHRvbSA9IG1hcC5wcm9qZWN0KFtsYXQgLSBsYXRSLCBsbmddKSxcbiAgXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG4gIFx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG4gIFx0XHRcdCAgICBsbmdSID0gTWF0aC5hY29zKChNYXRoLmNvcyhsYXRSICogZCkgLSBNYXRoLnNpbihsYXQgKiBkKSAqIE1hdGguc2luKGxhdDIgKiBkKSkgL1xuICBcdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cbiAgXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcbiAgXHRcdFx0XHRsbmdSID0gbGF0UiAvIE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBsYXQpOyAvLyBGYWxsYmFjayBmb3IgZWRnZSBjYXNlLCAjMjQyNVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcbiAgXHRcdFx0dGhpcy5fcmFkaXVzID0gaXNOYU4obG5nUikgPyAwIDogcC54IC0gbWFwLnByb2plY3QoW2xhdDIsIGxuZyAtIGxuZ1JdKS54O1xuICBcdFx0XHR0aGlzLl9yYWRpdXNZID0gcC55IC0gdG9wLnk7XG5cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG4gIFx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuICBcdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4gIC8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuICAvLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cbiAgLy8gQGFsdGVybmF0aXZlXG4gIC8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuICAvLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuICAvLyBEbyBub3QgdXNlIGluIG5ldyBhcHBsaWNhdGlvbnMgb3IgcGx1Z2lucy5cbiAgZnVuY3Rpb24gY2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgUG9seWxpbmVcbiAgICogQGFrYSBMLlBvbHlsaW5lXG4gICAqIEBpbmhlcml0cyBQYXRoXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiBcdFs0NS41MSwgLTEyMi42OF0sXG4gICAqIFx0WzM3Ljc3LCAtMTIyLjQzXSxcbiAgICogXHRbMzQuMDQsIC0xMTguMl1cbiAgICogXTtcbiAgICpcbiAgICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAgICpcbiAgICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5bGluZVxuICAgKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICAgKiB2YXIgbGF0bG5ncyA9IFtcbiAgICogXHRbWzQ1LjUxLCAtMTIyLjY4XSxcbiAgICogXHQgWzM3Ljc3LCAtMTIyLjQzXSxcbiAgICogXHQgWzM0LjA0LCAtMTE4LjJdXSxcbiAgICogXHRbWzQwLjc4LCAtNzMuOTFdLFxuICAgKiBcdCBbNDEuODMsIC04Ny42Ml0sXG4gICAqIFx0IFszMi43NiwgLTk2LjcyXV1cbiAgICogXTtcbiAgICogYGBgXG4gICAqL1xuXG5cbiAgdmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIFBvbHlsaW5lIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG4gIFx0XHQvLyBIb3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsLiBNb3JlIG1lYW5zXG4gIFx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG4gIFx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuICBcdFx0Ly8gQG9wdGlvbiBub0NsaXA6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cbiAgXHRcdG5vQ2xpcDogZmFsc2VcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cbiAgXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG4gIFx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcbiAgXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cbiAgXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGlzRW1wdHkoKTogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cbiAgXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGNsb3Nlc3RMYXllclBvaW50KHA6IFBvaW50KTogUG9pbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBwb2ludCBjbG9zZXN0IHRvIGBwYCBvbiB0aGUgUG9seWxpbmUuXG4gIFx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG4gIFx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcbiAgXHRcdCAgICBtaW5Qb2ludCA9IG51bGwsXG4gIFx0XHQgICAgY2xvc2VzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcbiAgXHRcdCAgICBwMSwgcDI7XG5cbiAgXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gIFx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuICBcdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuICBcdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG4gIFx0XHRcdFx0dmFyIHNxRGlzdCA9IGNsb3Nlc3QocCwgcDEsIHAyLCB0cnVlKTtcblxuICBcdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuICBcdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG4gIFx0XHRcdFx0XHRtaW5Qb2ludCA9IGNsb3Nlc3QocCwgcDEsIHAyKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGlmIChtaW5Qb2ludCkge1xuICBcdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gbWluUG9pbnQ7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwb2x5bGluZS5cbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcG9seWxpbmVDZW50ZXIodGhpcy5fZGVmYXVsdFNoYXBlKCksIHRoaXMuX21hcC5vcHRpb25zLmNycyk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuICBcdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/OiBMYXRMbmdbXSk6IHRoaXNcbiAgXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG4gIFx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmdcbiAgXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG4gIFx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG4gIFx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcbiAgXHRcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG4gIFx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcbiAgXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcbiAgXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcbiAgXHR9LFxuXG4gIFx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGlzRmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuICBcdH0sXG5cbiAgXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG4gIFx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dmFyIHJlc3VsdCA9IFtdLFxuICBcdFx0ICAgIGZsYXQgPSBpc0ZsYXQobGF0bG5ncyk7XG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGlmIChmbGF0KSB7XG4gIFx0XHRcdFx0cmVzdWx0W2ldID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XG4gIFx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fSxcblxuICBcdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gIFx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuICBcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuICBcdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG4gIFx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzID0gcHhCb3VuZHM7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG4gIFx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuICBcdFx0aWYgKCF0aGlzLl9yYXdQeEJvdW5kcykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyhbXG4gIFx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1pbi5zdWJ0cmFjdChwKSxcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWF4LmFkZChwKVxuICBcdFx0XSk7XG4gIFx0fSxcblxuICBcdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuICBcdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG4gIFx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMYXRMbmcsXG4gIFx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG4gIFx0XHQgICAgaSwgcmluZztcblxuICBcdFx0aWYgKGZsYXQpIHtcbiAgXHRcdFx0cmluZyA9IFtdO1xuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcbiAgXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2VcbiAgXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cbiAgXHRcdHRoaXMuX3BhcnRzID0gW107XG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuICBcdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuICBcdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG4gIFx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG4gIFx0XHRcdFx0c2VnbWVudCA9IGNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuICBcdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcbiAgXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG4gIFx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuICBcdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuICBcdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcbiAgXHRcdFx0XHRcdGsrKztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuICBcdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG4gIFx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdHBhcnRzW2ldID0gc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG4gIFx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuICBcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG4gIFx0fSxcblxuICBcdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcbiAgXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuICBcdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcbiAgXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuICBcdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgXHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG4gIFx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuICBcdFx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdFx0aWYgKHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuICBcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4gIC8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuICAvLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuICAvLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbiAgZnVuY3Rpb24gcG9seWxpbmUobGF0bG5ncywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBSZXRyb2NvbXBhdC4gQWxsb3cgcGx1Z2lucyB0byBzdXBwb3J0IExlYWZsZXQgdmVyc2lvbnMgYmVmb3JlIGFuZCBhZnRlciAxLjEuXG4gIFBvbHlsaW5lLl9mbGF0ID0gX2ZsYXQ7XG5cbiAgLypcbiAgICogQGNsYXNzIFBvbHlnb25cbiAgICogQGFrYSBMLlBvbHlnb25cbiAgICogQGluaGVyaXRzIFBvbHlsaW5lXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV07XG4gICAqXG4gICAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICAgKlxuICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAgICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICAgKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gICAqIF07XG4gICAqIGBgYFxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gICAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAgICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gICAqICAgXSxcbiAgICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gICAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAgICogICBdXG4gICAqIF07XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRmaWxsOiB0cnVlXG4gIFx0fSxcblxuICBcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGggfHwgIXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RoO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcbiAgXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBQb2x5Z29uLlxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBwb2x5Z29uQ2VudGVyKHRoaXMuX2RlZmF1bHRTaGFwZSgpLCB0aGlzLl9tYXAub3B0aW9ucy5jcnMpO1xuICBcdH0sXG5cbiAgXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gUG9seWxpbmUucHJvdG90eXBlLl9jb252ZXJ0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpLFxuICBcdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcbiAgXHRcdGlmIChsZW4gPj0gMiAmJiByZXN1bHRbMF0gaW5zdGFuY2VvZiBMYXRMbmcgJiYgcmVzdWx0WzBdLmVxdWFscyhyZXN1bHRbbGVuIC0gMV0pKSB7XG4gIFx0XHRcdHJlc3VsdC5wb3AoKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fSxcblxuICBcdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0UG9seWxpbmUucHJvdG90eXBlLl9zZXRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyk7XG4gIFx0XHRpZiAoaXNGbGF0KHRoaXMuX2xhdGxuZ3MpKSB7XG4gIFx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBpc0ZsYXQodGhpcy5fbGF0bG5nc1swXSkgPyB0aGlzLl9sYXRsbmdzWzBdIDogdGhpcy5fbGF0bG5nc1swXVswXTtcbiAgXHR9LFxuXG4gIFx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHBvbHlnb25zIG5lZWQgYSBkaWZmZXJlbnQgY2xpcHBpbmcgYWxnb3JpdGhtIHNvIHdlIHJlZGVmaW5lIHRoYXRcblxuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG4gIFx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG4gIFx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuICBcdFx0Ly8gaW5jcmVhc2UgY2xpcCBwYWRkaW5nIGJ5IHN0cm9rZSB3aWR0aCB0byBhdm9pZCBzdHJva2Ugb24gY2xpcCBlZGdlc1xuICBcdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cbiAgXHRcdHRoaXMuX3BhcnRzID0gW107XG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuICBcdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRjbGlwcGVkID0gY2xpcFBvbHlnb24odGhpcy5fcmluZ3NbaV0sIGJvdW5kcywgdHJ1ZSk7XG4gIFx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xuICBcdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMsIHRydWUpO1xuICBcdH0sXG5cbiAgXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG4gIFx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG4gIFx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG4gIFx0XHQgICAgcGFydCwgcDEsIHAyLCBpLCBqLCBrLCBsZW4sIGxlbjI7XG5cbiAgXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIFx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG4gIFx0XHRcdFx0cDEgPSBwYXJ0W2pdO1xuICBcdFx0XHRcdHAyID0gcGFydFtrXTtcblxuICBcdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG4gIFx0XHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBhbHNvIGNoZWNrIGlmIGl0J3Mgb24gcG9seWdvbiBzdHJva2VcbiAgXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG4gIFx0fVxuXG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbiAgZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgR2VvSlNPTlxyXG4gICAqIEBha2EgTC5HZW9KU09OXHJcbiAgICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gICAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5nZW9KU09OKGRhdGEsIHtcclxuICAgKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gICAqIFx0XHRyZXR1cm4ge2NvbG9yOiBmZWF0dXJlLnByb3BlcnRpZXMuY29sb3J9O1xyXG4gICAqIFx0fVxyXG4gICAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICAgKiBcdHJldHVybiBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb247XHJcbiAgICogfSkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIEdlb0pTT04gPSBGZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcbiAgXHQvKiBAc2VjdGlvblxyXG4gIFx0ICogQGFrYSBHZW9KU09OIG9wdGlvbnNcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHBvaW50VG9MYXllcjogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgaG93IEdlb0pTT04gcG9pbnRzIHNwYXduIExlYWZsZXQgbGF5ZXJzLiBJdCBpcyBpbnRlcm5hbGx5XHJcbiAgXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRvIHNwYXduIGEgZGVmYXVsdCBgTWFya2VyYDpcclxuICBcdCAqIGBgYGpzXHJcbiAgXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG4gIFx0ICogXHRyZXR1cm4gTC5tYXJrZXIobGF0bG5nKTtcclxuICBcdCAqIH1cclxuICBcdCAqIGBgYFxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gc3R5bGU6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuICBcdCAqIGNhbGxlZCBpbnRlcm5hbGx5IHdoZW4gZGF0YSBpcyBhZGRlZC5cclxuICBcdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIG5vdCBvdmVycmlkZSBhbnkgZGVmYXVsdHM6XHJcbiAgXHQgKiBgYGBqc1xyXG4gIFx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcbiAgXHQgKiBcdHJldHVybiB7fVxyXG4gIFx0ICogfVxyXG4gIFx0ICogYGBgXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggY3JlYXRlZCBgRmVhdHVyZWAsIGFmdGVyIGl0IGhhc1xyXG4gIFx0ICogYmVlbiBjcmVhdGVkIGFuZCBzdHlsZWQuIFVzZWZ1bCBmb3IgYXR0YWNoaW5nIGV2ZW50cyBhbmQgcG9wdXBzIHRvIGZlYXR1cmVzLlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuICBcdCAqIGBgYGpzXHJcbiAgXHQgKiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHt9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGZpbHRlcjogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgaXMgdG8gaW5jbHVkZSBhbGwgZmVhdHVyZXM6XHJcbiAgXHQgKiBgYGBqc1xyXG4gIFx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcbiAgXHQgKiBcdHJldHVybiB0cnVlO1xyXG4gIFx0ICogfVxyXG4gIFx0ICogYGBgXHJcbiAgXHQgKiBOb3RlOiBkeW5hbWljYWxseSBjaGFuZ2luZyB0aGUgYGZpbHRlcmAgb3B0aW9uIHdpbGwgaGF2ZSBlZmZlY3Qgb25seSBvbiBuZXdseVxyXG4gIFx0ICogYWRkZWQgZGF0YS4gSXQgd2lsbCBfbm90XyByZS1ldmFsdWF0ZSBhbHJlYWR5IGluY2x1ZGVkIGZlYXR1cmVzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gY29vcmRzVG9MYXRMbmc6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gY29vcmRpbmF0ZXMgdG8gYExhdExuZ2BzLlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIG1hcmtlcnNJbmhlcml0T3B0aW9uczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHQgKiBXaGV0aGVyIGRlZmF1bHQgTWFya2VycyBmb3IgXCJQb2ludFwiIHR5cGUgRmVhdHVyZXMgaW5oZXJpdCBmcm9tIGdyb3VwIG9wdGlvbnMuXHJcbiAgXHQgKi9cclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG4gIFx0XHRpZiAoZ2VvanNvbikge1xyXG4gIFx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcclxuICBcdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcbiAgXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG4gIFx0XHR2YXIgZmVhdHVyZXMgPSBpc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcbiAgXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG4gIFx0XHRpZiAoZmVhdHVyZXMpIHtcclxuICBcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcbiAgXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcbiAgXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcbiAgXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG4gIFx0XHRpZiAoIWxheWVyKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuICBcdFx0bGF5ZXIuZmVhdHVyZSA9IGFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcbiAgXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuICBcdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuICBcdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVzZXRTdHlsZSggPFBhdGg+IGxheWVyPyApOiB0aGlzXHJcbiAgXHQvLyBSZXNldHMgdGhlIGdpdmVuIHZlY3RvciBsYXllcidzIHN0eWxlIHRvIHRoZSBvcmlnaW5hbCBHZW9KU09OIHN0eWxlLCB1c2VmdWwgZm9yIHJlc2V0dGluZyBzdHlsZSBhZnRlciBob3ZlciBldmVudHMuXHJcbiAgXHQvLyBJZiBgbGF5ZXJgIGlzIG9taXR0ZWQsIHRoZSBzdHlsZSBvZiBhbGwgZmVhdHVyZXMgaW4gdGhlIGN1cnJlbnQgbGF5ZXIgaXMgcmVzZXQuXHJcbiAgXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZXNldFN0eWxlLCB0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG4gIFx0XHRsYXllci5vcHRpb25zID0gZXh0ZW5kKHt9LCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcbiAgXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuICBcdFx0fSwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcbiAgXHRcdGlmIChsYXllci5zZXRTdHlsZSkge1xyXG4gIFx0XHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAc2VjdGlvblxyXG4gIC8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5HZW9KU09OOlxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG4gIC8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuICAvLyBbYHBvaW50VG9MYXllcmBdKCNnZW9qc29uLXBvaW50dG9sYXllcikgYW5kL29yIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuICAvLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuICBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cclxuICBcdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcbiAgXHQgICAgY29vcmRzID0gZ2VvbWV0cnkgPyBnZW9tZXRyeS5jb29yZGluYXRlcyA6IG51bGwsXHJcbiAgXHQgICAgbGF5ZXJzID0gW10sXHJcbiAgXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuICBcdCAgICBfY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcsXHJcbiAgXHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG4gIFx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcbiAgXHRcdHJldHVybiBudWxsO1xyXG4gIFx0fVxyXG5cclxuICBcdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG4gIFx0Y2FzZSAnUG9pbnQnOlxyXG4gIFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzKTtcclxuICBcdFx0cmV0dXJuIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpO1xyXG5cclxuICBcdGNhc2UgJ011bHRpUG9pbnQnOlxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuICBcdFx0XHRsYXllcnMucHVzaChfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcbiAgXHRjYXNlICdMaW5lU3RyaW5nJzpcclxuICBcdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcbiAgXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRjYXNlICdQb2x5Z29uJzpcclxuICBcdGNhc2UgJ011bHRpUG9seWdvbic6XHJcbiAgXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuICBcdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHR2YXIgZ2VvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoe1xyXG4gIFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcbiAgXHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcbiAgXHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuICBcdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdFx0aWYgKGdlb0xheWVyKSB7XHJcbiAgXHRcdFx0XHRsYXllcnMucHVzaChnZW9MYXllcik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG4gIFx0Y2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5mZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHZhciBmZWF0dXJlTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvbWV0cnkuZmVhdHVyZXNbaV0sIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0XHRpZiAoZmVhdHVyZUxheWVyKSB7XHJcbiAgXHRcdFx0XHRsYXllcnMucHVzaChmZWF0dXJlTGF5ZXIpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuICBcdGRlZmF1bHQ6XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIHBvaW50VG9MYXllckZuID9cclxuICBcdFx0cG9pbnRUb0xheWVyRm4oZ2VvanNvbiwgbGF0bG5nKSA6XHJcbiAgXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuICAvLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4gIC8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG4gIGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4gIC8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuICAvLyBgbGV2ZWxzRGVlcGAgc3BlY2lmaWVzIHRoZSBuZXN0aW5nIGxldmVsICgwIGlzIGZvciBhbiBhcnJheSBvZiBwb2ludHMsIDEgZm9yIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwb2ludHMsIGV0Yy4sIDAgYnkgZGVmYXVsdCkuXHJcbiAgLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG4gIGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGxldmVsc0RlZXAsIF9jb29yZHNUb0xhdExuZykge1xyXG4gIFx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcbiAgXHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG4gIFx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG4gIFx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gbGF0bG5ncztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogQXJyYXlcclxuICAvLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24uXHJcbiAgZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nLCBwcmVjaXNpb24pIHtcclxuICBcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcbiAgXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuICBcdFx0W2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKSwgZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuICBcdFx0W2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3M6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjbG9zZWQ/OiBCb29sZWFuLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBBcnJheVxyXG4gIC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbiAgLy8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuICBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkLCBwcmVjaXNpb24pIHtcclxuICBcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHQvLyBDaGVjayBmb3IgZmxhdCBhcnJheXMgcmVxdWlyZWQgdG8gZW5zdXJlIHVuYmFsYW5jZWQgYXJyYXlzIGFyZSBjb3JyZWN0bHkgY29udmVydGVkIGluIHJlY3Vyc2lvblxyXG4gIFx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuICBcdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgaXNGbGF0KGxhdGxuZ3NbaV0pID8gMCA6IGxldmVsc0RlZXAgLSAxLCBjbG9zZWQsIHByZWNpc2lvbikgOlxyXG4gIFx0XHRcdGxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0sIHByZWNpc2lvbikpO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmICghbGV2ZWxzRGVlcCAmJiBjbG9zZWQgJiYgY29vcmRzLmxlbmd0aCA+IDApIHtcclxuICBcdFx0Y29vcmRzLnB1c2goY29vcmRzWzBdLnNsaWNlKCkpO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBjb29yZHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG4gIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG4gIFx0XHRleHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcbiAgXHRcdGFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIE5vcm1hbGl6ZSBHZW9KU09OIGdlb21ldHJpZXMvZmVhdHVyZXMgaW50byBHZW9KU09OIGZlYXR1cmVzLlxyXG4gIGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uKSB7XHJcbiAgXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcbiAgXHRcdHJldHVybiBnZW9qc29uO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB7XHJcbiAgXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuICBcdFx0cHJvcGVydGllczoge30sXHJcbiAgXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgdmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFya2VyXHJcbiAgLy8gQHNlY3Rpb24gT3RoZXIgbWV0aG9kc1xyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuICBNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbiAgLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuICBDaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbiAgQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcbiAgUG9seWxpbmUuaW5jbHVkZSh7XHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0dmFyIG11bHRpID0gIWlzRmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcbiAgXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuICAvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuICAvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcbiAgUG9seWdvbi5pbmNsdWRlKHtcclxuICBcdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgaG9sZXMgPSAhaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG4gIFx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuICBcdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuICBcdFx0aWYgKCFob2xlcykge1xyXG4gIFx0XHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbiAgTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuICBcdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICBcdC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIFx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG4gIFx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG4gIFx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuICBcdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcbiAgXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuICBcdFx0XHRcdFx0anNvbnMucHVzaChqc29uLmdlb21ldHJ5KTtcclxuICBcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdHZhciBmZWF0dXJlID0gYXNGZWF0dXJlKGpzb24pO1xyXG4gIFx0XHRcdFx0XHQvLyBTcXVhc2ggbmVzdGVkIGZlYXR1cmUgY29sbGVjdGlvbnNcclxuICBcdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG4gIFx0XHRcdFx0XHRcdGpzb25zLnB1c2guYXBwbHkoanNvbnMsIGZlYXR1cmUuZmVhdHVyZXMpO1xyXG4gIFx0XHRcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcbiAgXHRcdFx0XHRcdH1cclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcbiAgXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcbiAgXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcbiAgXHRcdH07XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4gIC8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbiAgLy8gW0dlb0pTT04gZm9ybWF0XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NikgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbiAgLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuICBmdW5jdGlvbiBnZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbiAgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gICAqIEBha2EgTC5JbWFnZU92ZXJsYXlcclxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICAgKlxyXG4gICAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHNpbmdsZSBpbWFnZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cHM6Ly9tYXBzLmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gICAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAgICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgSW1hZ2VPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG4gIFx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuICBcdFx0b3BhY2l0eTogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuICBcdFx0YWx0OiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG4gIFx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZXJyb3JPdmVybGF5VXJsOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG4gIFx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcclxuICBcdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgb3ZlcmxheSBsYXllci5cclxuICBcdFx0ekluZGV4OiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuICBcdFx0Y2xhc3NOYW1lOiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuICBcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG4gIFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdHRoaXMuX3Jlc2V0KCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuICBcdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0JhY2sodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcbiAgXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcbiAgXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcbiAgXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9yZXNldCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGV2ZW50cyA9IHtcclxuICBcdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcbiAgXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBHZXQgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XHJcbiAgXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IGNyZWF0ZSQxKCdpbWcnKTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyhpbWcsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG4gIFx0XHRpbWcub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcbiAgXHRcdGltZy5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcbiAgXHRcdGltZy5vbmxvYWQgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuICBcdFx0aW1nLm9uZXJyb3IgPSBiaW5kKHRoaXMuX292ZXJsYXlPbkVycm9yLCB0aGlzLCAnZXJyb3InKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG4gIFx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcbiAgXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcclxuXHJcbiAgXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuICBcdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG4gIFx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcbiAgXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcbiAgXHRcdHNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcbiAgXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcbiAgXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcclxuICBcdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vdmVybGF5T25FcnJvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBmYWlscyB0byBsb2FkIGl0cyBpbWFnZVxyXG4gIFx0XHR0aGlzLmZpcmUoJ2Vycm9yJyk7XHJcblxyXG4gIFx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG4gIFx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xyXG4gIFx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xyXG4gIFx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBJbWFnZU92ZXJsYXkuXHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRDZW50ZXIoKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4gIC8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuICB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICAgKiBAYWthIEwuVmlkZW9PdmVybGF5XHJcbiAgICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxyXG4gICAqXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgdmlkZW8gcGxheWVyIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXHJcbiAgICpcclxuICAgKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gICAqIEhUTUw1IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gICAqIFx0dmlkZW9Cb3VuZHMgPSBbWyAzMiwgLTEzMF0sIFsgMTMsIC0xMDBdXTtcclxuICAgKiBMLnZpZGVvT3ZlcmxheSh2aWRlb1VybCwgdmlkZW9Cb3VuZHMgKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgVmlkZW9PdmVybGF5IG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGxvYWRlZC5cclxuICBcdFx0Ly8gT24gc29tZSBicm93c2VycyBhdXRvcGxheSB3aWxsIG9ubHkgd29yayB3aXRoIGBtdXRlZDogdHJ1ZWBcclxuICBcdFx0YXV0b3BsYXk6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcbiAgXHRcdGxvb3A6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGtlZXBBc3BlY3RSYXRpbzogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBzYXZlIGFzcGVjdCByYXRpbyBhZnRlciB0aGUgcHJvamVjdGlvbi5cclxuICBcdFx0Ly8gUmVsZXZhbnQgZm9yIHN1cHBvcnRlZCBicm93c2Vycy4gU2VlIFticm93c2VyIGNvbXBhdGliaWxpdHldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vYmplY3QtZml0KVxyXG4gIFx0XHRrZWVwQXNwZWN0UmF0aW86IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG11dGVkOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIG9uIG11dGUgd2hlbiBsb2FkZWQuXHJcbiAgXHRcdG11dGVkOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcGxheXNJbmxpbmU6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIE1vYmlsZSBicm93c2VycyB3aWxsIHBsYXkgdGhlIHZpZGVvIHJpZ2h0IHdoZXJlIGl0IGlzIGluc3RlYWQgb2Ygb3BlbiBpdCB1cCBpbiBmdWxsc2NyZWVuIG1vZGUuXHJcbiAgXHRcdHBsYXlzSW5saW5lOiB0cnVlXHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG4gIFx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBjcmVhdGUkMSgndmlkZW8nKTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG4gIFx0XHR2aWQub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcbiAgXHRcdHZpZC5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcbiAgXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcbiAgXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuICBcdFx0XHR2YXIgc291cmNlRWxlbWVudHMgPSB2aWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xyXG4gIFx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcbiAgXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG4gIFx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZUVsZW1lbnRzW2pdLnNyYyk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCFpc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlkLnN0eWxlLCAnb2JqZWN0Rml0JykpIHtcclxuICBcdFx0XHR2aWQuc3R5bGVbJ29iamVjdEZpdCddID0gJ2ZpbGwnO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG4gIFx0XHR2aWQubG9vcCA9ICEhdGhpcy5vcHRpb25zLmxvb3A7XHJcbiAgXHRcdHZpZC5tdXRlZCA9ICEhdGhpcy5vcHRpb25zLm11dGVkO1xyXG4gIFx0XHR2aWQucGxheXNJbmxpbmUgPSAhIXRoaXMub3B0aW9ucy5wbGF5c0lubGluZTtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl91cmwubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR2YXIgc291cmNlID0gY3JlYXRlJDEoJ3NvdXJjZScpO1xyXG4gIFx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcbiAgXHRcdFx0dmlkLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTFZpZGVvRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MVmlkZW9FbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxWaWRlb0VsZW1lbnQpXHJcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudmlkZW9PdmVybGF5KHZpZGVvOiBTdHJpbmd8QXJyYXl8SFRNTFZpZGVvRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBWaWRlb092ZXJsYXkgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbiAgLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5cclxuICBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdPdmVybGF5XG4gICAqIEBha2EgTC5TVkdPdmVybGF5XG4gICAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcbiAgICpcbiAgICogVXNlZCB0byBsb2FkLCBkaXNwbGF5IGFuZCBwcm92aWRlIERPTSBhY2Nlc3MgdG8gYW4gU1ZHIGZpbGUgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cbiAgICpcbiAgICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAgICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBcIjAgMCAyMDAgMjAwXCIpO1xuICAgKiBzdmdFbGVtZW50LmlubmVySFRNTCA9ICc8cmVjdCB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwMFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6cmVkXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIxMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6IzAwMTNmZlwiLz4nO1xuICAgKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAgICogTC5zdmdPdmVybGF5KHN2Z0VsZW1lbnQsIHN2Z0VsZW1lbnRCb3VuZHMpLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgU1ZHT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xuICBcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBlbCA9IHRoaXMuX2ltYWdlID0gdGhpcy5fdXJsO1xuXG4gIFx0XHRhZGRDbGFzcyhlbCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgYWRkQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XG5cbiAgXHRcdGVsLm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICBcdFx0ZWwub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xuICBcdH1cblxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBTVkdFbGVtZW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpXG4gIFx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5zdmdPdmVybGF5KHN2ZzogU3RyaW5nfFNWR0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogU1ZHT3ZlcmxheSBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gYW4gU1ZHIGVsZW1lbnQgYW5kIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXG4gIC8vIEEgdmlld0JveCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgb24gdGhlIFNWRyBlbGVtZW50IHRvIHpvb20gaW4gYW5kIG91dCBwcm9wZXJseS5cblxuICBmdW5jdGlvbiBzdmdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICAgKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIG92ZXJsYXlzIGxpa2UgcGx1Z2lucy5cclxuICAgKi9cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbiAgdmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgdHJ1ZSwgdGhlIHBvcHVwL3Rvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIG1vdXNlIGV2ZW50cy5cclxuICBcdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcclxuICBcdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgb3ZlcmxheSBwb3NpdGlvbi5cclxuICBcdFx0b2Zmc2V0OiBbMCwgMF0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBvdmVybGF5LlxyXG4gIFx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSB1bmRlZmluZWRcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGFkZGVkLlxyXG4gIFx0XHRwYW5lOiB1bmRlZmluZWQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbiA9ICcnXHJcbiAgXHRcdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheSB3aGlsZSBpbml0aWFsaXppbmcuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZVxyXG4gIFx0XHQvLyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgb3ZlcmxheS5cclxuICBcdFx0Y29udGVudDogJydcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG4gIFx0XHRpZiAob3B0aW9ucyAmJiAob3B0aW9ucyBpbnN0YW5jZW9mIExhdExuZyB8fCBpc0FycmF5KG9wdGlvbnMpKSkge1xyXG4gIFx0XHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKG9wdGlvbnMpO1xyXG4gIFx0XHRcdHNldE9wdGlvbnModGhpcywgc291cmNlKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFx0XHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNvbnRlbnQpIHtcclxuICBcdFx0XHR0aGlzLl9jb250ZW50ID0gdGhpcy5vcHRpb25zLmNvbnRlbnQ7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcbiAgXHQvLyBBZGRzIHRoZSBvdmVybGF5IHRvIHRoZSBtYXAuXHJcbiAgXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLm9wZW5Qb3B1cChwb3B1cClgL2Aub3BlblRvb2x0aXAodG9vbHRpcClgLlxyXG4gIFx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcCA9IGFyZ3VtZW50cy5sZW5ndGggPyBtYXAgOiB0aGlzLl9zb3VyY2UuX21hcDsgLy8gZXhwZXJpbWVudGFsLCBub3QgdGhlIHBhcnQgb2YgcHVibGljIGFwaVxyXG4gIFx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkge1xyXG4gIFx0XHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZSgpOiB0aGlzXHJcbiAgXHQvLyBDbG9zZXMgdGhlIG92ZXJsYXkuXHJcbiAgXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLmNsb3NlUG9wdXAocG9wdXApYC9gLmNsb3NlVG9vbHRpcCh0b29sdGlwKWBcclxuICBcdC8vIGFuZCBgbGF5ZXIuY2xvc2VQb3B1cCgpYC9gLmNsb3NlVG9vbHRpcCgpYC5cclxuICBcdGNsb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9nZ2xlKGxheWVyPzogTGF5ZXIpOiB0aGlzXHJcbiAgXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIG92ZXJsYXkgYm91bmQgdG8gbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG4gIFx0Ly8gQXJndW1lbnQgbWF5IGJlIG9taXR0ZWQgb25seSBmb3Igb3ZlcmxheSBib3VuZCB0byBsYXllci5cclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBsYXllci50b2dnbGVQb3B1cCgpYC9gLnRvZ2dsZVRvb2x0aXAoKWAuXHJcbiAgXHR0b2dnbGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5jbG9zZSgpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9zb3VyY2UgPSBsYXllcjtcclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0bGF5ZXIgPSB0aGlzLl9zb3VyY2U7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHRoaXMuX3ByZXBhcmVPcGVuKCk7XHJcblxyXG4gIFx0XHRcdC8vIG9wZW4gdGhlIG92ZXJsYXkgb24gdGhlIG1hcFxyXG4gIFx0XHRcdHRoaXMub3Blbk9uKGxheWVyLl9tYXApO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcbiAgXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVUaW1lb3V0KTtcclxuICBcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcbiAgXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5icmluZ1RvRnJvbnQoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcbiAgXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuICBcdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChiaW5kKHJlbW92ZSwgdW5kZWZpbmVkLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG4gIFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuICBcdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiB0aGUgb3ZlcmxheS5cclxuICBcdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIG9wZW4uXHJcbiAgXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxyXG4gIFx0Ly8gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcbiAgXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gIFx0XHR0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGNvbnRhaW5lciBvZiB0aGUgb3ZlcmxheS5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1cGRhdGU6IG51bGxcclxuICBcdC8vIFVwZGF0ZXMgdGhlIG92ZXJsYXkgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgb3ZlcmxheSBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlTGF5b3V0KCk7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuICBcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZXZlbnRzID0ge1xyXG4gIFx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuICBcdFx0fTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGlzT3BlbjogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgb3ZlcmxheSBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcbiAgXHRpc09wZW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGlzIG92ZXJsYXkgaW4gZnJvbnQgb2Ygb3RoZXIgb3ZlcmxheXMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhpcyBvdmVybGF5IHRvIHRoZSBiYWNrIG9mIG90aGVyIG92ZXJsYXlzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHByZXBhcmUgYm91bmQgb3ZlcmxheSB0byBvcGVuOiB1cGRhdGUgbGF0bG5nIHBvcyAvIGNvbnRlbnQgc291cmNlIChmb3IgRmVhdHVyZUdyb3VwKVxyXG4gIFx0X3ByZXBhcmVPcGVuOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBzb3VyY2UgPSB0aGlzLl9zb3VyY2U7XHJcbiAgXHRcdGlmICghc291cmNlLl9tYXApIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRpZiAoc291cmNlIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSB7XHJcbiAgXHRcdFx0c291cmNlID0gbnVsbDtcclxuICBcdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5fc291cmNlLl9sYXllcnM7XHJcbiAgXHRcdFx0Zm9yICh2YXIgaWQgaW4gbGF5ZXJzKSB7XHJcbiAgXHRcdFx0XHRpZiAobGF5ZXJzW2lkXS5fbWFwKSB7XHJcbiAgXHRcdFx0XHRcdHNvdXJjZSA9IGxheWVyc1tpZF07XHJcbiAgXHRcdFx0XHRcdGJyZWFrO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRpZiAoIXNvdXJjZSkgeyByZXR1cm4gZmFsc2U7IH0gLy8gVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIuXHJcblxyXG4gIFx0XHRcdC8vIHNldCBvdmVybGF5IHNvdXJjZSB0byB0aGlzIGxheWVyXHJcbiAgXHRcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIWxhdGxuZykge1xyXG4gIFx0XHRcdGlmIChzb3VyY2UuZ2V0Q2VudGVyKSB7XHJcbiAgXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0Q2VudGVyKCk7XHJcbiAgXHRcdFx0fSBlbHNlIGlmIChzb3VyY2UuZ2V0TGF0TG5nKSB7XHJcbiAgXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0TGF0TG5nKCk7XHJcbiAgXHRcdFx0fSBlbHNlIGlmIChzb3VyY2UuZ2V0Qm91bmRzKSB7XHJcbiAgXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIgTGF0TG5nLicpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLnNldExhdExuZyhsYXRsbmcpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdC8vIHVwZGF0ZSB0aGUgb3ZlcmxheSAoY29udGVudCwgbGF5b3V0LCBldGMuLi4pXHJcbiAgXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRydWU7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcbiAgXHRcdHZhciBjb250ZW50ID0gKHR5cGVvZiB0aGlzLl9jb250ZW50ID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuX2NvbnRlbnQodGhpcy5fc291cmNlIHx8IHRoaXMpIDogdGhpcy5fY29udGVudDtcclxuXHJcbiAgXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG4gIFx0XHQvLyBAc2VjdGlvbiBEaXZPdmVybGF5IGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgY29udGVudHVwZGF0ZTogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY29udGVudCBvZiB0aGUgb3ZlcmxheSBpcyB1cGRhdGVkXHJcbiAgXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuICBcdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnksXHJcbiAgXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcbiAgXHRcdC8vIGJvdHRvbSBwb3NpdGlvbiB0aGUgb3ZlcmxheSBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIG92ZXJsYXkgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuYm90dG9tID0gYm90dG9tICsgJ3B4JztcclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gWzAsIDBdO1xyXG4gIFx0fVxyXG5cclxuICB9KTtcclxuXHJcbiAgTWFwLmluY2x1ZGUoe1xyXG4gIFx0X2luaXRPdmVybGF5OiBmdW5jdGlvbiAoT3ZlcmxheUNsYXNzLCBjb250ZW50LCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG4gIFx0XHRpZiAoIShvdmVybGF5IGluc3RhbmNlb2YgT3ZlcmxheUNsYXNzKSkge1xyXG4gIFx0XHRcdG92ZXJsYXkgPSBuZXcgT3ZlcmxheUNsYXNzKG9wdGlvbnMpLnNldENvbnRlbnQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGxhdGxuZykge1xyXG4gIFx0XHRcdG92ZXJsYXkuc2V0TGF0TG5nKGxhdGxuZyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG92ZXJsYXk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICBMYXllci5pbmNsdWRlKHtcclxuICBcdF9pbml0T3ZlcmxheTogZnVuY3Rpb24gKE92ZXJsYXlDbGFzcywgb2xkLCBjb250ZW50LCBvcHRpb25zKSB7XHJcbiAgXHRcdHZhciBvdmVybGF5ID0gY29udGVudDtcclxuICBcdFx0aWYgKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpIHtcclxuICBcdFx0XHRzZXRPcHRpb25zKG92ZXJsYXksIG9wdGlvbnMpO1xyXG4gIFx0XHRcdG92ZXJsYXkuX3NvdXJjZSA9IHRoaXM7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b3ZlcmxheSA9IChvbGQgJiYgIW9wdGlvbnMpID8gb2xkIDogbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zLCB0aGlzKTtcclxuICBcdFx0XHRvdmVybGF5LnNldENvbnRlbnQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG92ZXJsYXk7XHJcbiAgXHR9XHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgUG9wdXBcclxuICAgKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gICAqIEBha2EgTC5Qb3B1cFxyXG4gICAqIFVzZWQgdG8gb3BlbiBwb3B1cHMgaW4gY2VydGFpbiBwbGFjZXMgb2YgdGhlIG1hcC4gVXNlIFtNYXAub3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgdG9cclxuICAgKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICAgKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgcG9wdXAgdG8gbWFya2VyIGNsaWNrIGFuZCB0aGVuIG9wZW4gaXQsIGl0J3MgcmVhbGx5IGVhc3k6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG1hcmtlci5iaW5kUG9wdXAocG9wdXBDb250ZW50KS5vcGVuUG9wdXAoKTtcclxuICAgKiBgYGBcclxuICAgKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEEgcG9wdXAgY2FuIGJlIGFsc28gc3RhbmRhbG9uZTpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAgICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICAgKiBcdC5zZXRDb250ZW50KCc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICAgKiBcdC5vcGVuT24obWFwKTtcclxuICAgKiBgYGBcclxuICAgKiBvclxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvcHVwID0gTC5wb3B1cChsYXRsbmcsIHtjb250ZW50OiAnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAgICogXHQub3Blbk9uKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvcHVwXHJcbiAgdmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGFkZGVkLlxyXG4gIFx0XHRwYW5lOiAncG9wdXBQYW5lJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDcpXHJcbiAgXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLlxyXG4gIFx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG4gIFx0XHQvLyBNYXggd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcbiAgXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG4gIFx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcbiAgXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcbiAgXHRcdC8vIElmIHNldCwgY3JlYXRlcyBhIHNjcm9sbGFibGUgY29udGFpbmVyIG9mIHRoZSBnaXZlbiBoZWlnaHRcclxuICBcdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuICBcdFx0Ly8gVGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGNhbiBiZSBzdHlsZWQgdXNpbmcgdGhlXHJcbiAgXHRcdC8vIGBsZWFmbGV0LXBvcHVwLXNjcm9sbGVkYCBDU1MgY2xhc3Mgc2VsZWN0b3IuXHJcbiAgXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byBkbyBwYW5uaW5nIGFuaW1hdGlvblxyXG4gIFx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuICBcdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBQb2ludCA9IG51bGxcclxuICBcdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcbiAgXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuICBcdFx0YXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuICBcdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcbiAgXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG4gIFx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVzZXJzIGZyb20gcGFubmluZyB0aGUgcG9wdXBcclxuICBcdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuICBcdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG4gIFx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b0Nsb3NlOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG4gIFx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gIFx0XHRhdXRvQ2xvc2U6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsb3NlT25Fc2NhcGVLZXk6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcbiAgXHRcdC8vIHRoZSBFU0Mga2V5IGZvciBjbG9zaW5nIG9mIHRoZSBwb3B1cC5cclxuICBcdFx0Y2xvc2VPbkVzY2FwZUtleTogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xvc2VPbkNsaWNrOiBCb29sZWFuID0gKlxyXG4gIFx0XHQvLyBTZXQgaXQgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiB1c2VyIGNsaWNrc1xyXG4gIFx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG4gIFx0XHRjbGFzc05hbWU6ICcnXHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuICBcdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG4gIFx0Ly8gQWx0ZXJuYXRpdmUgdG8gYG1hcC5vcGVuUG9wdXAocG9wdXApYC5cclxuICBcdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLlxyXG4gIFx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcCA9IGFyZ3VtZW50cy5sZW5ndGggPyBtYXAgOiB0aGlzLl9zb3VyY2UuX21hcDsgLy8gZXhwZXJpbWVudGFsLCBub3QgdGhlIHBhcnQgb2YgcHVibGljIGFwaVxyXG5cclxuICBcdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcbiAgXHRcdFx0bWFwLnJlbW92ZUxheWVyKG1hcC5fcG9wdXApO1xyXG4gIFx0XHR9XHJcbiAgXHRcdG1hcC5fcG9wdXAgPSB0aGlzO1xyXG5cclxuICBcdFx0cmV0dXJuIERpdk92ZXJsYXkucHJvdG90eXBlLm9wZW5Pbi5jYWxsKHRoaXMsIG1hcCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpcyBvcGVuZWQgaW4gdGhlIG1hcFxyXG4gIFx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWRcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcbiAgXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcbiAgXHRcdFx0Ly8gYWdhaW4gdGhlIGxheWVyLCBzbyBwcmV2ZW50IHRoZSBtYXAgdG8gcmVvcGVuIGl0LlxyXG4gIFx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuICBcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG4gIFx0XHRtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG4gIFx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuICBcdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcbiAgXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuICBcdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuICBcdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLmNsb3NlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuICBcdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIGV2ZW50cztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLFxyXG4gIFx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcbiAgXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcbiAgXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcbiAgXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuICBcdFx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKTtcclxuICBcdFx0b24oY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuICBcdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcbiAgXHRcdHRoaXMuX3RpcCA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcbiAgXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBjcmVhdGUkMSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuICBcdFx0XHRjbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7IC8vIG92ZXJyaWRlcyB0aGUgaW1wbGljaXQgcm9sZT1saW5rIG9mIDxhPiBlbGVtZW50cyAjNzM5OVxyXG4gIFx0XHRcdGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdDbG9zZSBwb3B1cCcpO1xyXG4gIFx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuICBcdFx0XHRjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JiMyMTU7PC9zcGFuPic7XHJcblxyXG4gIFx0XHRcdG9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuICBcdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2KTtcclxuICBcdFx0XHRcdHRoaXMuY2xvc2UoKTtcclxuICBcdFx0XHR9LCB0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuICBcdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuICBcdFx0c3R5bGUud2lkdGggPSAnJztcclxuICBcdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuICBcdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gIFx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG4gIFx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuICBcdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcbiAgXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcbiAgXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuICBcdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcbiAgXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG4gIFx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcbiAgXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcbiAgXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuICBcdFx0XHRhZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLFxyXG4gIFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG4gIFx0XHRpZiAodGhpcy5fbWFwLl9wYW5BbmltKSB7IHRoaXMuX21hcC5fcGFuQW5pbS5zdG9wKCk7IH1cclxuXHJcbiAgXHRcdC8vIFdlIGNhbiBlbmRsZXNzbHkgcmVjdXJzZSBpZiBrZWVwSW5WaWV3IGlzIHNldCBhbmQgdGhlIHZpZXcgcmVzZXRzLlxyXG4gIFx0XHQvLyBMZXQncyBndWFyZCBhZ2FpbnN0IHRoYXQgYnkgZXhpdGluZyBlYXJseSBpZiB3ZSdyZSByZXNwb25kaW5nIHRvIG91ciBvd24gYXV0b3Bhbi5cclxuICBcdFx0aWYgKHRoaXMuX2F1dG9wYW5uaW5nKSB7XHJcbiAgXHRcdFx0dGhpcy5fYXV0b3Bhbm5pbmcgPSBmYWxzZTtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcbiAgXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChnZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcbiAgXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgbWFyZ2luQm90dG9tLFxyXG4gIFx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuICBcdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuICBcdFx0bGF5ZXJQb3MuX2FkZChnZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHJcbiAgXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG4gIFx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuICBcdFx0ICAgIHBhZGRpbmdUTCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuICBcdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcbiAgXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuICBcdFx0ICAgIGR4ID0gMCxcclxuICBcdFx0ICAgIGR5ID0gMDtcclxuXHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuICBcdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcbiAgXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG4gIFx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuICBcdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG4gIFx0XHRpZiAoZHggfHwgZHkpIHtcclxuICBcdFx0XHQvLyBUcmFjayB0aGF0IHdlJ3JlIGF1dG9wYW5uaW5nLCBhcyB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmUtcmFuIG9uIG1vdmVlbmRcclxuICBcdFx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuICBcdFx0XHRcdHRoaXMuX2F1dG9wYW5uaW5nID0gdHJ1ZTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdG1hcFxyXG4gIFx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuICBcdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHBvcHVwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yID8gdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvcigpIDogWzAsIDBdKTtcclxuICBcdH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuICAvLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHBvcHVwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLnBvcHVwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBgbGF0bG5nYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBvcGVuIGFuZCBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbi5cclxuICB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qIEBuYW1lc3BhY2UgTWFwXHJcbiAgICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gICAqIEBvcHRpb24gY2xvc2VQb3B1cE9uQ2xpY2s6IEJvb2xlYW4gPSB0cnVlXHJcbiAgICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICAgKi9cclxuICBNYXAubWVyZ2VPcHRpb25zKHtcclxuICBcdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICBNYXAuaW5jbHVkZSh7XHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChwb3B1cDogUG9wdXApOiB0aGlzXHJcbiAgXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG4gIFx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLl9pbml0T3ZlcmxheShQb3B1cCwgcG9wdXAsIGxhdGxuZywgb3B0aW9ucylcclxuICBcdFx0ICAub3Blbk9uKHRoaXMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG4gIFx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcbiAgXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAocG9wdXApIHtcclxuICBcdFx0cG9wdXAgPSBhcmd1bWVudHMubGVuZ3RoID8gcG9wdXAgOiB0aGlzLl9wb3B1cDtcclxuICBcdFx0aWYgKHBvcHVwKSB7XHJcbiAgXHRcdFx0cG9wdXAuY2xvc2UoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIExheWVyXHJcbiAgICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAgICpcclxuICAgKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyBwb3B1cHMgdG8gaXQuXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kUG9wdXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XHJcbiAgICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAgICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAgICovXHJcblxyXG4gIC8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuICBMYXllci5pbmNsdWRlKHtcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJpbmRQb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258UG9wdXAsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuICBcdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXHJcbiAgXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cclxuICBcdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuICBcdFx0dGhpcy5fcG9wdXAgPSB0aGlzLl9pbml0T3ZlcmxheShQb3B1cCwgdGhpcy5fcG9wdXAsIGNvbnRlbnQsIG9wdGlvbnMpO1xyXG4gIFx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG4gIFx0XHRcdHRoaXMub24oe1xyXG4gIFx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuICBcdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG4gIFx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcbiAgXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuICBcdFx0XHR9KTtcclxuICBcdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bmJpbmRQb3B1cCgpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcbiAgXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLm9mZih7XHJcbiAgXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG4gIFx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcbiAgXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuICBcdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuICBcdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IHRoaXM7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGlmICh0aGlzLl9wb3B1cC5fcHJlcGFyZU9wZW4obGF0bG5nIHx8IHRoaXMuX2xhdGxuZykpIHtcclxuICBcdFx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuICBcdFx0XHRcdHRoaXMuX3BvcHVwLm9wZW5Pbih0aGlzLl9tYXApO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuICBcdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG4gIFx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLl9wb3B1cC5jbG9zZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcclxuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcbiAgXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLl9wb3B1cC50b2dnbGUodGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXHJcbiAgXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcbiAgXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcclxuICBcdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcbiAgXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fcG9wdXAgfHwgIXRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG4gIFx0XHRzdG9wKGUpO1xyXG5cclxuICBcdFx0dmFyIHRhcmdldCA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cC5fc291cmNlID09PSB0YXJnZXQgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gIFx0XHRcdC8vIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuICBcdFx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcbiAgXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkpIHtcclxuICBcdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGFyZ2V0O1xyXG4gIFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcbiAgXHRcdFx0dGhpcy5fb3BlblBvcHVwKGUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIFRvb2x0aXBcbiAgICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAgICogQGFrYSBMLlRvb2x0aXBcbiAgICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSB0b29sdGlwIHRvIG1hcmtlcjpcbiAgICpcbiAgICogYGBganNcbiAgICogbWFya2VyLmJpbmRUb29sdGlwKFwibXkgdG9vbHRpcCB0ZXh0XCIpLm9wZW5Ub29sdGlwKCk7XG4gICAqIGBgYFxuICAgKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kVG9vbHRpcGAgbWV0aG9kLlxuICAgKlxuICAgKiBBIHRvb2x0aXAgY2FuIGJlIGFsc28gc3RhbmRhbG9uZTpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIHRvb2x0aXAgPSBMLnRvb2x0aXAoKVxuICAgKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxuICAgKiBcdC5zZXRDb250ZW50KCdIZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSB0b29sdGlwLicpXG4gICAqIFx0LmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKiBvclxuICAgKiBgYGBqc1xuICAgKiB2YXIgdG9vbHRpcCA9IEwudG9vbHRpcChsYXRsbmcsIHtjb250ZW50OiAnSGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgdG9vbHRpcC4nfSlcbiAgICogXHQuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqXG4gICAqXG4gICAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICAgKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAgICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gICAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gICAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gICAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAgICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gICAqL1xuXG5cbiAgLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4gIHZhciBUb29sdGlwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuICBcdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcbiAgXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cbiAgXHRcdG9mZnNldDogWzAsIDBdLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG4gIFx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuICBcdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuICBcdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuICBcdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cbiAgXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG4gIFx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG4gIFx0XHRzdGlja3k6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuICBcdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cbiAgXHRcdG9wYWNpdHk6IDAuOVxuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICBcdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcbiAgXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG4gIFx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG4gIFx0XHRpZiAodGhpcy5fc291cmNlKSB7XG4gIFx0XHRcdHRoaXMuYWRkRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuICBcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcbiAgXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG4gIFx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuICBcdFx0XHR0aGlzLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMuX3NvdXJjZSk7XG5cbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuICBcdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuICBcdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG4gIFx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG4gIFx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuICBcdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKTtcblxuICBcdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sdGlwJyk7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICdsZWFmbGV0LXRvb2x0aXAtJyArIHN0YW1wKHRoaXMpKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge30sXG5cbiAgXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuICBcdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0dmFyIHN1YlgsIHN1YlksXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgXHRcdCAgICBjZW50ZXJQb2ludCA9IG1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG1hcC5nZXRDZW50ZXIoKSksXG4gIFx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG4gIFx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcbiAgXHRcdCAgICB0b29sdGlwV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGgsXG4gIFx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG4gIFx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcbiAgXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblxuICBcdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0O1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG4gIFx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuICBcdFx0XHRzdWJZID0gMDtcbiAgXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgXHRcdFx0c3ViWCA9IDA7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aDtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmICh0b29sdGlwUG9pbnQueCA8IGNlbnRlclBvaW50LngpIHtcbiAgXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgXHRcdFx0c3ViWCA9IDA7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCArIChvZmZzZXQueCArIGFuY2hvci54KSAqIDI7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH1cblxuICBcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQoc3ViWCwgc3ViWSwgdHJ1ZSkpLmFkZChvZmZzZXQpLmFkZChhbmNob3IpO1xuXG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG4gIFx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcbiAgXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG4gIFx0fSxcblxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcbiAgXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG4gIFx0fSxcblxuICBcdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cbiAgXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG4gIFx0fVxuXG4gIH0pO1xuXG4gIC8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuICAvLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4gIC8vIEluc3RhbnRpYXRlcyBhIGBUb29sdGlwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbiAgLy8gQGFsdGVybmF0aXZlXG4gIC8vIEBmYWN0b3J5IEwudG9vbHRpcChsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgYFRvb2x0aXBgIG9iamVjdCBnaXZlbiBgbGF0bG5nYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIG9wZW4gYW5kIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uLlxuICB2YXIgdG9vbHRpcCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgXHRyZXR1cm4gbmV3IFRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbiAgfTtcblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gIE1hcC5pbmNsdWRlKHtcblxuICBcdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcbiAgXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG4gIFx0Ly8gQGFsdGVybmF0aXZlXG4gIFx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuICBcdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuICBcdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG4gIFx0XHR0aGlzLl9pbml0T3ZlcmxheShUb29sdGlwLCB0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpXG4gIFx0XHQgIC5vcGVuT24odGhpcyk7XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuICBcdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG4gIFx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuICBcdFx0dG9vbHRpcC5jbG9zZSgpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fVxuXG4gIH0pO1xuXG4gIC8qXG4gICAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAgICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAgICpcbiAgICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAgICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gICAqIGBgYFxuICAgKi9cblxuICAvLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbiAgTGF5ZXIuaW5jbHVkZSh7XG5cbiAgXHQvLyBAbWV0aG9kIGJpbmRUb29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxUb29sdGlwLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuICBcdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcbiAgXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuICBcdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuICBcdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLmlzVG9vbHRpcE9wZW4oKSkge1xuICBcdFx0XHR0aGlzLnVuYmluZFRvb2x0aXAoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fdG9vbHRpcCA9IHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRoaXMuX3Rvb2x0aXAsIGNvbnRlbnQsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQgJiYgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKSkge1xuICBcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kVG9vbHRpcGAuXG4gIFx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnModHJ1ZSk7XG4gIFx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG4gIFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdF9pbml0VG9vbHRpcEludGVyYWN0aW9uczogZnVuY3Rpb24gKHJlbW92ZSkge1xuICBcdFx0aWYgKCFyZW1vdmUgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG4gIFx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG4gIFx0XHQgICAgZXZlbnRzID0ge1xuICBcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuICBcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuICBcdFx0ICAgIH07XG4gIFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcbiAgXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuICBcdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcbiAgXHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG4gIFx0XHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0XHR0aGlzLl9hZGRGb2N1c0xpc3RlbmVycygpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9hZGRGb2N1c0xpc3RlbmVycztcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuICBcdFx0fVxuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcbiAgXHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuICBcdFx0fVxuICBcdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcbiAgXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG4gIFx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG4gIFx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG4gIFx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XG4gIFx0XHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gdGhpcztcbiAgXHRcdFx0fVxuICBcdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fcHJlcGFyZU9wZW4obGF0bG5nKSkge1xuICBcdFx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuICBcdFx0XHRcdHRoaXMuX3Rvb2x0aXAub3Blbk9uKHRoaXMuX21hcCk7XG5cbiAgXHRcdFx0XHRpZiAodGhpcy5nZXRFbGVtZW50KSB7XG4gIFx0XHRcdFx0XHR0aGlzLl9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyKHRoaXMpO1xuICBcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5lYWNoTGF5ZXIpIHtcbiAgXHRcdFx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIsIHRoaXMpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcbiAgXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuICBcdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuY2xvc2UoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcbiAgXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG4gIFx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcC50b2dnbGUodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuICBcdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuICBcdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cbiAgXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG4gIFx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuICBcdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cbiAgXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcbiAgXHR9LFxuXG4gIFx0X2FkZEZvY3VzTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5nZXRFbGVtZW50KSB7XG4gIFx0XHRcdHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzT25MYXllcih0aGlzKTtcbiAgXHRcdH0gZWxzZSBpZiAodGhpcy5lYWNoTGF5ZXIpIHtcbiAgXHRcdFx0dGhpcy5lYWNoTGF5ZXIodGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyLCB0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2FkZEZvY3VzTGlzdGVuZXJzT25MYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgZWwgPSB0eXBlb2YgbGF5ZXIuZ2V0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiBsYXllci5nZXRFbGVtZW50KCk7XG4gIFx0XHRpZiAoZWwpIHtcbiAgXHRcdFx0b24oZWwsICdmb2N1cycsIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBsYXllcjtcbiAgXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG4gIFx0XHRcdH0sIHRoaXMpO1xuICBcdFx0XHRvbihlbCwgJ2JsdXInLCB0aGlzLmNsb3NlVG9vbHRpcCwgdGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBlbCA9IHR5cGVvZiBsYXllci5nZXRFbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIGxheWVyLmdldEVsZW1lbnQoKTtcbiAgXHRcdGlmIChlbCkge1xuICBcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aGlzLl90b29sdGlwLl9jb250YWluZXIuaWQpO1xuICBcdFx0fVxuICBcdH0sXG5cblxuICBcdF9vcGVuVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSWYgdGhlIG1hcCBpcyBtb3ZpbmcsIHdlIHdpbGwgc2hvdyB0aGUgdG9vbHRpcCBhZnRlciBpdCdzIGRvbmUuXG4gIFx0XHRpZiAodGhpcy5fbWFwLmRyYWdnaW5nICYmIHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSAmJiAhdGhpcy5fb3Blbk9uY2VGbGFnKSB7XG4gIFx0XHRcdHRoaXMuX29wZW5PbmNlRmxhZyA9IHRydWU7XG4gIFx0XHRcdHZhciB0aGF0ID0gdGhpcztcbiAgXHRcdFx0dGhpcy5fbWFwLm9uY2UoJ21vdmVlbmQnLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dGhhdC5fb3Blbk9uY2VGbGFnID0gZmFsc2U7XG4gIFx0XHRcdFx0dGhhdC5fb3BlblRvb2x0aXAoZSk7XG4gIFx0XHRcdH0pO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cbiAgXHRcdHRoaXMub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSA/IGUubGF0bG5nIDogdW5kZWZpbmVkKTtcbiAgXHR9LFxuXG4gIFx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nLCBjb250YWluZXJQb2ludCwgbGF5ZXJQb2ludDtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuICBcdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuICBcdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcbiAgXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBAY2xhc3MgRGl2SWNvblxuICAgKiBAYWthIEwuRGl2SWNvblxuICAgKiBAaW5oZXJpdHMgSWNvblxuICAgKlxuICAgKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICAgKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgbXlJY29uID0gTC5kaXZJY29uKHtjbGFzc05hbWU6ICdteS1kaXYtaWNvbid9KTtcbiAgICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAgICpcbiAgICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IGhhcyBhICdsZWFmbGV0LWRpdi1pY29uJyBDU1MgY2xhc3MgYW5kIGlzIHN0eWxlZCBhcyBhIGxpdHRsZSB3aGl0ZSBzcXVhcmUgd2l0aCBhIHNoYWRvdy5cbiAgICovXG5cbiAgdmFyIERpdkljb24gPSBJY29uLmV4dGVuZCh7XG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQHNlY3Rpb25cbiAgXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG4gIFx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG4gIFx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuICBcdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cbiAgXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcbiAgXHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuIEFsdGVybmF0aXZlbHksXG4gIFx0XHQvLyBhbiBpbnN0YW5jZSBvZiBgSFRNTEVsZW1lbnRgLlxuICBcdFx0aHRtbDogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG4gIFx0XHQvLyBPcHRpb25hbCByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgYmFja2dyb3VuZCwgaW4gcGl4ZWxzXG4gIFx0XHRiZ1BvczogbnVsbCxcblxuICBcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcbiAgXHR9LFxuXG4gIFx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcbiAgXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICBcdFx0XHRlbXB0eShkaXYpO1xuICBcdFx0XHRkaXYuYXBwZW5kQ2hpbGQob3B0aW9ucy5odG1sKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG4gIFx0XHRcdHZhciBiZ1BvcyA9IHRvUG9pbnQob3B0aW9ucy5iZ1Bvcyk7XG4gIFx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4JztcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpO1xuXG4gIFx0XHRyZXR1cm4gZGl2O1xuICBcdH0sXG5cbiAgXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhIGBEaXZJY29uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG4gIH1cblxuICBJY29uLkRlZmF1bHQgPSBJY29uRGVmYXVsdDtcblxuICAvKlxuICAgKiBAY2xhc3MgR3JpZExheWVyXG4gICAqIEBpbmhlcml0cyBMYXllclxuICAgKiBAYWthIEwuR3JpZExheWVyXG4gICAqXG4gICAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAgICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICAgKlxuICAgKlxuICAgKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAgICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gICAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAgICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICAgKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICAgKlxuICAgKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gICAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICpcbiAgICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICAgKiAgICAgICAgIHJldHVybiB0aWxlO1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICAgKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAgICogICAgICAgICB2YXIgZXJyb3I7XG4gICAqXG4gICAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAgICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICAgKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICAgKlxuICAgKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAgICogICAgICAgICB9LCAxMDAwKTtcbiAgICpcbiAgICogICAgICAgICByZXR1cm4gdGlsZTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VjdGlvblxuICAgKi9cblxuXG4gIHZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiB0aWxlU2l6ZTogTnVtYmVyfFBvaW50ID0gMjU2XG4gIFx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG4gIFx0XHR0aWxlU2l6ZTogMjU2LFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuICBcdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cbiAgXHRcdG9wYWNpdHk6IDEsXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSAoZGVwZW5kcylcbiAgXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG4gIFx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuICBcdFx0Ly8gYGZhbHNlYCBvdGhlcndpc2UgaW4gb3JkZXIgdG8gZGlzcGxheSBuZXcgdGlsZXMgX2R1cmluZ18gcGFubmluZywgc2luY2UgaXQgaXMgZWFzeSB0byBwYW4gb3V0c2lkZSB0aGVcbiAgXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG4gIFx0XHR1cGRhdGVXaGVuSWRsZTogQnJvd3Nlci5tb2JpbGUsXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cbiAgXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcbiAgXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG4gIFx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuICBcdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cbiAgXHRcdHpJbmRleDogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuICBcdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuICBcdFx0Ym91bmRzOiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcbiAgXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuICBcdFx0bWluWm9vbTogMCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcbiAgXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cbiAgXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcbiAgXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcbiAgXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG4gIFx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG4gIFx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWluTmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG4gIFx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG4gIFx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG4gIFx0XHQvLyBmcm9tIGBtaW5OYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG4gIFx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cbiAgXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG4gIFx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG4gIFx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuICBcdFx0Ly8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3RpbmdcbiAgXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG4gIFx0XHRub1dyYXA6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cbiAgXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuICBcdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG4gIFx0XHRjbGFzc05hbWU6ICcnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcbiAgXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cbiAgXHRcdGtlZXBCdWZmZXI6IDJcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cbiAgXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuICBcdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuICBcdFx0dGhpcy5fcmVzZXRWaWV3KCk7IC8vIGltcGxpY2l0IF91cGRhdGUoKSBjYWxsXG4gIFx0fSxcblxuICBcdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG4gIFx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgdGlsZSBsYXllcnMuXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuICBcdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0b0JhY2sodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpbGVzIGZvciB0aGlzIGxheWVyLlxuICBcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbb3BhY2l0eV0oI2dyaWRsYXllci1vcGFjaXR5KSBvZiB0aGUgZ3JpZCBsYXllci5cbiAgXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuICBcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuICBcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuICBcdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNncmlkbGF5ZXItemluZGV4KSBvZiB0aGUgZ3JpZCBsYXllci5cbiAgXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaXNMb2FkaW5nOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuICBcdGlzTG9hZGluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG4gIFx0Ly8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIHRpbGVzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXG4gIFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gIFx0XHRcdHZhciB0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgXHRcdFx0aWYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSkge1xuICBcdFx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0ge1xuICBcdFx0XHR2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuICBcdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG4gIFx0XHRcdG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuICBcdFx0fTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcbiAgXHRcdFx0Ly8gdXBkYXRlIHRpbGVzIG9uIG1vdmUsIGJ1dCBub3QgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIGdpdmVuIGludGVydmFsXG4gIFx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG4gIFx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gdGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gIFx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cbiAgXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG4gIFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuICBcdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcbiAgXHQvLyBpcyBzcGVjaWZpZWQsIGl0IG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGZpbmlzaGVkIGxvYWRpbmcgYW5kIGRyYXdpbmcuXG4gIFx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBcdH0sXG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG4gIFx0Ly8gTm9ybWFsaXplcyB0aGUgW3RpbGVTaXplIG9wdGlvbl0oI2dyaWRsYXllci10aWxlc2l6ZSkgaW50byBhIHBvaW50LiBVc2VkIGJ5IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QuXG4gIFx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICBcdFx0cmV0dXJuIHMgaW5zdGFuY2VvZiBQb2ludCA/IHMgOiBuZXcgUG9pbnQocywgcyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcbiAgXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuICBcdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cbiAgXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcbiAgXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG4gIFx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cbiAgXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuICBcdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuICBcdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuICBcdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcbiAgXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG4gIFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG4gIFx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG4gIFx0XHQgICAgbmV4dEZyYW1lID0gZmFsc2UsXG4gIFx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cbiAgXHRcdFx0c2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcbiAgXHRcdFx0aWYgKGZhZGUgPCAxKSB7XG4gIFx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpZiAodGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRoaXMuX29uT3BhcXVlVGlsZSh0aWxlKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cbiAgXHRcdGlmIChuZXh0RnJhbWUpIHtcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG4gIFx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbk9wYXF1ZVRpbGU6IGZhbHNlRm4sXG5cbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG4gIFx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG4gIFx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICBcdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcbiAgXHRcdFx0eiA9IE51bWJlcih6KTtcbiAgXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuICBcdFx0XHRcdHRoaXMuX2xldmVsc1t6XS5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tIC0gTWF0aC5hYnMoem9vbSAtIHopO1xuICBcdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG4gIFx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oeik7XG4gIFx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcbiAgXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcbiAgXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgXHRcdGlmICghbGV2ZWwpIHtcbiAgXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuICBcdFx0XHRsZXZlbC5lbCA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG4gIFx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuICBcdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuICBcdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG4gIFx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG4gIFx0XHRcdGZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG4gIFx0XHRcdHRoaXMuX29uQ3JlYXRlTGV2ZWwobGV2ZWwpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG4gIFx0XHRyZXR1cm4gbGV2ZWw7XG4gIFx0fSxcblxuICBcdF9vblVwZGF0ZUxldmVsOiBmYWxzZUZuLFxuXG4gIFx0X29uUmVtb3ZlTGV2ZWw6IGZhbHNlRm4sXG5cbiAgXHRfb25DcmVhdGVMZXZlbDogZmFsc2VGbixcblxuICBcdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBrZXksIHRpbGU7XG5cbiAgXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcbiAgXHRcdFx0em9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG4gIFx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRcdHRpbGUucmV0YWluID0gdGlsZS5jdXJyZW50O1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG4gIFx0XHRcdFx0aWYgKCF0aGlzLl9yZXRhaW5QYXJlbnQoY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogLSA1KSkge1xuICBcdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLnJldGFpbikge1xuICBcdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcbiAgXHRcdFx0XHRjb250aW51ZTtcbiAgXHRcdFx0fVxuICBcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuICBcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKE51bWJlcih6KSk7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXG4gIFx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgXHR9LFxuXG4gIFx0X3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcbiAgXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuICBcdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG4gIFx0XHQgICAgejIgPSB6IC0gMSxcbiAgXHRcdCAgICBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcbiAgXHRcdGNvb3JkczIueiA9ICt6MjtcblxuICBcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMyKSxcbiAgXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuICBcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuICBcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG4gIFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHoyID4gbWluWm9vbSkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5fcmV0YWluUGFyZW50KHgyLCB5MiwgejIsIG1pblpvb20pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fSxcblxuICBcdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcbiAgXHRcdFx0Zm9yICh2YXIgaiA9IDIgKiB5OyBqIDwgMiAqIHkgKyAyOyBqKyspIHtcblxuICBcdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG4gIFx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuICBcdFx0XHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKSxcbiAgXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cbiAgXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuICBcdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuICBcdFx0XHRcdFx0Y29udGludWU7XG5cbiAgXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcbiAgXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG4gIFx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihpLCBqLCB6ICsgMSwgbWF4Wm9vbSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgYW5pbWF0aW5nID0gZSAmJiAoZS5waW5jaCB8fCBlLmZseVRvKTtcbiAgXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG4gIFx0fSxcblxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG4gIFx0fSxcblxuICBcdF9jbGFtcFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBcdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcbiAgXHRcdFx0cmV0dXJuIG9wdGlvbnMubWluTmF0aXZlWm9vbTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcbiAgXHRcdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHpvb207XG4gIFx0fSxcblxuICBcdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuICBcdFx0dmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcbiAgXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuICBcdFx0ICAgICh0aGlzLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pKSB7XG4gIFx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20odGlsZVpvb20pO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgdGlsZVpvb21DaGFuZ2VkID0gdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nICYmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pO1xuXG4gIFx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG4gIFx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cbiAgXHRcdFx0aWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xuICBcdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG4gIFx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG4gIFx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlKGNlbnRlcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIW5vUHJ1bmUpIHtcbiAgXHRcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuICBcdFx0XHQvLyBhIHpvb20gYW5pbSBvciBhIHBpbmNoIGdlc3R1cmVcbiAgXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXMoY2VudGVyLCB6b29tKTtcbiAgXHR9LFxuXG4gIFx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xldmVscykge1xuICBcdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuICBcdFx0ICAgIHRyYW5zbGF0ZSA9IGxldmVsLm9yaWdpbi5tdWx0aXBseUJ5KHNjYWxlKVxuICBcdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG4gIFx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuICBcdFx0XHRzZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c2V0UG9zaXRpb24obGV2ZWwuZWwsIHRyYW5zbGF0ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXNldEdyaWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuICBcdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG4gIFx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcbiAgXHRcdGlmIChib3VuZHMpIHtcbiAgXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl93cmFwWCA9IGNycy53cmFwTG5nICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcbiAgXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuICBcdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuICBcdFx0XTtcbiAgXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuICBcdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG4gIFx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMV0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLnkpXG4gIFx0XHRdO1xuICBcdH0sXG5cbiAgXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBtYXBab29tID0gbWFwLl9hbmltYXRpbmdab29tID8gTWF0aC5tYXgobWFwLl9hbmltYXRlVG9ab29tLCBtYXAuZ2V0Wm9vbSgpKSA6IG1hcC5nZXRab29tKCksXG4gIFx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcbiAgXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG4gIFx0XHQgICAgaGFsZlNpemUgPSBtYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KHNjYWxlICogMik7XG5cbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG4gIFx0fSxcblxuICBcdC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuICBcdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gIFx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cbiAgXHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG4gIFx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG4gIFx0XHRpZiAodGhpcy5fdGlsZVpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cdC8vIGlmIG91dCBvZiBtaW56b29tL21heHpvb21cblxuICBcdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuICBcdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuICBcdFx0ICAgIHRpbGVDZW50ZXIgPSB0aWxlUmFuZ2UuZ2V0Q2VudGVyKCksXG4gIFx0XHQgICAgcXVldWUgPSBbXSxcbiAgXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcbiAgXHRcdCAgICBub1BydW5lUmFuZ2UgPSBuZXcgQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuICBcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cbiAgXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuICBcdFx0aWYgKCEoaXNGaW5pdGUodGlsZVJhbmdlLm1pbi54KSAmJlxuICBcdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJlxuICBcdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuICBcdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC55KSkpIHsgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gbG9hZCBhbiBpbmZpbml0ZSBudW1iZXIgb2YgdGlsZXMnKTsgfVxuXG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3JkcztcbiAgXHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhuZXcgUG9pbnQoYy54LCBjLnkpKSkge1xuICBcdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcbiAgXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG4gIFx0XHRpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHsgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pOyByZXR1cm47IH1cblxuICBcdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG4gIFx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG4gIFx0XHRcdGZvciAodmFyIGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcbiAgXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuICBcdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cbiAgXHRcdFx0XHRpZiAoIXRoaXMuX2lzVmFsaWRUaWxlKGNvb3JkcykpIHsgY29udGludWU7IH1cblxuICBcdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuICBcdFx0XHRcdGlmICh0aWxlKSB7XG4gIFx0XHRcdFx0XHR0aWxlLmN1cnJlbnQgPSB0cnVlO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuICBcdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICBcdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuICBcdFx0XHRpZiAoIXRoaXMuX2xvYWRpbmcpIHtcbiAgXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcbiAgXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuICBcdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG4gIFx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgXHRcdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuICBcdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcbiAgXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcbiAgXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZTtcbiAgXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcbiAgXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG4gIFx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuICBcdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuICBcdH0sXG5cbiAgXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuICBcdH0sXG5cbiAgXHRfdGlsZUNvb3Jkc1RvTndTZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcbiAgXHRcdCAgICBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkodGlsZVNpemUpLFxuICBcdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG4gIFx0XHQgICAgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSxcbiAgXHRcdCAgICBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopO1xuICBcdFx0cmV0dXJuIFtudywgc2VdO1xuICBcdH0sXG5cbiAgXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG4gIFx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIGJwID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxuICBcdFx0ICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoYnBbMF0sIGJwWzFdKTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG4gIFx0XHRcdGJvdW5kcyA9IHRoaXMuX21hcC53cmFwTGF0TG5nQm91bmRzKGJvdW5kcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gYm91bmRzO1xuICBcdH0sXG4gIFx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG4gIFx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0cmV0dXJuIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnkgKyAnOicgKyBjb29yZHMuejtcbiAgXHR9LFxuXG4gIFx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcbiAgXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuICBcdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuICBcdFx0Y29vcmRzLnogPSAra1syXTtcbiAgXHRcdHJldHVybiBjb29yZHM7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHJlbW92ZSh0aWxlLmVsKTtcblxuICBcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG5cbiAgXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG4gIFx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG4gIFx0XHRcdHRpbGU6IHRpbGUuZWwsXG4gIFx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcbiAgXHRcdH0pO1xuICBcdH0sXG5cbiAgXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG4gIFx0XHRhZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cbiAgXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4JztcbiAgXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cbiAgXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG4gIFx0XHR0aWxlLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcblxuICBcdFx0Ly8gdXBkYXRlIG9wYWNpdHkgb24gdGlsZXMgaW4gSUU3LTggYmVjYXVzZSBvZiBmaWx0ZXIgaW5oZXJpdGFuY2UgcHJvYmxlbXNcbiAgXHRcdGlmIChCcm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuICBcdFx0XHRzZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuICBcdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG4gIFx0XHQgICAga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cbiAgXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG4gIFx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuICBcdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcbiAgXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2VcbiAgXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuICBcdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuICBcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcbiAgXHRcdH1cblxuICBcdFx0c2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cbiAgXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuICBcdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcbiAgXHRcdFx0ZWw6IHRpbGUsXG4gIFx0XHRcdGNvb3JkczogY29vcmRzLFxuICBcdFx0XHRjdXJyZW50OiB0cnVlXG4gIFx0XHR9O1xuXG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG4gIFx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuICBcdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuICBcdFx0XHR0aWxlOiB0aWxlLFxuICBcdFx0XHRjb29yZHM6IGNvb3Jkc1xuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuICBcdFx0aWYgKGVycikge1xuICBcdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuICBcdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcbiAgXHRcdFx0XHRlcnJvcjogZXJyLFxuICBcdFx0XHRcdHRpbGU6IHRpbGUsXG4gIFx0XHRcdFx0Y29vcmRzOiBjb29yZHNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuICBcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aWxlLmVsLCAwKTtcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG4gIFx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG4gIFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFlcnIpIHtcbiAgXHRcdFx0YWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuICBcdFx0XHQvLyBAZXZlbnQgdGlsZWxvYWQ6IFRpbGVFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cbiAgXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcbiAgXHRcdFx0XHR0aWxlOiB0aWxlLmVsLFxuICBcdFx0XHRcdGNvb3JkczogY29vcmRzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG4gIFx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcbiAgXHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuICBcdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuICBcdFx0XHRpZiAoQnJvd3Nlci5pZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcbiAgXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcbiAgXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cbiAgXHRcdFx0XHRzZXRUaW1lb3V0KGJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG4gIFx0fSxcblxuICBcdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuICBcdFx0XHR0aGlzLl93cmFwWCA/IHdyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuICBcdFx0XHR0aGlzLl93cmFwWSA/IHdyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcbiAgXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG4gIFx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuICBcdH0sXG5cbiAgXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG4gIFx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuICBcdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuICBcdH0sXG5cbiAgXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbiAgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IEdyaWRMYXllcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIFRpbGVMYXllclxyXG4gICAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICAgKiBAYWthIEwuVGlsZUxheWVyXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIE5vdGUgdGhhdCBtb3N0IHRpbGUgc2VydmVycyByZXF1aXJlIGF0dHJpYnV0aW9uLCB3aGljaCB5b3UgY2FuIHNldCB1bmRlciBgTGF5ZXJgLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8vdGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJywgYXR0cmlidXRpb246ICcmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycyd9KS5hZGRUbyhtYXApO1xuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiAnaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gICAqXHJcbiAgICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiBMLnRpbGVMYXllcignaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuICBcdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcbiAgXHRcdG1pblpvb206IDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcbiAgXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuICBcdFx0bWF4Wm9vbTogMTgsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcbiAgXHRcdC8vIFN1YmRvbWFpbnMgb2YgdGhlIHRpbGUgc2VydmljZS4gQ2FuIGJlIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBvbmUgc3RyaW5nICh3aGVyZSBlYWNoIGxldHRlciBpcyBhIHN1YmRvbWFpbiBuYW1lKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG4gIFx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG4gIFx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcbiAgXHRcdC8vIFRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIG9mZnNldCB3aXRoIHRoaXMgdmFsdWUuXHJcbiAgXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgaW52ZXJzZXMgWSBheGlzIG51bWJlcmluZyBmb3IgdGlsZXMgKHR1cm4gdGhpcyBvbiBmb3IgW1RNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZSkgc2VydmljZXMpLlxyXG4gIFx0XHR0bXM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcclxuICBcdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAgYW5kIHVzZXIgaXMgb24gYSByZXRpbmEgZGlzcGxheSwgaXQgd2lsbCByZXF1ZXN0IGZvdXIgdGlsZXMgb2YgaGFsZiB0aGUgc3BlY2lmaWVkIHNpemUgYW5kIGEgYmlnZ2VyIHpvb20gbGV2ZWwgaW4gcGxhY2Ugb2Ygb25lIHRvIHV0aWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbi5cclxuICBcdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG4gIFx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmVmZXJyZXJQb2xpY3k6IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgcmVmZXJyZXJQb2xpY3kgYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG4gIFx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciByZWZlcnJlclBvbGljeSBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuXHJcbiAgXHRcdC8vIFRoaXMgbWF5IGJlIG5lZWRlZCBpZiB5b3VyIG1hcCdzIHJlbmRlcmluZyBjb250ZXh0IGhhcyBhIHN0cmljdCBkZWZhdWx0IGJ1dCB5b3VyIHRpbGUgcHJvdmlkZXIgZXhwZWN0cyBhIHZhbGlkIHJlZmVycmVyXHJcbiAgXHRcdC8vIChlLmcuIHRvIHZhbGlkYXRlIGFuIEFQSSB0b2tlbikuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtIVE1MSW1hZ2VFbGVtZW50LnJlZmVycmVyUG9saWN5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudC9yZWZlcnJlclBvbGljeSkgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdHJlZmVycmVyUG9saWN5OiBmYWxzZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuICBcdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcbiAgXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuICBcdFx0XHRpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuICBcdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG4gIFx0XHRcdFx0b3B0aW9ucy5tYXhab29tID0gTWF0aC5tYXgob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20gLSAxKTtcclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0LS07XHJcbiAgXHRcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSArIDEpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5ab29tKTtcclxuICBcdFx0fSBlbHNlIGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG4gIFx0XHRcdC8vIG1ha2Ugc3VyZSBtYXhab29tIGlzIGd0ZSBtaW5ab29tXHJcbiAgXHRcdFx0b3B0aW9ucy5tYXhab29tID0gTWF0aC5tYXgob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20pO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdC8vIG1ha2Ugc3VyZSBtaW5ab29tIGlzIGx0ZSBtYXhab29tXHJcbiAgXHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCBvcHRpb25zLm1pblpvb20pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cclxuICBcdC8vIElmIHRoZSBVUkwgZG9lcyBub3QgY2hhbmdlLCB0aGUgbGF5ZXIgd2lsbCBub3QgYmUgcmVkcmF3biB1bmxlc3NcclxuICBcdC8vIHRoZSBub1JlZHJhdyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGZhbHNlLlxyXG4gIFx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG4gIFx0XHRpZiAodGhpcy5fdXJsID09PSB1cmwgJiYgbm9SZWRyYXcgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdG5vUmVkcmF3ID0gdHJ1ZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0aWYgKCFub1JlZHJhdykge1xyXG4gIFx0XHRcdHRoaXMucmVkcmF3KCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuICBcdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuICBcdC8vIHRvIHJldHVybiBhbiBgPGltZz5gIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBpbWFnZSBVUkwgZ2l2ZW4gYGNvb3Jkc2AuIFRoZSBgZG9uZWBcclxuICBcdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuICBcdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuICBcdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcbiAgXHRcdG9uKHRpbGUsICdsb2FkJywgYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcbiAgXHRcdG9uKHRpbGUsICdlcnJvcicsIGJpbmQodGhpcy5fdGlsZU9uRXJyb3IsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG4gIFx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gZm9yIHRoaXMgbmV3IG9wdGlvbiB3ZSBmb2xsb3cgdGhlIGRvY3VtZW50ZWQgYmVoYXZpb3JcclxuICBcdFx0Ly8gbW9yZSBjbG9zZWx5IGJ5IG9ubHkgc2V0dGluZyB0aGUgcHJvcGVydHkgd2hlbiBzdHJpbmdcclxuICBcdFx0aWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVmZXJyZXJQb2xpY3kgPT09ICdzdHJpbmcnKSB7XHJcbiAgXHRcdFx0dGlsZS5yZWZlcnJlclBvbGljeSA9IHRoaXMub3B0aW9ucy5yZWZlcnJlclBvbGljeTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gVGhlIGFsdCBhdHRyaWJ1dGUgaXMgc2V0IHRvIHRoZSBlbXB0eSBzdHJpbmcsXHJcbiAgXHRcdC8vIGFsbG93aW5nIHNjcmVlbiByZWFkZXJzIHRvIGlnbm9yZSB0aGUgZGVjb3JhdGl2ZSBpbWFnZSB0aWxlcy5cclxuICBcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS90dXRvcmlhbHMvaW1hZ2VzL2RlY29yYXRpdmUvXHJcbiAgXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sLWFyaWEvI2VsLWltZy1lbXB0eS1hbHRcclxuICBcdFx0dGlsZS5hbHQgPSAnJztcclxuXHJcbiAgXHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGlsZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICBcdC8vIEB1bmluaGVyaXRhYmxlXHJcbiAgXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIG1pZ2h0IHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRUaWxlVXJsKGNvb3JkczogT2JqZWN0KTogU3RyaW5nXHJcbiAgXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcbiAgXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSB0aWxlIFVSTCBuYW1pbmcgc2NoZW1lcy5cclxuICBcdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuICBcdFx0dmFyIGRhdGEgPSB7XHJcbiAgXHRcdFx0cjogQnJvd3Nlci5yZXRpbmEgPyAnQDJ4JyA6ICcnLFxyXG4gIFx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG4gIFx0XHRcdHg6IGNvb3Jkcy54LFxyXG4gIFx0XHRcdHk6IGNvb3Jkcy55LFxyXG4gIFx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG4gIFx0XHR9O1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLl9tYXAub3B0aW9ucy5jcnMuaW5maW5pdGUpIHtcclxuICBcdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuICBcdFx0XHRcdGRhdGFbJ3knXSA9IGludmVydGVkWTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0ZGF0YVsnLXknXSA9IGludmVydGVkWTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRlbXBsYXRlKHRoaXMuX3VybCwgZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdGlsZU9uTG9hZDogZnVuY3Rpb24gKGRvbmUsIHRpbGUpIHtcclxuICBcdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuICBcdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHtcclxuICBcdFx0XHRzZXRUaW1lb3V0KGJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGRvbmUobnVsbCwgdGlsZSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSwgZSkge1xyXG4gIFx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG4gIFx0XHRpZiAoZXJyb3JVcmwgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpICE9PSBlcnJvclVybCkge1xyXG4gIFx0XHRcdHRpbGUuc3JjID0gZXJyb3JVcmw7XHJcbiAgXHRcdH1cclxuICBcdFx0ZG9uZShlLCB0aWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uVGlsZVJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXHJcbiAgXHRcdG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbSxcclxuICBcdFx0em9vbVJldmVyc2UgPSB0aGlzLm9wdGlvbnMuem9vbVJldmVyc2UsXHJcbiAgXHRcdHpvb21PZmZzZXQgPSB0aGlzLm9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcbiAgXHRcdGlmICh6b29tUmV2ZXJzZSkge1xyXG4gIFx0XHRcdHpvb20gPSBtYXhab29tIC0gem9vbTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHpvb20gKyB6b29tT2Zmc2V0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcbiAgXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnNbaW5kZXhdO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBzdG9wcyBsb2FkaW5nIGFsbCB0aWxlcyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxyXG4gIFx0X2Fib3J0TG9hZGluZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaSwgdGlsZTtcclxuICBcdFx0Zm9yIChpIGluIHRoaXMuX3RpbGVzKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xyXG4gIFx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuICBcdFx0XHRcdHRpbGUub25sb2FkID0gZmFsc2VGbjtcclxuICBcdFx0XHRcdHRpbGUub25lcnJvciA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHRcdFx0aWYgKCF0aWxlLmNvbXBsZXRlKSB7XHJcbiAgXHRcdFx0XHRcdHRpbGUuc3JjID0gZW1wdHlJbWFnZVVybDtcclxuICBcdFx0XHRcdFx0dmFyIGNvb3JkcyA9IHRoaXMuX3RpbGVzW2ldLmNvb3JkcztcclxuICBcdFx0XHRcdFx0cmVtb3ZlKHRpbGUpO1xyXG4gIFx0XHRcdFx0XHRkZWxldGUgdGhpcy5fdGlsZXNbaV07XHJcbiAgXHRcdFx0XHRcdC8vIEBldmVudCB0aWxlYWJvcnQ6IFRpbGVFdmVudFxyXG4gIFx0XHRcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSB3YXMgbG9hZGluZyBidXQgaXMgbm93IG5vdCB3YW50ZWQuXHJcbiAgXHRcdFx0XHRcdHRoaXMuZmlyZSgndGlsZWFib3J0Jywge1xyXG4gIFx0XHRcdFx0XHRcdHRpbGU6IHRpbGUsXHJcbiAgXHRcdFx0XHRcdFx0Y29vcmRzOiBjb29yZHNcclxuICBcdFx0XHRcdFx0fSk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuICBcdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gQ2FuY2VscyBhbnkgcGVuZGluZyBodHRwIHJlcXVlc3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdGlsZVxyXG4gIFx0XHR0aWxlLmVsLnNldEF0dHJpYnV0ZSgnc3JjJywgZW1wdHlJbWFnZVVybCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fcmVtb3ZlVGlsZS5jYWxsKHRoaXMsIGtleSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCB8fCAodGlsZSAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgPT09IGVtcHR5SW1hZ2VVcmwpKSB7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fdGlsZVJlYWR5LmNhbGwodGhpcywgY29vcmRzLCBlcnIsIHRpbGUpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC50aWxlbGF5ZXIodXJsVGVtcGxhdGU6IFN0cmluZywgb3B0aW9ucz86IFRpbGVMYXllciBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG4gIGZ1bmN0aW9uIHRpbGVMYXllcih1cmwsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICAgKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAgICogQGFrYSBMLlRpbGVMYXllci5XTVNcclxuICAgKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIG5leHJhZCA9IEwudGlsZUxheWVyLndtcyhcImh0dHA6Ly9tZXNvbmV0LmFncm9uLmlhc3RhdGUuZWR1L2NnaS1iaW4vd21zL25leHJhZC9uMHIuY2dpXCIsIHtcclxuICAgKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICAgKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAgICogXHR0cmFuc3BhcmVudDogdHJ1ZSxcclxuICAgKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgVGlsZUxheWVyV01TID0gVGlsZUxheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcbiAgXHQvLyBJZiBhbnkgY3VzdG9tIG9wdGlvbnMgbm90IGRvY3VtZW50ZWQgaGVyZSBhcmUgdXNlZCwgdGhleSB3aWxsIGJlIHNlbnQgdG8gdGhlXHJcbiAgXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG4gIFx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHBzOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcbiAgXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcbiAgXHRcdHNlcnZpY2U6ICdXTVMnLFxyXG4gIFx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyAqKihyZXF1aXJlZCkqKiBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgbGF5ZXJzIHRvIHNob3cuXHJcbiAgXHRcdGxheWVyczogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHN0eWxlczogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIHN0eWxlcy5cclxuICBcdFx0c3R5bGVzOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZm9ybWF0OiBTdHJpbmcgPSAnaW1hZ2UvanBlZydcclxuICBcdFx0Ly8gV01TIGltYWdlIGZvcm1hdCAodXNlIGAnaW1hZ2UvcG5nJ2AgZm9yIGxheWVycyB3aXRoIHRyYW5zcGFyZW5jeSkuXHJcbiAgXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB0cmFuc3BhcmVudDogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIFdNUyBzZXJ2aWNlIHdpbGwgcmV0dXJuIGltYWdlcyB3aXRoIHRyYW5zcGFyZW5jeS5cclxuICBcdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB2ZXJzaW9uOiBTdHJpbmcgPSAnMS4xLjEnXHJcbiAgXHRcdC8vIFZlcnNpb24gb2YgdGhlIFdNUyBzZXJ2aWNlIHRvIHVzZVxyXG4gIFx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcbiAgXHR9LFxyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuICBcdFx0Ly8gQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIHRvIHVzZSBmb3IgdGhlIFdNUyByZXF1ZXN0cywgZGVmYXVsdHMgdG9cclxuICBcdFx0Ly8gbWFwIENSUy4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcbiAgXHRcdGNyczogbnVsbCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdXBwZXJjYXNlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCBXTVMgcmVxdWVzdCBwYXJhbWV0ZXIga2V5cyB3aWxsIGJlIHVwcGVyY2FzZS5cclxuICBcdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHR2YXIgd21zUGFyYW1zID0gZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpO1xyXG5cclxuICBcdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuICBcdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcbiAgXHRcdFx0aWYgKCEoaSBpbiB0aGlzLm9wdGlvbnMpKSB7XHJcbiAgXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XHJcbiAgXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcclxuICBcdFx0d21zUGFyYW1zLndpZHRoID0gdGlsZVNpemUueCAqIHJlYWxSZXRpbmE7XHJcbiAgXHRcdHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZS55ICogcmVhbFJldGluYTtcclxuXHJcbiAgXHRcdHRoaXMud21zUGFyYW1zID0gd21zUGFyYW1zO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuICBcdFx0dGhpcy5fY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XHJcbiAgXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuICBcdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcbiAgXHRcdHRoaXMud21zUGFyYW1zW3Byb2plY3Rpb25LZXldID0gdGhpcy5fY3JzLmNvZGU7XHJcblxyXG4gIFx0XHRUaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cclxuICBcdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXHJcbiAgXHRcdCAgICBjcnMgPSB0aGlzLl9jcnMsXHJcbiAgXHRcdCAgICBib3VuZHMgPSB0b0JvdW5kcyhjcnMucHJvamVjdCh0aWxlQm91bmRzWzBdKSwgY3JzLnByb2plY3QodGlsZUJvdW5kc1sxXSkpLFxyXG4gIFx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuICBcdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcbiAgXHRcdCAgICBiYm94ID0gKHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zICYmIHRoaXMuX2NycyA9PT0gRVBTRzQzMjYgP1xyXG4gIFx0XHQgICAgW21pbi55LCBtaW4ueCwgbWF4LnksIG1heC54XSA6XHJcbiAgXHRcdCAgICBbbWluLngsIG1pbi55LCBtYXgueCwgbWF4LnldKS5qb2luKCcsJyksXHJcbiAgXHRcdCAgICB1cmwgPSBUaWxlTGF5ZXIucHJvdG90eXBlLmdldFRpbGVVcmwuY2FsbCh0aGlzLCBjb29yZHMpO1xyXG4gIFx0XHRyZXR1cm4gdXJsICtcclxuICBcdFx0XHRnZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcbiAgXHRcdFx0KHRoaXMub3B0aW9ucy51cHBlcmNhc2UgPyAnJkJCT1g9JyA6ICcmYmJveD0nKSArIGJib3g7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcbiAgXHQvLyBNZXJnZXMgYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBwYXJhbWV0ZXJzIGFuZCByZS1yZXF1ZXN0cyB0aWxlcyBvbiB0aGUgY3VycmVudCBzY3JlZW4gKHVubGVzcyBgbm9SZWRyYXdgIHdhcyBzZXQgdG8gdHJ1ZSkuXHJcbiAgXHRzZXRQYXJhbXM6IGZ1bmN0aW9uIChwYXJhbXMsIG5vUmVkcmF3KSB7XHJcblxyXG4gIFx0XHRleHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG4gIFx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcbiAgXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLnRpbGVMYXllci53bXMoYmFzZVVybDogU3RyaW5nLCBvcHRpb25zOiBUaWxlTGF5ZXIuV01TIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgV01TIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYmFzZSBVUkwgb2YgdGhlIFdNUyBzZXJ2aWNlIGFuZCBhIFdNUyBwYXJhbWV0ZXJzL29wdGlvbnMgb2JqZWN0LlxyXG4gIGZ1bmN0aW9uIHRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgVGlsZUxheWVyV01TKHVybCwgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIFRpbGVMYXllci5XTVMgPSBUaWxlTGF5ZXJXTVM7XG4gIHRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5cbiAgLypcbiAgICogQGNsYXNzIFJlbmRlcmVyXG4gICAqIEBpbmhlcml0cyBMYXllclxuICAgKiBAYWthIEwuUmVuZGVyZXJcbiAgICpcbiAgICogQmFzZSBjbGFzcyBmb3IgdmVjdG9yIHJlbmRlcmVyIGltcGxlbWVudGF0aW9ucyAoYFNWR2AsIGBDYW52YXNgKS4gSGFuZGxlcyB0aGVcbiAgICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gICAqXG4gICAqIEEgYFJlbmRlcmVyYCB3b3JrcyBhcyBhbiBpbXBsaWNpdCBsYXllciBncm91cCBmb3IgYWxsIGBQYXRoYHMgLSB0aGUgcmVuZGVyZXJcbiAgICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gICAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAgICogb3IgZXhwbGljaXQgKHVzaW5nIHRoZSBbYHJlbmRlcmVyYF0oI3BhdGgtcmVuZGVyZXIpIG9wdGlvbiBvZiB0aGUgcGF0aCkuXG4gICAqXG4gICAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICAgKiBGaXJlZCB3aGVuIHRoZSByZW5kZXJlciB1cGRhdGVzIGl0cyBib3VuZHMsIGNlbnRlciBhbmQgem9vbSwgZm9yIGV4YW1wbGUgd2hlblxuICAgKiBpdHMgbWFwIGhhcyBtb3ZlZFxuICAgKi9cblxuICB2YXIgUmVuZGVyZXIgPSBMYXllci5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuICBcdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG4gIFx0XHQvLyBlLmcuIDAuMSB3b3VsZCBiZSAxMCUgb2YgbWFwIHZpZXcgaW4gZWFjaCBkaXJlY3Rpb25cbiAgXHRcdHBhZGRpbmc6IDAuMVxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHN0YW1wKHRoaXMpO1xuICBcdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgXHRcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpOyAvLyBkZWZpbmVkIGJ5IHJlbmRlcmVyIGltcGxlbWVudGF0aW9uc1xuXG4gIFx0XHRcdC8vIGFsd2F5cyBrZWVwIHRyYW5zZm9ybS1vcmlnaW4gYXMgMCAwXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuICBcdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSB7XG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXQsXG4gIFx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcbiAgXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuICBcdFx0XHR6b29tZW5kOiB0aGlzLl9vblpvb21FbmRcbiAgXHRcdH07XG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG4gIFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX29uQW5pbVpvb207XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xuICBcdH0sXG5cbiAgXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG4gIFx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcbiAgXHR9LFxuXG4gIFx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG4gIFx0XHQgICAgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41ICsgdGhpcy5vcHRpb25zLnBhZGRpbmcpLFxuICBcdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cbiAgXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChjdXJyZW50Q2VudGVyUG9pbnQpXG4gIFx0XHRcdFx0ICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKTtcblxuICBcdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcbiAgXHRcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcmVzZXQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Byb2plY3QoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuICBcdFx0Ly8gU3ViY2xhc3NlcyBhcmUgcmVzcG9uc2libGUgb2YgZmlyaW5nIHRoZSAndXBkYXRlJyBldmVudC5cbiAgXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG4gIFx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG4gIFx0XHQgICAgbWluID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHNpemUubXVsdGlwbHlCeSgtcCkpLnJvdW5kKCk7XG5cbiAgXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuICBcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICBcdFx0dGhpcy5fem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBAY2xhc3MgQ2FudmFzXG4gICAqIEBpbmhlcml0cyBSZW5kZXJlclxuICAgKiBAYWthIEwuQ2FudmFzXG4gICAqXG4gICAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gICAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gICAqXG4gICAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwczovL2Nhbml1c2UuY29tL2NhbnZhcyksIENhbnZhcyBpcyBub3RcbiAgICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgSUU4LCBhbmQgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcyBtaWdodFxuICAgKiBub3QgZGlzcGxheSBwcm9wZXJseSBpbiBzb21lIGVkZ2UgY2FzZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICAgKiBcdHJlbmRlcmVyOiBMLmNhbnZhcygpXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVXNlIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gICAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gICAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgQ2FudmFzID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBDYW52YXMgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gdG9sZXJhbmNlOiBOdW1iZXIgPSAwXG4gIFx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaWNrIHRvbGVyYW5jZSBhcm91bmQgYSBwYXRoL29iamVjdCBvbiB0aGUgbWFwLlxuICBcdFx0dG9sZXJhbmNlOiAwXG4gIFx0fSxcblxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcbiAgXHRcdGV2ZW50cy52aWV3cHJlcmVzZXQgPSB0aGlzLl9vblZpZXdQcmVSZXNldDtcbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdF9vblZpZXdQcmVSZXNldDogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gU2V0IGEgZmxhZyBzbyB0aGF0IGEgdmlld3ByZXJlc2V0K21vdmVlbmQrdmlld3Jlc2V0IG9ubHkgdXBkYXRlcyZyZWRyYXdzIG9uY2VcbiAgXHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSB0cnVlO1xuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyk7XG5cbiAgXHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcbiAgXHRcdC8vIGluIGNhc2Ugb2YgcmVtb3ZpbmcgdGhlIHJlbmRlcmVyIGl0c2VsZiBmcm9tIHRoZSBtYXAuXG4gIFx0XHR0aGlzLl9kcmF3KCk7XG4gIFx0fSxcblxuICBcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgXHRcdG9uKGNvbnRhaW5lciwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51JywgdGhpcy5fb25DbGljaywgdGhpcyk7XG4gIFx0XHRvbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcbiAgXHRcdGNvbnRhaW5lclsnX2xlYWZsZXRfZGlzYWJsZV9ldmVudHMnXSA9IHRydWU7XG5cbiAgXHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuICBcdH0sXG5cbiAgXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3JlZHJhd1JlcXVlc3QpO1xuICBcdFx0ZGVsZXRlIHRoaXMuX2N0eDtcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0b2ZmKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbGF5ZXI7XG4gIFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gIFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcbiAgXHRcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuICBcdFx0fVxuICBcdFx0dGhpcy5fcmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gIFx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG4gIFx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuICBcdFx0ICAgIG0gPSBCcm93c2VyLnJldGluYSA/IDIgOiAxO1xuXG4gIFx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblxuICBcdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuICBcdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcbiAgXHRcdGNvbnRhaW5lci5oZWlnaHQgPSBtICogc2l6ZS55O1xuICBcdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4JztcbiAgXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG4gIFx0XHRpZiAoQnJvd3Nlci5yZXRpbmEpIHtcbiAgXHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyB0cmFuc2xhdGUgc28gd2UgdXNlIHRoZSBzYW1lIHBhdGggY29vcmRpbmF0ZXMgYWZ0ZXIgY2FudmFzIGVsZW1lbnQgbW92ZXNcbiAgXHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuICBcdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuICBcdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcyk7XG5cbiAgXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7XG4gIFx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUGF0aHMoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG4gIFx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXG4gIFx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG4gIFx0XHRcdGxheWVyOiBsYXllcixcbiAgXHRcdFx0cHJldjogdGhpcy5fZHJhd0xhc3QsXG4gIFx0XHRcdG5leHQ6IG51bGxcbiAgXHRcdH07XG4gIFx0XHRpZiAodGhpcy5fZHJhd0xhc3QpIHsgdGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyOyB9XG4gIFx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuICBcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gdGhpcy5fZHJhd0ZpcnN0IHx8IHRoaXMuX2RyYXdMYXN0O1xuICBcdH0sXG5cbiAgXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuICBcdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuICBcdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG4gIFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuICBcdFx0fVxuICBcdFx0aWYgKHByZXYpIHtcbiAgXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG4gIFx0XHR9XG5cbiAgXHRcdGRlbGV0ZSBsYXllci5fb3JkZXI7XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblxuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG4gIFx0XHQvLyBib3VuZHMgYW5kIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuICBcdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcbiAgXHRcdGxheWVyLl9wcm9qZWN0KCk7XG4gIFx0XHRsYXllci5fdXBkYXRlKCk7XG4gIFx0XHQvLyBUaGUgcmVkcmF3IHdpbGwgZXh0ZW5kIHRoZSByZWRyYXcgYm91bmRzXG4gIFx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fSxcblxuICBcdF91cGRhdGVEYXNoQXJyYXk6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKHR5cGVvZiBsYXllci5vcHRpb25zLmRhc2hBcnJheSA9PT0gJ3N0cmluZycpIHtcbiAgXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksXG4gIFx0XHRcdCAgICBkYXNoQXJyYXkgPSBbXSxcbiAgXHRcdFx0ICAgIGRhc2hWYWx1ZSxcbiAgXHRcdFx0ICAgIGk7XG4gIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICBcdFx0XHRcdGRhc2hWYWx1ZSA9IE51bWJlcihwYXJ0c1tpXSk7XG4gIFx0XHRcdFx0Ly8gSWdub3JlIGRhc2ggYXJyYXkgY29udGFpbmluZyBpbnZhbGlkIGxlbmd0aHNcbiAgXHRcdFx0XHRpZiAoaXNOYU4oZGFzaFZhbHVlKSkgeyByZXR1cm47IH1cbiAgXHRcdFx0XHRkYXNoQXJyYXkucHVzaChkYXNoVmFsdWUpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGRhc2hBcnJheTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5O1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcbiAgXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X2V4dGVuZFJlZHJhd0JvdW5kczogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAobGF5ZXIuX3B4Qm91bmRzKSB7XG4gIFx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcbiAgXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzIHx8IG5ldyBCb3VuZHMoKTtcbiAgXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gbnVsbDtcblxuICBcdFx0aWYgKHRoaXMuX3JlZHJhd0JvdW5kcykge1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWF4Ll9jZWlsKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG4gIFx0XHR0aGlzLl9kcmF3KCk7IC8vIGRyYXcgbGF5ZXJzXG5cbiAgXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG4gIFx0fSxcblxuICBcdF9jbGVhcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcbiAgXHRcdGlmIChib3VuZHMpIHtcbiAgXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuICBcdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuICBcdFx0XHR0aGlzLl9jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICBcdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NvbnRhaW5lci53aWR0aCwgdGhpcy5fY29udGFpbmVyLmhlaWdodCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9kcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbGF5ZXIsIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcbiAgXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG4gIFx0XHRpZiAoYm91bmRzKSB7XG4gIFx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcbiAgXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuICBcdFx0XHR0aGlzLl9jdHgucmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuICBcdFx0XHR0aGlzLl9jdHguY2xpcCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9kcmF3aW5nID0gdHJ1ZTtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKCFib3VuZHMgfHwgKGxheWVyLl9weEJvdW5kcyAmJiBsYXllci5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSkge1xuICBcdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuXG4gIFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG4gIFx0fSxcblxuICBcdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuICBcdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgaSwgaiwgbGVuMiwgcCxcbiAgXHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcbiAgXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG4gIFx0XHQgICAgY3R4ID0gdGhpcy5fY3R4O1xuXG4gIFx0XHRpZiAoIWxlbikgeyByZXR1cm47IH1cblxuICBcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICBcdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcbiAgXHRcdFx0XHRjdHhbaiA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHAueCwgcC55KTtcbiAgXHRcdFx0fVxuICBcdFx0XHRpZiAoY2xvc2VkKSB7XG4gIFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cbiAgXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuICBcdFx0aWYgKCF0aGlzLl9kcmF3aW5nIHx8IGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcbiAgXHRcdCAgICBjdHggPSB0aGlzLl9jdHgsXG4gIFx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuICBcdFx0ICAgIHMgPSAoTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIpIC8gcjtcblxuICBcdFx0aWYgKHMgIT09IDEpIHtcbiAgXHRcdFx0Y3R4LnNhdmUoKTtcbiAgXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuICBcdFx0fVxuXG4gIFx0XHRjdHguYmVnaW5QYXRoKCk7XG4gIFx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuICBcdFx0aWYgKHMgIT09IDEpIHtcbiAgXHRcdFx0Y3R4LnJlc3RvcmUoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG4gIFx0XHR2YXIgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cbiAgXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcbiAgXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcbiAgXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG9wdGlvbnMuc3Ryb2tlICYmIG9wdGlvbnMud2VpZ2h0ICE9PSAwKSB7XG4gIFx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcbiAgXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuICBcdFx0XHR9XG4gIFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMub3BhY2l0eTtcbiAgXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xuICBcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuICBcdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcbiAgXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcbiAgXHRcdFx0Y3R4LnN0cm9rZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBDYW52YXMgb2J2aW91c2x5IGRvZXNuJ3QgaGF2ZSBtb3VzZSBldmVudHMgZm9yIGluZGl2aWR1YWwgZHJhd24gb2JqZWN0cyxcbiAgXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuICBcdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksIGxheWVyLCBjbGlja2VkTGF5ZXI7XG5cbiAgXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG4gIFx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG4gIFx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuICBcdFx0XHRcdGlmICghKGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdwcmVjbGljaycpIHx8ICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuICBcdFx0XHRcdFx0Y2xpY2tlZExheWVyID0gbGF5ZXI7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl9maXJlRXZlbnQoY2xpY2tlZExheWVyID8gW2NsaWNrZWRMYXllcl0gOiBmYWxzZSwgZSk7XG4gIFx0fSxcblxuICBcdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuICBcdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG4gIFx0fSxcblxuXG4gIFx0X2hhbmRsZU1vdXNlT3V0OiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuICBcdFx0aWYgKGxheWVyKSB7XG4gIFx0XHRcdC8vIGlmIHdlJ3JlIGxlYXZpbmcgdGhlIGxheWVyLCBmaXJlIG1vdXNlb3V0XG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcbiAgXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuICBcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBudWxsO1xuICBcdFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9oYW5kbGVNb3VzZUhvdmVyOiBmdW5jdGlvbiAoZSwgcG9pbnQpIHtcbiAgXHRcdGlmICh0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGxheWVyLCBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cbiAgXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG4gIFx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG4gIFx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuICBcdFx0XHRcdGNhbmRpZGF0ZUhvdmVyZWRMYXllciA9IGxheWVyO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgIT09IHRoaXMuX2hvdmVyZWRMYXllcikge1xuICBcdFx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlKTtcblxuICBcdFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyKSB7XG4gIFx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpOyAvLyBjaGFuZ2UgY3Vyc29yXG4gIFx0XHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjYW5kaWRhdGVIb3ZlcmVkTGF5ZXJdLCBlLCAnbW91c2VvdmVyJyk7XG4gIFx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2ZpcmVFdmVudCh0aGlzLl9ob3ZlcmVkTGF5ZXIgPyBbdGhpcy5faG92ZXJlZExheWVyXSA6IGZhbHNlLCBlKTtcblxuICBcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IHRydWU7XG4gIFx0XHRzZXRUaW1lb3V0KGJpbmQoZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gZmFsc2U7XG4gIFx0XHR9LCB0aGlzKSwgMzIpO1xuICBcdH0sXG5cbiAgXHRfZmlyZUV2ZW50OiBmdW5jdGlvbiAobGF5ZXJzLCBlLCB0eXBlKSB7XG4gIFx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcbiAgXHR9LFxuXG4gIFx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cbiAgXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcbiAgXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuICBcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdC8vIEFscmVhZHkgbGFzdFxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHRpZiAocHJldikge1xuICBcdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuICBcdFx0fSBlbHNlIGlmIChuZXh0KSB7XG4gIFx0XHRcdC8vIFVwZGF0ZSBmaXJzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcbiAgXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG4gIFx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG4gIFx0XHR9XG5cbiAgXHRcdG9yZGVyLnByZXYgPSB0aGlzLl9kcmF3TGFzdDtcbiAgXHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblxuICBcdFx0b3JkZXIubmV4dCA9IG51bGw7XG4gIFx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuICBcdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuICBcdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG4gIFx0XHRpZiAocHJldikge1xuICBcdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gQWxyZWFkeSBmaXJzdFxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuICBcdFx0fSBlbHNlIGlmIChwcmV2KSB7XG4gIFx0XHRcdC8vIFVwZGF0ZSBsYXN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuICBcdFx0XHQvLyBzaW5nbGUgZW50cnlcbiAgXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuICBcdFx0fVxuXG4gIFx0XHRvcmRlci5wcmV2ID0gbnVsbDtcblxuICBcdFx0b3JkZXIubmV4dCA9IHRoaXMuX2RyYXdGaXJzdDtcbiAgXHRcdHRoaXMuX2RyYXdGaXJzdC5wcmV2ID0gb3JkZXI7XG4gIFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBvcmRlcjtcblxuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICBmdW5jdGlvbiBjYW52YXMob3B0aW9ucykge1xuICBcdHJldHVybiBCcm93c2VyLmNhbnZhcyA/IG5ldyBDYW52YXMob3B0aW9ucykgOiBudWxsO1xuICB9XG5cbiAgLypcbiAgICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAgICovXG5cblxuICB2YXIgdm1sQ3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgXHR0cnkge1xuICBcdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcbiAgXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuICBcdFx0fTtcbiAgXHR9IGNhdGNoIChlKSB7XG4gIFx0XHQvLyBEbyBub3QgcmV0dXJuIGZuIGZyb20gY2F0Y2ggYmxvY2sgc28gYGVgIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICBcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvcHVsbC83Mjc5XG4gIFx0fVxuICBcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuICBcdH07XG4gIH0pKCk7XG5cblxuICAvKlxuICAgKiBAY2xhc3MgU1ZHXG4gICAqXG4gICAqXG4gICAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBvbGQgdmVyc2lvbnMgb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAqL1xuXG4gIC8vIG1peGluIHRvIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG4gIHZhciB2bWxNaXhpbiA9IHtcblxuICBcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcbiAgXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG4gIFx0fSxcblxuICBcdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciA9IHZtbENyZWF0ZSgnc2hhcGUnKTtcblxuICBcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cbiAgXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuICBcdFx0bGF5ZXIuX3BhdGggPSB2bWxDcmVhdGUoJ3BhdGgnKTtcbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcbiAgXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG4gIFx0fSxcblxuICBcdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuICBcdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG4gIFx0XHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuICBcdFx0cmVtb3ZlKGNvbnRhaW5lcik7XG4gIFx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG4gIFx0XHQgICAgZmlsbCA9IGxheWVyLl9maWxsLFxuICBcdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cbiAgXHRcdGNvbnRhaW5lci5zdHJva2VkID0gISFvcHRpb25zLnN0cm9rZTtcbiAgXHRcdGNvbnRhaW5lci5maWxsZWQgPSAhIW9wdGlvbnMuZmlsbDtcblxuICBcdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG4gIFx0XHRcdGlmICghc3Ryb2tlKSB7XG4gIFx0XHRcdFx0c3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSA9IHZtbENyZWF0ZSgnc3Ryb2tlJyk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG4gIFx0XHRcdHN0cm9rZS53ZWlnaHQgPSBvcHRpb25zLndlaWdodCArICdweCc7XG4gIFx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG4gIFx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuICBcdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBpc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG4gIFx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XG4gIFx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XG4gIFx0XHRcdH1cbiAgXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcbiAgXHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XG5cbiAgXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XG4gIFx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuICBcdFx0XHRsYXllci5fc3Ryb2tlID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuICBcdFx0XHRpZiAoIWZpbGwpIHtcbiAgXHRcdFx0XHRmaWxsID0gbGF5ZXIuX2ZpbGwgPSB2bWxDcmVhdGUoJ2ZpbGwnKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG4gIFx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuICBcdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXG4gIFx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcbiAgXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xuICBcdFx0XHRsYXllci5fZmlsbCA9IG51bGw7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIHAgPSBsYXllci5fcG9pbnQucm91bmQoKSxcbiAgXHRcdCAgICByID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSxcbiAgXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cbiAgXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcbiAgXHRcdFx0J0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgcjIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCkpO1xuICBcdH0sXG5cbiAgXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG4gIFx0XHRsYXllci5fcGF0aC52ID0gcGF0aDtcbiAgXHR9LFxuXG4gIFx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0b0Zyb250KGxheWVyLl9jb250YWluZXIpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dG9CYWNrKGxheWVyLl9jb250YWluZXIpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgY3JlYXRlID0gQnJvd3Nlci52bWwgPyB2bWxDcmVhdGUgOiBzdmdDcmVhdGU7XG5cbiAgLypcbiAgICogQGNsYXNzIFNWR1xuICAgKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAgICogQGFrYSBMLlNWR1xuICAgKlxuICAgKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxuICAgKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICAgKlxuICAgKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cHM6Ly9jYW5pdXNlLmNvbS9zdmcpLCBTVkcgaXMgbm90XG4gICAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IEFuZHJvaWQgMi54IGFuZCAzLnguXG4gICAqXG4gICAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gICAqIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpXG4gICAqIChhIG5vdyBkZXByZWNhdGVkIHRlY2hub2xvZ3kpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW5cbiAgICogdGhpcyBjYXNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBVc2UgU1ZHIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAgICogXHRyZW5kZXJlcjogTC5zdmcoKVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICAgKiB2YXIgbXlSZW5kZXJlciA9IEwuc3ZnKHsgcGFkZGluZzogMC41IH0pO1xuICAgKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIFNWRyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlKCdzdmcnKTtcblxuICBcdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cbiAgXHRcdHRoaXMuX3Jvb3RHcm91cCA9IGNyZWF0ZSgnZycpO1xuICBcdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG4gIFx0fSxcblxuICBcdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdG9mZih0aGlzLl9jb250YWluZXIpO1xuICBcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9yb290R3JvdXA7XG4gIFx0XHRkZWxldGUgdGhpcy5fc3ZnU2l6ZTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuICBcdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cbiAgXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuICBcdFx0aWYgKCF0aGlzLl9zdmdTaXplIHx8ICF0aGlzLl9zdmdTaXplLmVxdWFscyhzaXplKSkge1xuICBcdFx0XHR0aGlzLl9zdmdTaXplID0gc2l6ZTtcbiAgXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuICBcdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplLnkpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcbiAgXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuICBcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtiLm1pbi54LCBiLm1pbi55LCBzaXplLngsIHNpemUueV0uam9pbignICcpKTtcblxuICBcdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcbiAgXHR9LFxuXG4gIFx0Ly8gbWV0aG9kcyBiZWxvdyBhcmUgY2FsbGVkIGJ5IHZlY3RvciBsYXllcnMgaW1wbGVtZW50YXRpb25zXG5cbiAgXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCA9IGNyZWF0ZSgncGF0aCcpO1xuXG4gIFx0XHQvLyBAbmFtZXNwYWNlIFBhdGhcbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG4gIFx0XHQvLyBDdXN0b20gY2xhc3MgbmFtZSBzZXQgb24gYW4gZWxlbWVudC4gT25seSBmb3IgU1ZHIHJlbmRlcmVyLlxuICBcdFx0aWYgKGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gIFx0XHRcdGFkZENsYXNzKHBhdGgsIGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcbiAgXHRcdFx0YWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuICBcdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcbiAgXHR9LFxuXG4gIFx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCF0aGlzLl9yb290R3JvdXApIHsgdGhpcy5faW5pdENvbnRhaW5lcigpOyB9XG4gIFx0XHR0aGlzLl9yb290R3JvdXAuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuICBcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuICBcdH0sXG5cbiAgXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRyZW1vdmUobGF5ZXIuX3BhdGgpO1xuICBcdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRsYXllci5fcHJvamVjdCgpO1xuICBcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCxcbiAgXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuICBcdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG4gIFx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgb3B0aW9ucy53ZWlnaHQpO1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG4gIFx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcbiAgXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBvcHRpb25zLmRhc2hPZmZzZXQpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5Jywgb3B0aW9ucy5maWxsT3BhY2l0eSk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuICBcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgcG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG4gIFx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuICBcdFx0ICAgIHIyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIsXG4gIFx0XHQgICAgYXJjID0gJ2EnICsgciArICcsJyArIHIyICsgJyAwIDEsMCAnO1xuXG4gIFx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuICBcdFx0dmFyIGQgPSBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG4gIFx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG4gIFx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG4gIFx0XHRcdGFyYyArICgtciAqIDIpICsgJywwICc7XG5cbiAgXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuICBcdH0sXG5cbiAgXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG4gIFx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcbiAgXHR9LFxuXG4gIFx0Ly8gU1ZHIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgekluZGV4IHNvIHdlIHJlc29ydCB0byBjaGFuZ2luZyB0aGUgRE9NIG9yZGVyIG9mIGVsZW1lbnRzXG4gIFx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0b0Zyb250KGxheWVyLl9wYXRoKTtcbiAgXHR9LFxuXG4gIFx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvQmFjayhsYXllci5fcGF0aCk7XG4gIFx0fVxuICB9KTtcblxuICBpZiAoQnJvd3Nlci52bWwpIHtcbiAgXHRTVkcuaW5jbHVkZSh2bWxNaXhpbik7XG4gIH1cblxuICAvLyBAbmFtZXNwYWNlIFNWR1xuICAvLyBAZmFjdG9yeSBMLnN2ZyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICBmdW5jdGlvbiBzdmcob3B0aW9ucykge1xuICBcdHJldHVybiBCcm93c2VyLnN2ZyB8fCBCcm93c2VyLnZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xuICB9XG5cbiAgTWFwLmluY2x1ZGUoe1xuICBcdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcbiAgXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlblxuICBcdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG4gIFx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuICBcdGdldFJlbmRlcmVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcbiAgXHRcdC8vIFVzZSB0aGlzIHNwZWNpZmljIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgZm9yIHRoaXMgcGF0aC4gVGFrZXNcbiAgXHRcdC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWFwJ3MgW2RlZmF1bHQgcmVuZGVyZXJdKCNtYXAtcmVuZGVyZXIpLlxuICBcdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cbiAgXHRcdGlmICghcmVuZGVyZXIpIHtcbiAgXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcbiAgXHRcdFx0dGhpcy5hZGRMYXllcihyZW5kZXJlcik7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcmVuZGVyZXI7XG4gIFx0fSxcblxuICBcdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuICBcdFx0aWYgKHJlbmRlcmVyID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcih7cGFuZTogbmFtZX0pO1xuICBcdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcmVuZGVyZXI7XG4gIFx0fSxcblxuICBcdF9jcmVhdGVSZW5kZXJlcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwOyBAb3B0aW9uIHByZWZlckNhbnZhczogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBXaGV0aGVyIGBQYXRoYHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIGEgYENhbnZhc2AgcmVuZGVyZXIuXG4gIFx0XHQvLyBCeSBkZWZhdWx0LCBhbGwgYFBhdGhgcyBhcmUgcmVuZGVyZWQgaW4gYSBgU1ZHYCByZW5kZXJlci5cbiAgXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyAmJiBjYW52YXMob3B0aW9ucykpIHx8IHN2ZyhvcHRpb25zKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXG4gICAqL1xuXG4gIC8qXG4gICAqIEBjbGFzcyBSZWN0YW5nbGVcbiAgICogQGFrYSBMLlJlY3RhbmdsZVxuICAgKiBAaW5oZXJpdHMgUG9seWdvblxuICAgKlxuICAgKiBBIGNsYXNzIGZvciBkcmF3aW5nIHJlY3RhbmdsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWdvbmAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGRlZmluZSByZWN0YW5nbGUgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICAgKiB2YXIgYm91bmRzID0gW1s1NC41NTkzMjIsIC01Ljc2NzgyMl0sIFs1Ni4xMjEwNjA0LCAtMy4wMjEyNDBdXTtcbiAgICpcbiAgICogLy8gY3JlYXRlIGFuIG9yYW5nZSByZWN0YW5nbGVcbiAgICogTC5yZWN0YW5nbGUoYm91bmRzLCB7Y29sb3I6IFwiI2ZmNzgwMFwiLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuICAgKlxuICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHJlY3RhbmdsZSBib3VuZHNcbiAgICogbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICAgKiBgYGBcbiAgICpcbiAgICovXG5cblxuICB2YXIgUmVjdGFuZ2xlID0gUG9seWdvbi5leHRlbmQoe1xuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcbiAgXHRcdFBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xuICBcdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuICBcdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuICBcdFx0cmV0dXJuIHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSk7XG4gIFx0fSxcblxuICBcdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcbiAgXHRcdGxhdExuZ0JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XG4gIFx0XHRyZXR1cm4gW1xuICBcdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuICBcdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcbiAgXHRcdF07XG4gIFx0fVxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwucmVjdGFuZ2xlKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbiAgZnVuY3Rpb24gcmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG4gIH1cblxuICBTVkcuY3JlYXRlID0gY3JlYXRlO1xuICBTVkcucG9pbnRzVG9QYXRoID0gcG9pbnRzVG9QYXRoO1xuXG4gIEdlb0pTT04uZ2VvbWV0cnlUb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyO1xuICBHZW9KU09OLmNvb3Jkc1RvTGF0TG5nID0gY29vcmRzVG9MYXRMbmc7XG4gIEdlb0pTT04uY29vcmRzVG9MYXRMbmdzID0gY29vcmRzVG9MYXRMbmdzO1xuICBHZW9KU09OLmxhdExuZ1RvQ29vcmRzID0gbGF0TG5nVG9Db29yZHM7XG4gIEdlb0pTT04ubGF0TG5nc1RvQ29vcmRzID0gbGF0TG5nc1RvQ29vcmRzO1xuICBHZW9KU09OLmdldEZlYXR1cmUgPSBnZXRGZWF0dXJlO1xuICBHZW9KU09OLmFzRmVhdHVyZSA9IGFzRmVhdHVyZTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuQm94Wm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICAgKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAb3B0aW9uIGJveFpvb206IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuICBcdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuICBcdGJveFpvb206IHRydWVcbiAgfSk7XG5cbiAgdmFyIEJveFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xuICBcdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG4gIFx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcbiAgXHRcdG1hcC5vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYodGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX21vdmVkO1xuICBcdH0sXG5cbiAgXHRfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlKHRoaXMuX3BhbmUpO1xuICBcdFx0ZGVsZXRlIHRoaXMuX3BhbmU7XG4gIFx0fSxcblxuICBcdF9yZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuICBcdH0sXG5cbiAgXHRfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9yZXNldFN0YXRlVGltZW91dCAhPT0gMCkge1xuICBcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQpO1xuICBcdFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIFx0XHQvLyBDbGVhciB0aGUgZGVmZXJyZWQgcmVzZXRTdGF0ZSBpZiBpdCBoYXNuJ3QgZXhlY3V0ZWQgeWV0LCBvdGhlcndpc2UgaXRcbiAgXHRcdC8vIHdpbGwgaW50ZXJydXB0IHRoZSBpbnRlcmFjdGlvbiBhbmQgb3JwaGFuIGEgYm94IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lci5cbiAgXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG4gIFx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cbiAgXHRcdGRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gIFx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XG5cbiAgXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cbiAgXHRcdG9uKGRvY3VtZW50LCB7XG4gIFx0XHRcdGNvbnRleHRtZW51OiBzdG9wLFxuICBcdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuICBcdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG4gIFx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuICBcdFx0fSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG4gIFx0XHRcdHRoaXMuX2JveCA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cbiAgXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuICBcdFx0dmFyIGJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQsIHRoaXMuX3N0YXJ0UG9pbnQpLFxuICBcdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9ib3gsIGJvdW5kcy5taW4pO1xuXG4gIFx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcbiAgXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuICBcdH0sXG5cbiAgXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbW92ZWQpIHtcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX2JveCk7XG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGVuYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgXHRcdGVuYWJsZUltYWdlRHJhZygpO1xuXG4gIFx0XHRvZmYoZG9jdW1lbnQsIHtcbiAgXHRcdFx0Y29udGV4dG1lbnU6IHN0b3AsXG4gIFx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG4gIFx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcbiAgXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fZmluaXNoKCk7XG5cbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHsgcmV0dXJuOyB9XG4gIFx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcbiAgXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG4gIFx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuICBcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG4gIFx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG4gIFx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50KSk7XG5cbiAgXHRcdHRoaXMuX21hcFxuICBcdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcbiAgXHRcdFx0LmZpcmUoJ2JveHpvb21lbmQnLCB7Ym94Wm9vbUJvdW5kczogYm91bmRzfSk7XG4gIFx0fSxcblxuICBcdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICBcdFx0XHR0aGlzLl9maW5pc2goKTtcbiAgXHRcdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcbiAgXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IGJveFpvb206IEhhbmRsZXJcbiAgLy8gQm94IChzaGlmdC1kcmFnIHdpdGggbW91c2UpIHpvb20gaGFuZGxlci5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBCb3hab29tKTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuRG91YmxlQ2xpY2tab29tIGlzIHVzZWQgdG8gaGFuZGxlIGRvdWJsZS1jbGljayB6b29tIG9uIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBpbiBieSBkb3VibGUgY2xpY2tpbmcgb24gaXQgYW5kXG4gIFx0Ly8gem9vbWVkIG91dCBieSBkb3VibGUgY2xpY2tpbmcgd2hpbGUgaG9sZGluZyBzaGlmdC4gSWYgcGFzc2VkXG4gIFx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG4gIFx0Ly8gIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuICBcdGRvdWJsZUNsaWNrWm9vbTogdHJ1ZVxuICB9KTtcblxuICB2YXIgRG91YmxlQ2xpY2tab29tID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgb2xkWm9vbSA9IG1hcC5nZXRab29tKCksXG4gIFx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG4gIFx0XHQgICAgem9vbSA9IGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IG9sZFpvb20gLSBkZWx0YSA6IG9sZFpvb20gKyBkZWx0YTtcblxuICBcdFx0aWYgKG1hcC5vcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA9PT0gJ2NlbnRlcicpIHtcbiAgXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZChlLmNvbnRhaW5lclBvaW50LCB6b29tKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vXG4gIC8vIE1hcCBwcm9wZXJ0aWVzIGluY2x1ZGUgaW50ZXJhY3Rpb24gaGFuZGxlcnMgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbFxuICAvLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4gIC8vIGFzIGRyYWdnaW5nIG9yIHRvdWNoIHpvb20gKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyBgYGBqc1xuICAvLyBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbiAgLy8gYGBgXG4gIC8vXG4gIC8vIEBwcm9wZXJ0eSBkb3VibGVDbGlja1pvb206IEhhbmRsZXJcbiAgLy8gRG91YmxlIGNsaWNrIHpvb20gaGFuZGxlci5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLk1hcERyYWcgaXMgdXNlZCB0byBtYWtlIHRoZSBtYXAgZHJhZ2dhYmxlICh3aXRoIHBhbm5pbmcgaW5lcnRpYSksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXG4gIFx0ZHJhZ2dpbmc6IHRydWUsXG5cbiAgXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuICBcdC8vIEBvcHRpb24gaW5lcnRpYTogQm9vbGVhbiA9ICpcbiAgXHQvLyBJZiBlbmFibGVkLCBwYW5uaW5nIG9mIHRoZSBtYXAgd2lsbCBoYXZlIGFuIGluZXJ0aWEgZWZmZWN0IHdoZXJlXG4gIFx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cbiAgXHQvLyB0aGUgc2FtZSBkaXJlY3Rpb24gZm9yIHNvbWUgdGltZS4gRmVlbHMgZXNwZWNpYWxseSBuaWNlIG9uIHRvdWNoXG4gIFx0Ly8gZGV2aWNlcy4gRW5hYmxlZCBieSBkZWZhdWx0LlxuICBcdGluZXJ0aWE6IHRydWUsXG5cbiAgXHQvLyBAb3B0aW9uIGluZXJ0aWFEZWNlbGVyYXRpb246IE51bWJlciA9IDMwMDBcbiAgXHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG4gIFx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cbiAgXHQvLyBAb3B0aW9uIGluZXJ0aWFNYXhTcGVlZDogTnVtYmVyID0gSW5maW5pdHlcbiAgXHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuICBcdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuICBcdC8vIEBvcHRpb24gZWFzZUxpbmVhcml0eTogTnVtYmVyID0gMC4yXG4gIFx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG4gIFx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcbiAgXHQvLyBAb3B0aW9uIHdvcmxkQ29weUp1bXA6IEJvb2xlYW4gPSBmYWxzZVxuICBcdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcbiAgXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuICBcdC8vIGxpa2UgbWFya2VycyBhbmQgdmVjdG9yIGxheWVycyBhcmUgc3RpbGwgdmlzaWJsZS5cbiAgXHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuICBcdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcbiAgXHQvLyBJZiBgbWF4Qm91bmRzYCBpcyBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgY29udHJvbCBob3cgc29saWQgdGhlIGJvdW5kc1xuICBcdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG4gIFx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuICBcdC8vIHNsb3cgZG93biBtYXAgZHJhZ2dpbmcgb3V0c2lkZSBib3VuZHMsIGFuZCBgMS4wYCBtYWtlcyB0aGUgYm91bmRzIGZ1bGx5XG4gIFx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG4gIFx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbiAgfSk7XG5cbiAgdmFyIERyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG4gIFx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZShtYXAuX21hcFBhbmUsIG1hcC5fY29udGFpbmVyKTtcblxuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuICBcdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gIFx0XHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuICBcdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuICBcdFx0XHR9LCB0aGlzKTtcblxuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdMaW1pdCwgdGhpcyk7XG4gIFx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG4gIFx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG4gIFx0XHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblxuICBcdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0YWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnJyk7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG4gIFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcbiAgXHRcdHRoaXMuX3RpbWVzID0gW107XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG4gIFx0fSxcblxuICBcdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG4gIFx0fSxcblxuICBcdG1vdmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmluZztcbiAgXHR9LFxuXG4gIFx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gIFx0XHRtYXAuX3N0b3AoKTtcbiAgXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiYgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSB7XG4gIFx0XHRcdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG4gIFx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gdG9Cb3VuZHMoXG4gIFx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldE5vcnRoV2VzdCgpKS5tdWx0aXBseUJ5KC0xKSxcbiAgXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG4gIFx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuICBcdFx0XHR0aGlzLl92aXNjb3NpdHkgPSBNYXRoLm1pbigxLjAsIE1hdGgubWF4KDAuMCwgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdG1hcFxuICBcdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuICBcdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblxuICBcdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcbiAgXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG4gIFx0XHRcdHRoaXMuX3RpbWVzID0gW107XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuICBcdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG4gIFx0XHRcdCAgICBwb3MgPSB0aGlzLl9sYXN0UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgfHwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M7XG5cbiAgXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcbiAgXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuICBcdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucyh0aW1lKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fbWFwXG4gIFx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuICBcdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG4gIFx0fSxcblxuICBcdF9wcnVuZVBvc2l0aW9uczogZnVuY3Rpb24gKHRpbWUpIHtcbiAgXHRcdHdoaWxlICh0aGlzLl9wb3NpdGlvbnMubGVuZ3RoID4gMSAmJiB0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuICBcdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcbiAgXHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcbiAgXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG4gIFx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuICBcdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLng7XG4gIFx0fSxcblxuICBcdF92aXNjb3VzTGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGhyZXNob2xkKSB7XG4gIFx0XHRyZXR1cm4gdmFsdWUgLSAodmFsdWUgLSB0aHJlc2hvbGQpICogdGhpcy5fdmlzY29zaXR5O1xuICBcdH0sXG5cbiAgXHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fdmlzY29zaXR5IHx8ICF0aGlzLl9vZmZzZXRMaW1pdCkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG4gIFx0XHR2YXIgbGltaXQgPSB0aGlzLl9vZmZzZXRMaW1pdDtcbiAgXHRcdGlmIChvZmZzZXQueCA8IGxpbWl0Lm1pbi54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7IH1cbiAgXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cbiAgXHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5tYXgueCk7IH1cbiAgXHRcdGlmIChvZmZzZXQueSA+IGxpbWl0Lm1heC55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7IH1cblxuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuICBcdH0sXG5cbiAgXHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG4gIFx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG4gIFx0XHQgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG4gIFx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG4gIFx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG4gIFx0XHQgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcbiAgXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuICBcdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG4gIFx0fSxcblxuICBcdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblxuICBcdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgZS5ub0luZXJ0aWEgfHwgdGhpcy5fdGltZXMubGVuZ3RoIDwgMjtcblxuICBcdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuICBcdFx0aWYgKG5vSW5lcnRpYSkge1xuICBcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9wcnVuZVBvc2l0aW9ucygrbmV3IERhdGUoKSk7XG5cbiAgXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcbiAgXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcbiAgXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cbiAgXHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcbiAgXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG4gIFx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuICBcdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cbiAgXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuICBcdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuICBcdFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuICBcdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuICBcdFx0XHRcdHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCwge1xuICBcdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG4gIFx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG4gIFx0XHRcdFx0XHRcdG5vTW92ZVN0YXJ0OiB0cnVlLFxuICBcdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gIC8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIERyYWcpO1xuXG4gIC8qXG4gICAqIEwuTWFwLktleWJvYXJkIGlzIGhhbmRsaW5nIGtleWJvYXJkIGludGVyYWN0aW9uIHdpdGggdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBLZXlib2FyZCBOYXZpZ2F0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuICBcdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuICBcdGtleWJvYXJkOiB0cnVlLFxuXG4gIFx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuICBcdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuICBcdGtleWJvYXJkUGFuRGVsdGE6IDgwXG4gIH0pO1xuXG4gIHZhciBLZXlib2FyZCA9IEhhbmRsZXIuZXh0ZW5kKHtcblxuICBcdGtleUNvZGVzOiB7XG4gIFx0XHRsZWZ0OiAgICBbMzddLFxuICBcdFx0cmlnaHQ6ICAgWzM5XSxcbiAgXHRcdGRvd246ICAgIFs0MF0sXG4gIFx0XHR1cDogICAgICBbMzhdLFxuICBcdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcbiAgXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xuXG4gIFx0XHR0aGlzLl9zZXRQYW5EZWx0YShtYXAub3B0aW9ucy5rZXlib2FyZFBhbkRlbHRhKTtcbiAgXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuICBcdH0sXG5cbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG4gIFx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcbiAgXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuICBcdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG4gIFx0XHR9XG5cbiAgXHRcdG9uKGNvbnRhaW5lciwge1xuICBcdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuICBcdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG4gIFx0XHR9LCB0aGlzKTtcblxuICBcdFx0dGhpcy5fbWFwLm9uKHtcbiAgXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuICBcdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuICBcdFx0fSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG4gIFx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcbiAgXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG4gIFx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcbiAgXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuICBcdFx0fSwgdGhpcyk7XG5cbiAgXHRcdHRoaXMuX21hcC5vZmYoe1xuICBcdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG4gIFx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuICBcdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICBcdFx0ICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsLnNjcm9sbFRvcCxcbiAgXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cbiAgXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cbiAgXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuICBcdH0sXG5cbiAgXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fZm9jdXNlZCA9IHRydWU7XG4gIFx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcbiAgXHR9LFxuXG4gIFx0X29uQmx1cjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuICBcdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcbiAgXHR9LFxuXG4gIFx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcbiAgXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuICBcdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2RlcyxcbiAgXHRcdCAgICBpLCBsZW47XG5cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbkRlbHRhLCAwXTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbkRlbHRhLCAwXTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5EZWx0YV07XG4gIFx0XHR9XG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbkRlbHRhXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3NldFpvb21EZWx0YTogZnVuY3Rpb24gKHpvb21EZWx0YSkge1xuICBcdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuICBcdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2RlcyxcbiAgXHRcdCAgICBpLCBsZW47XG5cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG4gIFx0XHR9XG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcbiAgXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgb2Zmc2V0O1xuXG4gIFx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcbiAgXHRcdFx0aWYgKCFtYXAuX3BhbkFuaW0gfHwgIW1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykge1xuICBcdFx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcbiAgXHRcdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuICBcdFx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuICBcdFx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldCh0b1BvaW50KG9mZnNldCksIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcbiAgXHRcdFx0XHRcdHZhciBuZXdMYXRMbmcgPSBtYXAud3JhcExhdExuZyhtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KG1hcC5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpKTtcbiAgXHRcdFx0XHRcdG1hcC5wYW5UbyhuZXdMYXRMbmcpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG4gIFx0XHRcdG1hcC5zZXRab29tKG1hcC5nZXRab29tKCkgKyAoZS5zaGlmdEtleSA/IDMgOiAxKSAqIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG4gIFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkVzY2FwZUtleSkge1xuICBcdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHN0b3AoZSk7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbiAgLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBLZXlib2FyZCk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLlNjcm9sbFdoZWVsWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGVuYWJsZSBtb3VzZSBzY3JvbGwgd2hlZWwgem9vbSBvbiB0aGUgbWFwLlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBzZWN0aW9uIE1vdXNlIHdoZWVsIG9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdXNpbmcgdGhlIG1vdXNlIHdoZWVsLiBJZiBwYXNzZWQgYCdjZW50ZXInYCxcbiAgXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG4gIFx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG4gIFx0Ly8gQG9wdGlvbiB3aGVlbERlYm91bmNlVGltZTogTnVtYmVyID0gNDBcbiAgXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuICBcdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuICBcdHdoZWVsRGVib3VuY2VUaW1lOiA0MCxcblxuICBcdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcbiAgXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG4gIFx0Ly8gbWVhbiBhIGNoYW5nZSBvZiBvbmUgZnVsbCB6b29tIGxldmVsLiBTbWFsbGVyIHZhbHVlcyB3aWxsIG1ha2Ugd2hlZWwtem9vbWluZ1xuICBcdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuICBcdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG4gIH0pO1xuXG4gIHZhciBTY3JvbGxXaGVlbFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuICBcdFx0dGhpcy5fZGVsdGEgPSAwO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgZGVsdGEgPSBnZXRXaGVlbERlbHRhKGUpO1xuXG4gIFx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuICBcdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG4gIFx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cbiAgXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG4gIFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cbiAgXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIFx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG4gIFx0XHRzdG9wKGUpO1xuICBcdH0sXG5cbiAgXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG4gIFx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cbiAgXHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG4gIFx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcbiAgXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcbiAgXHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG4gIFx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG4gIFx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG4gIFx0XHR0aGlzLl9kZWx0YSA9IDA7XG4gIFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG4gIFx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuICAvLyBTY3JvbGwgd2hlZWwgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgU2Nyb2xsV2hlZWxab29tKTtcblxuICAvKlxuICAgKiBMLk1hcC5UYXBIb2xkIGlzIHVzZWQgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCBvbiBsb25nIGhvbGQsXG4gICAqIHdoaWNoIG90aGVyd2lzZSBpcyBub3QgZmlyZWQgYnkgbW9iaWxlIFNhZmFyaS5cbiAgICovXG5cbiAgdmFyIHRhcEhvbGREZWxheSA9IDYwMDtcblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIHRhcEhvbGQ6IEJvb2xlYW5cbiAgXHQvLyBFbmFibGVzIHNpbXVsYXRpb24gb2YgYGNvbnRleHRtZW51YCBldmVudCwgZGVmYXVsdCBpcyBgdHJ1ZWAgZm9yIG1vYmlsZSBTYWZhcmkuXG4gIFx0dGFwSG9sZDogQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnNhZmFyaSAmJiBCcm93c2VyLm1vYmlsZSxcblxuICBcdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuICBcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG4gIFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG4gIFx0dGFwVG9sZXJhbmNlOiAxNVxuICB9KTtcblxuICB2YXIgVGFwSG9sZCA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcbiAgXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG4gIFx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuICBcdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQoZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzLl9jYW5jZWwoKTtcbiAgXHRcdFx0aWYgKCF0aGlzLl9pc1RhcFZhbGlkKCkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdFx0Ly8gcHJldmVudCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby90b3VjaC1ldmVudHMvI21vdXNlLWV2ZW50c1xuICBcdFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgcHJldmVudERlZmF1bHQpO1xuICBcdFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fY2FuY2VsQ2xpY2tQcmV2ZW50KTtcbiAgXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG4gIFx0XHR9LCB0aGlzKSwgdGFwSG9sZERlbGF5KTtcblxuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9jYW5jZWxDbGlja1ByZXZlbnQ6IGZ1bmN0aW9uIGNhbmNlbENsaWNrUHJldmVudCgpIHtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgcHJldmVudERlZmF1bHQpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBjYW5jZWxDbGlja1ByZXZlbnQpO1xuICBcdH0sXG5cbiAgXHRfY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwgY29udGV4dG1lbnUnLCB0aGlzLl9jYW5jZWwsIHRoaXMpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcbiAgXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcbiAgXHR9LFxuXG4gIFx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuICBcdH0sXG5cbiAgXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IG5ldyBNb3VzZUV2ZW50KHR5cGUsIHtcbiAgXHRcdFx0YnViYmxlczogdHJ1ZSxcbiAgXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcbiAgXHRcdFx0dmlldzogd2luZG93LFxuICBcdFx0XHQvLyBkZXRhaWw6IDEsXG4gIFx0XHRcdHNjcmVlblg6IGUuc2NyZWVuWCxcbiAgXHRcdFx0c2NyZWVuWTogZS5zY3JlZW5ZLFxuICBcdFx0XHRjbGllbnRYOiBlLmNsaWVudFgsXG4gIFx0XHRcdGNsaWVudFk6IGUuY2xpZW50WSxcbiAgXHRcdFx0Ly8gYnV0dG9uOiAyLFxuICBcdFx0XHQvLyBidXR0b25zOiAyXG4gIFx0XHR9KTtcblxuICBcdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cbiAgXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IHRhcEhvbGQ6IEhhbmRsZXJcbiAgLy8gTG9uZyB0YXAgaGFuZGxlciB0byBzaW11bGF0ZSBgY29udGV4dG1lbnVgIGV2ZW50ICh1c2VmdWwgaW4gbW9iaWxlIFNhZmFyaSkuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXBIb2xkJywgVGFwSG9sZCk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuICBcdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuICBcdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG4gIFx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcbiAgXHQvLyBicm93c2Vycy5cbiAgXHR0b3VjaFpvb206IEJyb3dzZXIudG91Y2gsXG5cbiAgXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cbiAgXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG4gIFx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBUb3VjaFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG4gIFx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuICBcdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cbiAgXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG4gIFx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcbiAgXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuICBcdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcbiAgXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG4gIFx0XHRtYXAuX3N0b3AoKTtcblxuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cbiAgXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuICBcdH0sXG5cbiAgXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG4gIFx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcbiAgXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG4gIFx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuICBcdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuICBcdFx0XHQodGhpcy5fem9vbSA8IG1hcC5nZXRNaW5ab29tKCkgJiYgc2NhbGUgPCAxKSB8fFxuICBcdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcbiAgXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcbiAgXHRcdFx0aWYgKHNjYWxlID09PSAxKSB7IHJldHVybjsgfVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG4gIFx0XHRcdHZhciBkZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO1xuICBcdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuICBcdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcbiAgXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cbiAgXHRcdHZhciBtb3ZlRm4gPSBiaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSwgdW5kZWZpbmVkKTtcbiAgXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZShtb3ZlRm4sIHRoaXMsIHRydWUpO1xuXG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcbiAgXHR9LFxuXG4gIFx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbW92ZWQgfHwgIXRoaXMuX3pvb21pbmcpIHtcbiAgXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cbiAgXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG4gIFx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuICBcdFx0XHR0aGlzLl9tYXAuX2FuaW1hdGVab29tKHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSksIHRydWUsIHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX21hcC5fcmVzZXRWaWV3KHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuICAvLyBUb3VjaCB6b29tIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBUb3VjaFpvb20pO1xuXG4gIE1hcC5Cb3hab29tID0gQm94Wm9vbTtcbiAgTWFwLkRvdWJsZUNsaWNrWm9vbSA9IERvdWJsZUNsaWNrWm9vbTtcbiAgTWFwLkRyYWcgPSBEcmFnO1xuICBNYXAuS2V5Ym9hcmQgPSBLZXlib2FyZDtcbiAgTWFwLlNjcm9sbFdoZWVsWm9vbSA9IFNjcm9sbFdoZWVsWm9vbTtcbiAgTWFwLlRhcEhvbGQgPSBUYXBIb2xkO1xuICBNYXAuVG91Y2hab29tID0gVG91Y2hab29tO1xuXG4gIGV4cG9ydHMuQm91bmRzID0gQm91bmRzO1xuICBleHBvcnRzLkJyb3dzZXIgPSBCcm93c2VyO1xuICBleHBvcnRzLkNSUyA9IENSUztcbiAgZXhwb3J0cy5DYW52YXMgPSBDYW52YXM7XG4gIGV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlO1xuICBleHBvcnRzLkNpcmNsZU1hcmtlciA9IENpcmNsZU1hcmtlcjtcbiAgZXhwb3J0cy5DbGFzcyA9IENsYXNzO1xuICBleHBvcnRzLkNvbnRyb2wgPSBDb250cm9sO1xuICBleHBvcnRzLkRpdkljb24gPSBEaXZJY29uO1xuICBleHBvcnRzLkRpdk92ZXJsYXkgPSBEaXZPdmVybGF5O1xuICBleHBvcnRzLkRvbUV2ZW50ID0gRG9tRXZlbnQ7XG4gIGV4cG9ydHMuRG9tVXRpbCA9IERvbVV0aWw7XG4gIGV4cG9ydHMuRHJhZ2dhYmxlID0gRHJhZ2dhYmxlO1xuICBleHBvcnRzLkV2ZW50ZWQgPSBFdmVudGVkO1xuICBleHBvcnRzLkZlYXR1cmVHcm91cCA9IEZlYXR1cmVHcm91cDtcbiAgZXhwb3J0cy5HZW9KU09OID0gR2VvSlNPTjtcbiAgZXhwb3J0cy5HcmlkTGF5ZXIgPSBHcmlkTGF5ZXI7XG4gIGV4cG9ydHMuSGFuZGxlciA9IEhhbmRsZXI7XG4gIGV4cG9ydHMuSWNvbiA9IEljb247XG4gIGV4cG9ydHMuSW1hZ2VPdmVybGF5ID0gSW1hZ2VPdmVybGF5O1xuICBleHBvcnRzLkxhdExuZyA9IExhdExuZztcbiAgZXhwb3J0cy5MYXRMbmdCb3VuZHMgPSBMYXRMbmdCb3VuZHM7XG4gIGV4cG9ydHMuTGF5ZXIgPSBMYXllcjtcbiAgZXhwb3J0cy5MYXllckdyb3VwID0gTGF5ZXJHcm91cDtcbiAgZXhwb3J0cy5MaW5lVXRpbCA9IExpbmVVdGlsO1xuICBleHBvcnRzLk1hcCA9IE1hcDtcbiAgZXhwb3J0cy5NYXJrZXIgPSBNYXJrZXI7XG4gIGV4cG9ydHMuTWl4aW4gPSBNaXhpbjtcbiAgZXhwb3J0cy5QYXRoID0gUGF0aDtcbiAgZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuICBleHBvcnRzLlBvbHlVdGlsID0gUG9seVV0aWw7XG4gIGV4cG9ydHMuUG9seWdvbiA9IFBvbHlnb247XG4gIGV4cG9ydHMuUG9seWxpbmUgPSBQb2x5bGluZTtcbiAgZXhwb3J0cy5Qb3B1cCA9IFBvcHVwO1xuICBleHBvcnRzLlBvc0FuaW1hdGlvbiA9IFBvc0FuaW1hdGlvbjtcbiAgZXhwb3J0cy5Qcm9qZWN0aW9uID0gaW5kZXg7XG4gIGV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xuICBleHBvcnRzLlJlbmRlcmVyID0gUmVuZGVyZXI7XG4gIGV4cG9ydHMuU1ZHID0gU1ZHO1xuICBleHBvcnRzLlNWR092ZXJsYXkgPSBTVkdPdmVybGF5O1xuICBleHBvcnRzLlRpbGVMYXllciA9IFRpbGVMYXllcjtcbiAgZXhwb3J0cy5Ub29sdGlwID0gVG9vbHRpcDtcbiAgZXhwb3J0cy5UcmFuc2Zvcm1hdGlvbiA9IFRyYW5zZm9ybWF0aW9uO1xuICBleHBvcnRzLlV0aWwgPSBVdGlsO1xuICBleHBvcnRzLlZpZGVvT3ZlcmxheSA9IFZpZGVvT3ZlcmxheTtcbiAgZXhwb3J0cy5iaW5kID0gYmluZDtcbiAgZXhwb3J0cy5ib3VuZHMgPSB0b0JvdW5kcztcbiAgZXhwb3J0cy5jYW52YXMgPSBjYW52YXM7XG4gIGV4cG9ydHMuY2lyY2xlID0gY2lyY2xlO1xuICBleHBvcnRzLmNpcmNsZU1hcmtlciA9IGNpcmNsZU1hcmtlcjtcbiAgZXhwb3J0cy5jb250cm9sID0gY29udHJvbDtcbiAgZXhwb3J0cy5kaXZJY29uID0gZGl2SWNvbjtcbiAgZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG4gIGV4cG9ydHMuZmVhdHVyZUdyb3VwID0gZmVhdHVyZUdyb3VwO1xuICBleHBvcnRzLmdlb0pTT04gPSBnZW9KU09OO1xuICBleHBvcnRzLmdlb0pzb24gPSBnZW9Kc29uO1xuICBleHBvcnRzLmdyaWRMYXllciA9IGdyaWRMYXllcjtcbiAgZXhwb3J0cy5pY29uID0gaWNvbjtcbiAgZXhwb3J0cy5pbWFnZU92ZXJsYXkgPSBpbWFnZU92ZXJsYXk7XG4gIGV4cG9ydHMubGF0TG5nID0gdG9MYXRMbmc7XG4gIGV4cG9ydHMubGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHM7XG4gIGV4cG9ydHMubGF5ZXJHcm91cCA9IGxheWVyR3JvdXA7XG4gIGV4cG9ydHMubWFwID0gY3JlYXRlTWFwO1xuICBleHBvcnRzLm1hcmtlciA9IG1hcmtlcjtcbiAgZXhwb3J0cy5wb2ludCA9IHRvUG9pbnQ7XG4gIGV4cG9ydHMucG9seWdvbiA9IHBvbHlnb247XG4gIGV4cG9ydHMucG9seWxpbmUgPSBwb2x5bGluZTtcbiAgZXhwb3J0cy5wb3B1cCA9IHBvcHVwO1xuICBleHBvcnRzLnJlY3RhbmdsZSA9IHJlY3RhbmdsZTtcbiAgZXhwb3J0cy5zZXRPcHRpb25zID0gc2V0T3B0aW9ucztcbiAgZXhwb3J0cy5zdGFtcCA9IHN0YW1wO1xuICBleHBvcnRzLnN2ZyA9IHN2ZztcbiAgZXhwb3J0cy5zdmdPdmVybGF5ID0gc3ZnT3ZlcmxheTtcbiAgZXhwb3J0cy50aWxlTGF5ZXIgPSB0aWxlTGF5ZXI7XG4gIGV4cG9ydHMudG9vbHRpcCA9IHRvb2x0aXA7XG4gIGV4cG9ydHMudHJhbnNmb3JtYXRpb24gPSB0b1RyYW5zZm9ybWF0aW9uO1xuICBleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICBleHBvcnRzLnZpZGVvT3ZlcmxheSA9IHZpZGVvT3ZlcmxheTtcblxuICB2YXIgb2xkTCA9IHdpbmRvdy5MO1xuICBleHBvcnRzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgXHR3aW5kb3cuTCA9IG9sZEw7XG4gIFx0cmV0dXJuIHRoaXM7XG4gIH1cbiAgLy8gQWx3YXlzIGV4cG9ydCB1cyB0byB3aW5kb3cgZ2xvYmFsIChzZWUgIzIzNjQpXG4gIHdpbmRvdy5MID0gZXhwb3J0cztcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVhZmxldC1zcmMuanMubWFwXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwic2VsZiIsImxlYWZsZXQiLCJ2ZXJzaW9uIiwiZXh0ZW5kIiwiZGVzdCIsImkiLCJqIiwibGVuIiwic3JjIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY3JlYXRlJDIiLCJPYmplY3QiLCJjcmVhdGUiLCJGIiwicHJvdG8iLCJwcm90b3R5cGUiLCJiaW5kIiwiZm4iLCJvYmoiLCJzbGljZSIsIkFycmF5IiwiYXBwbHkiLCJjYWxsIiwiYXJncyIsImNvbmNhdCIsImxhc3RJZCIsInN0YW1wIiwiX2xlYWZsZXRfaWQiLCJ0aHJvdHRsZSIsInRpbWUiLCJjb250ZXh0IiwibG9jayIsIndyYXBwZXJGbiIsImxhdGVyIiwic2V0VGltZW91dCIsIndyYXBOdW0iLCJ4IiwicmFuZ2UiLCJpbmNsdWRlTWF4IiwibWF4IiwibWluIiwiZCIsImZhbHNlRm4iLCJmb3JtYXROdW0iLCJudW0iLCJwcmVjaXNpb24iLCJwb3ciLCJNYXRoIiwidW5kZWZpbmVkIiwicm91bmQiLCJ0cmltIiwic3RyIiwicmVwbGFjZSIsInNwbGl0V29yZHMiLCJzcGxpdCIsInNldE9wdGlvbnMiLCJvcHRpb25zIiwiaGFzT3duUHJvcGVydHkiLCJnZXRQYXJhbVN0cmluZyIsImV4aXN0aW5nVXJsIiwidXBwZXJjYXNlIiwicGFyYW1zIiwicHVzaCIsImVuY29kZVVSSUNvbXBvbmVudCIsInRvVXBwZXJDYXNlIiwiaW5kZXhPZiIsImpvaW4iLCJ0ZW1wbGF0ZVJlIiwidGVtcGxhdGUiLCJkYXRhIiwia2V5IiwidmFsdWUiLCJFcnJvciIsImlzQXJyYXkiLCJ0b1N0cmluZyIsImFycmF5IiwiZWwiLCJlbXB0eUltYWdlVXJsIiwiZ2V0UHJlZml4ZWQiLCJuYW1lIiwid2luZG93IiwibGFzdFRpbWUiLCJ0aW1lb3V0RGVmZXIiLCJEYXRlIiwidGltZVRvQ2FsbCIsInJlcXVlc3RGbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEZuIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpZCIsImNsZWFyVGltZW91dCIsInJlcXVlc3RBbmltRnJhbWUiLCJpbW1lZGlhdGUiLCJjYW5jZWxBbmltRnJhbWUiLCJVdGlsIiwiX19wcm90b19fIiwiQ2xhc3MiLCJwcm9wcyIsIk5ld0NsYXNzIiwiaW5pdGlhbGl6ZSIsImNhbGxJbml0SG9va3MiLCJwYXJlbnRQcm90byIsIl9fc3VwZXJfXyIsImNvbnN0cnVjdG9yIiwic3RhdGljcyIsImluY2x1ZGVzIiwiY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMiLCJfaW5pdEhvb2tzIiwiX2luaXRIb29rc0NhbGxlZCIsImluY2x1ZGUiLCJwYXJlbnRPcHRpb25zIiwibWVyZ2VPcHRpb25zIiwiYWRkSW5pdEhvb2siLCJpbml0IiwiTCIsIk1peGluIiwiRXZlbnRzIiwiY29uc29sZSIsIndhcm4iLCJzdGFjayIsIm9uIiwidHlwZXMiLCJ0eXBlIiwiX29uIiwib2ZmIiwiX2V2ZW50cyIsIl9vZmYiLCJyZW1vdmVBbGwiLCJfb25jZSIsIl9saXN0ZW5zIiwibmV3TGlzdGVuZXIiLCJjdHgiLCJvbmNlIiwibGlzdGVuZXJzIiwiX2ZpcmluZ0NvdW50IiwiaW5kZXgiLCJsaXN0ZW5lciIsInNwbGljZSIsImZpcmUiLCJwcm9wYWdhdGUiLCJsaXN0ZW5zIiwiZXZlbnQiLCJ0YXJnZXQiLCJzb3VyY2VUYXJnZXQiLCJsIiwiX3Byb3BhZ2F0ZUV2ZW50IiwiX2ZuIiwiX2V2ZW50UGFyZW50cyIsImFkZEV2ZW50UGFyZW50IiwicmVtb3ZlRXZlbnRQYXJlbnQiLCJlIiwibGF5ZXIiLCJwcm9wYWdhdGVkRnJvbSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYXJBbGxFdmVudExpc3RlbmVycyIsImFkZE9uZVRpbWVFdmVudExpc3RlbmVyIiwiZmlyZUV2ZW50IiwiaGFzRXZlbnRMaXN0ZW5lcnMiLCJFdmVudGVkIiwiUG9pbnQiLCJ5IiwidHJ1bmMiLCJ2IiwiZmxvb3IiLCJjZWlsIiwiY2xvbmUiLCJhZGQiLCJwb2ludCIsIl9hZGQiLCJ0b1BvaW50Iiwic3VidHJhY3QiLCJfc3VidHJhY3QiLCJkaXZpZGVCeSIsIl9kaXZpZGVCeSIsIm11bHRpcGx5QnkiLCJfbXVsdGlwbHlCeSIsInNjYWxlQnkiLCJ1bnNjYWxlQnkiLCJfcm91bmQiLCJfZmxvb3IiLCJfY2VpbCIsIl90cnVuYyIsImRpc3RhbmNlVG8iLCJzcXJ0IiwiZXF1YWxzIiwiY29udGFpbnMiLCJhYnMiLCJCb3VuZHMiLCJhIiwiYiIsInBvaW50cyIsIm1pbjIiLCJtYXgyIiwidG9Cb3VuZHMiLCJnZXRDZW50ZXIiLCJnZXRCb3R0b21MZWZ0IiwiZ2V0VG9wUmlnaHQiLCJnZXRUb3BMZWZ0IiwiZ2V0Qm90dG9tUmlnaHQiLCJnZXRTaXplIiwiaW50ZXJzZWN0cyIsImJvdW5kcyIsInhJbnRlcnNlY3RzIiwieUludGVyc2VjdHMiLCJvdmVybGFwcyIsInhPdmVybGFwcyIsInlPdmVybGFwcyIsImlzVmFsaWQiLCJwYWQiLCJidWZmZXJSYXRpbyIsImhlaWdodEJ1ZmZlciIsIndpZHRoQnVmZmVyIiwiTGF0TG5nQm91bmRzIiwiY29ybmVyMSIsImNvcm5lcjIiLCJsYXRsbmdzIiwic3ciLCJfc291dGhXZXN0IiwibmUiLCJfbm9ydGhFYXN0Iiwic3cyIiwibmUyIiwiTGF0TG5nIiwidG9MYXRMbmciLCJ0b0xhdExuZ0JvdW5kcyIsImxhdCIsImxuZyIsImdldFNvdXRoV2VzdCIsImdldE5vcnRoRWFzdCIsImdldE5vcnRoV2VzdCIsImdldE5vcnRoIiwiZ2V0V2VzdCIsImdldFNvdXRoRWFzdCIsImdldFNvdXRoIiwiZ2V0RWFzdCIsImxhdEludGVyc2VjdHMiLCJsbmdJbnRlcnNlY3RzIiwibGF0T3ZlcmxhcHMiLCJsbmdPdmVybGFwcyIsInRvQkJveFN0cmluZyIsIm1heE1hcmdpbiIsImFsdCIsImlzTmFOIiwibWFyZ2luIiwib3RoZXIiLCJFYXJ0aCIsImRpc3RhbmNlIiwid3JhcCIsIndyYXBMYXRMbmciLCJzaXplSW5NZXRlcnMiLCJsYXRBY2N1cmFjeSIsImxuZ0FjY3VyYWN5IiwiY29zIiwiUEkiLCJjIiwibG9uIiwiQ1JTIiwibGF0TG5nVG9Qb2ludCIsImxhdGxuZyIsInpvb20iLCJwcm9qZWN0ZWRQb2ludCIsInByb2plY3Rpb24iLCJwcm9qZWN0Iiwic2NhbGUiLCJ0cmFuc2Zvcm1hdGlvbiIsIl90cmFuc2Zvcm0iLCJwb2ludFRvTGF0TG5nIiwidW50cmFuc2Zvcm1lZFBvaW50IiwidW50cmFuc2Zvcm0iLCJ1bnByb2plY3QiLCJsb2ciLCJMTjIiLCJnZXRQcm9qZWN0ZWRCb3VuZHMiLCJpbmZpbml0ZSIsInMiLCJ0cmFuc2Zvcm0iLCJ3cmFwTG5nIiwid3JhcExhdCIsIndyYXBMYXRMbmdCb3VuZHMiLCJjZW50ZXIiLCJuZXdDZW50ZXIiLCJsYXRTaGlmdCIsImxuZ1NoaWZ0IiwibmV3U3ciLCJuZXdOZSIsIlIiLCJsYXRsbmcxIiwibGF0bG5nMiIsInJhZCIsImxhdDEiLCJsYXQyIiwic2luRExhdCIsInNpbiIsInNpbkRMb24iLCJhdGFuMiIsImVhcnRoUmFkaXVzIiwiU3BoZXJpY2FsTWVyY2F0b3IiLCJNQVhfTEFUSVRVREUiLCJhdGFuIiwiZXhwIiwiVHJhbnNmb3JtYXRpb24iLCJfYSIsIl9iIiwiX2MiLCJfZCIsInRvVHJhbnNmb3JtYXRpb24iLCJFUFNHMzg1NyIsImNvZGUiLCJFUFNHOTAwOTEzIiwic3ZnQ3JlYXRlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJwb2ludHNUb1BhdGgiLCJyaW5ncyIsImNsb3NlZCIsImxlbjIiLCJwIiwiQnJvd3NlciIsInN2ZyIsInN0eWxlIiwiZG9jdW1lbnRFbGVtZW50IiwiaWUiLCJpZWx0OSIsImVkZ2UiLCJuYXZpZ2F0b3IiLCJ3ZWJraXQiLCJ1c2VyQWdlbnRDb250YWlucyIsImFuZHJvaWQiLCJhbmRyb2lkMjMiLCJ3ZWJraXRWZXIiLCJwYXJzZUludCIsImV4ZWMiLCJ1c2VyQWdlbnQiLCJhbmRyb2lkU3RvY2siLCJvcGVyYSIsImNocm9tZSIsImdlY2tvIiwic2FmYXJpIiwicGhhbnRvbSIsIm9wZXJhMTIiLCJ3aW4iLCJwbGF0Zm9ybSIsImllM2QiLCJ3ZWJraXQzZCIsIldlYktpdENTU01hdHJpeCIsImdlY2tvM2QiLCJhbnkzZCIsIkxfRElTQUJMRV8zRCIsIm1vYmlsZSIsIm9yaWVudGF0aW9uIiwibW9iaWxlV2Via2l0IiwibW9iaWxlV2Via2l0M2QiLCJtc1BvaW50ZXIiLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXJFdmVudCIsInBvaW50ZXIiLCJ0b3VjaE5hdGl2ZSIsIlRvdWNoRXZlbnQiLCJ0b3VjaCIsIkxfTk9fVE9VQ0giLCJtb2JpbGVPcGVyYSIsIm1vYmlsZUdlY2tvIiwicmV0aW5hIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNjcmVlbiIsImRldmljZVhEUEkiLCJsb2dpY2FsWERQSSIsInBhc3NpdmVFdmVudHMiLCJzdXBwb3J0c1Bhc3NpdmVPcHRpb24iLCJvcHRzIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJjYW52YXMkMSIsImNyZWF0ZUVsZW1lbnQiLCJnZXRDb250ZXh0Iiwic3ZnJDEiLCJjcmVhdGVTVkdSZWN0IiwiaW5saW5lU3ZnIiwiZGl2IiwiaW5uZXJIVE1MIiwiZmlyc3RDaGlsZCIsIm5hbWVzcGFjZVVSSSIsInZtbCIsInNoYXBlIiwiYmVoYXZpb3IiLCJhZGoiLCJtYWMiLCJsaW51eCIsInRvTG93ZXJDYXNlIiwiY2FudmFzIiwiUE9JTlRFUl9ET1dOIiwiUE9JTlRFUl9NT1ZFIiwiUE9JTlRFUl9VUCIsIlBPSU5URVJfQ0FOQ0VMIiwicEV2ZW50IiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwidG91Y2hjYW5jZWwiLCJoYW5kbGUiLCJfb25Qb2ludGVyU3RhcnQiLCJfaGFuZGxlUG9pbnRlciIsIl9wb2ludGVycyIsIl9wb2ludGVyRG9jTGlzdGVuZXIiLCJhZGRQb2ludGVyTGlzdGVuZXIiLCJoYW5kbGVyIiwiX2FkZFBvaW50ZXJEb2NMaXN0ZW5lciIsInJlbW92ZVBvaW50ZXJMaXN0ZW5lciIsIl9nbG9iYWxQb2ludGVyRG93biIsInBvaW50ZXJJZCIsIl9nbG9iYWxQb2ludGVyTW92ZSIsIl9nbG9iYWxQb2ludGVyVXAiLCJwb2ludGVyVHlwZSIsIk1TUE9JTlRFUl9UWVBFX01PVVNFIiwidG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiTVNQT0lOVEVSX1RZUEVfVE9VQ0giLCJwcmV2ZW50RGVmYXVsdCIsIm1ha2VEYmxjbGljayIsIm5ld0V2ZW50IiwicHJvcCIsImRldGFpbCIsImlzVHJ1c3RlZCIsIl9zaW11bGF0ZWQiLCJkZWxheSIsImFkZERvdWJsZVRhcExpc3RlbmVyIiwibGFzdCIsInNpbURibGNsaWNrIiwic291cmNlQ2FwYWJpbGl0aWVzIiwiZmlyZXNUb3VjaEV2ZW50cyIsInBhdGgiLCJnZXRQcm9wYWdhdGlvblBhdGgiLCJzb21lIiwiSFRNTExhYmVsRWxlbWVudCIsImF0dHJpYnV0ZXMiLCJmb3IiLCJIVE1MSW5wdXRFbGVtZW50IiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJub3ciLCJkYmxjbGljayIsInJlbW92ZURvdWJsZVRhcExpc3RlbmVyIiwiaGFuZGxlcnMiLCJUUkFOU0ZPUk0iLCJ0ZXN0UHJvcCIsIlRSQU5TSVRJT04iLCJUUkFOU0lUSU9OX0VORCIsImdldEVsZW1lbnRCeUlkIiwiZ2V0U3R5bGUiLCJjdXJyZW50U3R5bGUiLCJkZWZhdWx0VmlldyIsImNzcyIsImdldENvbXB1dGVkU3R5bGUiLCJjcmVhdGUkMSIsInRhZ05hbWUiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJhcHBlbmRDaGlsZCIsInJlbW92ZSIsInBhcmVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImVtcHR5IiwidG9Gcm9udCIsImxhc3RDaGlsZCIsInRvQmFjayIsImluc2VydEJlZm9yZSIsImhhc0NsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0Q2xhc3MiLCJSZWdFeHAiLCJ0ZXN0IiwiYWRkQ2xhc3MiLCJjbGFzc2VzIiwic2V0Q2xhc3MiLCJyZW1vdmVDbGFzcyIsImJhc2VWYWwiLCJjb3JyZXNwb25kaW5nRWxlbWVudCIsInNldE9wYWNpdHkiLCJvcGFjaXR5IiwiX3NldE9wYWNpdHlJRSIsImZpbHRlciIsImZpbHRlck5hbWUiLCJmaWx0ZXJzIiwiaXRlbSIsIkVuYWJsZWQiLCJPcGFjaXR5Iiwic2V0VHJhbnNmb3JtIiwib2Zmc2V0IiwicG9zIiwic2V0UG9zaXRpb24iLCJfbGVhZmxldF9wb3MiLCJsZWZ0IiwidG9wIiwiZ2V0UG9zaXRpb24iLCJkaXNhYmxlVGV4dFNlbGVjdGlvbiIsImVuYWJsZVRleHRTZWxlY3Rpb24iLCJfdXNlclNlbGVjdCIsInVzZXJTZWxlY3RQcm9wZXJ0eSIsImRpc2FibGVJbWFnZURyYWciLCJlbmFibGVJbWFnZURyYWciLCJfb3V0bGluZUVsZW1lbnQiLCJfb3V0bGluZVN0eWxlIiwicHJldmVudE91dGxpbmUiLCJlbGVtZW50IiwidGFiSW5kZXgiLCJyZXN0b3JlT3V0bGluZSIsIm91dGxpbmVTdHlsZSIsImdldFNpemVkUGFyZW50Tm9kZSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiYm9keSIsImdldFNjYWxlIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiYm91bmRpbmdDbGllbnRSZWN0IiwiRG9tVXRpbCIsImFkZE9uZSIsImV2ZW50c0tleSIsImJhdGNoUmVtb3ZlIiwicmVtb3ZlT25lIiwiZmlsdGVyRm4iLCJtb3VzZVN1YnN0IiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJ3aGVlbCIsIm9yaWdpbmFsSGFuZGxlciIsInBhc3NpdmUiLCJpc0V4dGVybmFsVGFyZ2V0IiwiYXR0YWNoRXZlbnQiLCJkZXRhY2hFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsIm9yaWdpbmFsRXZlbnQiLCJfc3RvcHBlZCIsImNhbmNlbEJ1YmJsZSIsImRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbiIsImRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwicmV0dXJuVmFsdWUiLCJzdG9wIiwiZXYiLCJjb21wb3NlZFBhdGgiLCJnZXRNb3VzZVBvc2l0aW9uIiwiY2xpZW50WCIsImNsaWVudFkiLCJjbGllbnRMZWZ0IiwiY2xpZW50VG9wIiwid2hlZWxQeEZhY3RvciIsImdldFdoZWVsRGVsdGEiLCJ3aGVlbERlbHRhWSIsImRlbHRhWSIsImRlbHRhTW9kZSIsImRlbHRhWCIsImRlbHRhWiIsIndoZWVsRGVsdGEiLCJyZWxhdGVkIiwicmVsYXRlZFRhcmdldCIsImVyciIsIkRvbUV2ZW50IiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIlBvc0FuaW1hdGlvbiIsInJ1biIsIm5ld1BvcyIsImR1cmF0aW9uIiwiZWFzZUxpbmVhcml0eSIsIl9lbCIsIl9pblByb2dyZXNzIiwiX2R1cmF0aW9uIiwiX2Vhc2VPdXRQb3dlciIsIl9zdGFydFBvcyIsIl9vZmZzZXQiLCJfc3RhcnRUaW1lIiwiX2FuaW1hdGUiLCJfc3RlcCIsIl9jb21wbGV0ZSIsIl9hbmltSWQiLCJlbGFwc2VkIiwiX3J1bkZyYW1lIiwiX2Vhc2VPdXQiLCJwcm9ncmVzcyIsInQiLCJNYXAiLCJjcnMiLCJtaW5ab29tIiwibWF4Wm9vbSIsImxheWVycyIsIm1heEJvdW5kcyIsInJlbmRlcmVyIiwiem9vbUFuaW1hdGlvbiIsInpvb21BbmltYXRpb25UaHJlc2hvbGQiLCJmYWRlQW5pbWF0aW9uIiwibWFya2VyWm9vbUFuaW1hdGlvbiIsInRyYW5zZm9ybTNETGltaXQiLCJ6b29tU25hcCIsInpvb21EZWx0YSIsInRyYWNrUmVzaXplIiwiX2hhbmRsZXJzIiwiX2xheWVycyIsIl96b29tQm91bmRMYXllcnMiLCJfc2l6ZUNoYW5nZWQiLCJfaW5pdENvbnRhaW5lciIsIl9pbml0TGF5b3V0IiwiX29uUmVzaXplIiwiX2luaXRFdmVudHMiLCJzZXRNYXhCb3VuZHMiLCJfem9vbSIsIl9saW1pdFpvb20iLCJzZXRWaWV3IiwicmVzZXQiLCJfem9vbUFuaW1hdGVkIiwiX2NyZWF0ZUFuaW1Qcm94eSIsIl9wcm94eSIsIl9jYXRjaFRyYW5zaXRpb25FbmQiLCJfYWRkTGF5ZXJzIiwiX2xpbWl0Q2VudGVyIiwiX3N0b3AiLCJfbG9hZGVkIiwiYW5pbWF0ZSIsInBhbiIsIm1vdmVkIiwiX3RyeUFuaW1hdGVkWm9vbSIsIl90cnlBbmltYXRlZFBhbiIsIl9zaXplVGltZXIiLCJfcmVzZXRWaWV3Iiwibm9Nb3ZlU3RhcnQiLCJzZXRab29tIiwiem9vbUluIiwiZGVsdGEiLCJ6b29tT3V0Iiwic2V0Wm9vbUFyb3VuZCIsImdldFpvb21TY2FsZSIsInZpZXdIYWxmIiwiY29udGFpbmVyUG9pbnQiLCJsYXRMbmdUb0NvbnRhaW5lclBvaW50IiwiY2VudGVyT2Zmc2V0IiwiY29udGFpbmVyUG9pbnRUb0xhdExuZyIsIl9nZXRCb3VuZHNDZW50ZXJab29tIiwiZ2V0Qm91bmRzIiwicGFkZGluZ1RMIiwicGFkZGluZ1RvcExlZnQiLCJwYWRkaW5nIiwicGFkZGluZ0JSIiwicGFkZGluZ0JvdHRvbVJpZ2h0IiwiZ2V0Qm91bmRzWm9vbSIsIkluZmluaXR5IiwicGFkZGluZ09mZnNldCIsInN3UG9pbnQiLCJuZVBvaW50IiwiZml0Qm91bmRzIiwiZml0V29ybGQiLCJwYW5UbyIsInBhbkJ5IiwiZ2V0Wm9vbSIsIl9wYW5BbmltIiwiX29uUGFuVHJhbnNpdGlvblN0ZXAiLCJfb25QYW5UcmFuc2l0aW9uRW5kIiwiX21hcFBhbmUiLCJfZ2V0TWFwUGFuZVBvcyIsIl9yYXdQYW5CeSIsImZseVRvIiwidGFyZ2V0Q2VudGVyIiwidGFyZ2V0Wm9vbSIsImZyb20iLCJ0byIsInNpemUiLCJzdGFydFpvb20iLCJ3MCIsIncxIiwidTEiLCJyaG8iLCJyaG8yIiwiciIsInMxIiwiczIiLCJ0MSIsImIxIiwic3EiLCJzaW5oIiwibiIsImNvc2giLCJ0YW5oIiwicjAiLCJ3IiwidSIsImVhc2VPdXQiLCJzdGFydCIsIlMiLCJmcmFtZSIsIl9mbHlUb0ZyYW1lIiwiX21vdmUiLCJnZXRTY2FsZVpvb20iLCJfbW92ZUVuZCIsIl9tb3ZlU3RhcnQiLCJmbHlUb0JvdW5kcyIsIl9wYW5JbnNpZGVNYXhCb3VuZHMiLCJzZXRNaW5ab29tIiwib2xkWm9vbSIsInNldE1heFpvb20iLCJwYW5JbnNpZGVCb3VuZHMiLCJfZW5mb3JjaW5nQm91bmRzIiwicGFuSW5zaWRlIiwicGl4ZWxDZW50ZXIiLCJwaXhlbFBvaW50IiwicGl4ZWxCb3VuZHMiLCJnZXRQaXhlbEJvdW5kcyIsInBhZGRlZEJvdW5kcyIsInBhZGRlZFNpemUiLCJpbnZhbGlkYXRlU2l6ZSIsIm9sZFNpemUiLCJfbGFzdENlbnRlciIsIm5ld1NpemUiLCJvbGRDZW50ZXIiLCJkZWJvdW5jZU1vdmVlbmQiLCJsb2NhdGUiLCJfbG9jYXRlT3B0aW9ucyIsInRpbWVvdXQiLCJ3YXRjaCIsIl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yIiwibWVzc2FnZSIsIm9uUmVzcG9uc2UiLCJfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSIsIm9uRXJyb3IiLCJfbG9jYXRpb25XYXRjaElkIiwiZ2VvbG9jYXRpb24iLCJ3YXRjaFBvc2l0aW9uIiwiZ2V0Q3VycmVudFBvc2l0aW9uIiwic3RvcExvY2F0ZSIsImNsZWFyV2F0Y2giLCJlcnJvciIsIl9jb250YWluZXIiLCJjb29yZHMiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImFjY3VyYWN5IiwidGltZXN0YW1wIiwiYWRkSGFuZGxlciIsIkhhbmRsZXJDbGFzcyIsImVuYWJsZSIsIl9jb250YWluZXJJZCIsIl9jbGVhckNvbnRyb2xQb3MiLCJfcmVzaXplUmVxdWVzdCIsIl9jbGVhckhhbmRsZXJzIiwiX3BhbmVzIiwiX3JlbmRlcmVyIiwiY3JlYXRlUGFuZSIsInBhbmUiLCJfY2hlY2tJZkxvYWRlZCIsIl9tb3ZlZCIsImxheWVyUG9pbnRUb0xhdExuZyIsIl9nZXRDZW50ZXJMYXllclBvaW50IiwiZ2V0TWluWm9vbSIsIl9sYXllcnNNaW5ab29tIiwiZ2V0TWF4Wm9vbSIsIl9sYXllcnNNYXhab29tIiwiaW5zaWRlIiwibnciLCJzZSIsImJvdW5kc1NpemUiLCJzbmFwIiwic2NhbGV4Iiwic2NhbGV5IiwiX3NpemUiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInRvcExlZnRQb2ludCIsIl9nZXRUb3BMZWZ0UG9pbnQiLCJnZXRQaXhlbE9yaWdpbiIsIl9waXhlbE9yaWdpbiIsImdldFBpeGVsV29ybGRCb3VuZHMiLCJnZXRQYW5lIiwiZ2V0UGFuZXMiLCJnZXRDb250YWluZXIiLCJ0b1pvb20iLCJmcm9tWm9vbSIsImxhdExuZ1RvTGF5ZXJQb2ludCIsImNvbnRhaW5lclBvaW50VG9MYXllclBvaW50IiwibGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQiLCJsYXllclBvaW50IiwibW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQiLCJtb3VzZUV2ZW50VG9MYXllclBvaW50IiwibW91c2VFdmVudFRvTGF0TG5nIiwiX29uU2Nyb2xsIiwiX2ZhZGVBbmltYXRlZCIsInBvc2l0aW9uIiwiX2luaXRQYW5lcyIsIl9pbml0Q29udHJvbFBvcyIsInBhbmVzIiwiX3BhbmVSZW5kZXJlcnMiLCJtYXJrZXJQYW5lIiwic2hhZG93UGFuZSIsImxvYWRpbmciLCJ6b29tQ2hhbmdlZCIsInN1cHJlc3NFdmVudCIsIl9nZXROZXdQaXhlbE9yaWdpbiIsInBpbmNoIiwiX2dldFpvb21TcGFuIiwiX3RhcmdldHMiLCJvbk9mZiIsIl9oYW5kbGVET01FdmVudCIsIl9vbk1vdmVFbmQiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwiX2ZpbmRFdmVudFRhcmdldHMiLCJ0YXJnZXRzIiwiaXNIb3ZlciIsInNyY0VsZW1lbnQiLCJkcmFnZ2luZyIsIl9kcmFnZ2FibGVNb3ZlZCIsIl9pc0NsaWNrRGlzYWJsZWQiLCJfZmlyZURPTUV2ZW50IiwiX21vdXNlRXZlbnRzIiwiY2FudmFzVGFyZ2V0cyIsInN5bnRoIiwiZmlsdGVyZWQiLCJpc01hcmtlciIsImdldExhdExuZyIsIl9yYWRpdXMiLCJidWJibGluZ01vdXNlRXZlbnRzIiwiZW5hYmxlZCIsImJveFpvb20iLCJkaXNhYmxlIiwid2hlblJlYWR5IiwiY2FsbGJhY2siLCJwaXhlbE9yaWdpbiIsIl9sYXRMbmdUb05ld0xheWVyUG9pbnQiLCJ0b3BMZWZ0IiwiX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHMiLCJsYXRMbmdCb3VuZHMiLCJfZ2V0Q2VudGVyT2Zmc2V0IiwiY2VudGVyUG9pbnQiLCJ2aWV3Qm91bmRzIiwiX2dldEJvdW5kc09mZnNldCIsIl9saW1pdE9mZnNldCIsIm5ld0JvdW5kcyIsInB4Qm91bmRzIiwicHJvamVjdGVkTWF4Qm91bmRzIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiZHgiLCJfcmVib3VuZCIsImR5IiwicmlnaHQiLCJwcm94eSIsIm1hcFBhbmUiLCJfYW5pbWF0aW5nWm9vbSIsIl9vblpvb21UcmFuc2l0aW9uRW5kIiwiX2FuaW1Nb3ZlRW5kIiwiX2Rlc3Ryb3lBbmltUHJveHkiLCJ6IiwicHJvcGVydHlOYW1lIiwiX25vdGhpbmdUb0FuaW1hdGUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiX2FuaW1hdGVab29tIiwic3RhcnRBbmltIiwibm9VcGRhdGUiLCJfYW5pbWF0ZVRvQ2VudGVyIiwiX2FuaW1hdGVUb1pvb20iLCJfdGVtcEZpcmVab29tRXZlbnQiLCJjcmVhdGVNYXAiLCJDb250cm9sIiwibWFwIiwiX21hcCIsInJlbW92ZUNvbnRyb2wiLCJhZGRDb250cm9sIiwiYWRkVG8iLCJvbkFkZCIsImNvcm5lciIsIl9jb250cm9sQ29ybmVycyIsIm9uUmVtb3ZlIiwiX3JlZm9jdXNPbk1hcCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiZm9jdXMiLCJjb250cm9sIiwiY29ybmVycyIsIl9jb250cm9sQ29udGFpbmVyIiwiY3JlYXRlQ29ybmVyIiwidlNpZGUiLCJoU2lkZSIsIkxheWVycyIsImNvbGxhcHNlZCIsImF1dG9aSW5kZXgiLCJoaWRlU2luZ2xlQmFzZSIsInNvcnRMYXllcnMiLCJzb3J0RnVuY3Rpb24iLCJsYXllckEiLCJsYXllckIiLCJuYW1lQSIsIm5hbWVCIiwiYmFzZUxheWVycyIsIm92ZXJsYXlzIiwiX2xheWVyQ29udHJvbElucHV0cyIsIl9sYXN0WkluZGV4IiwiX2hhbmRsaW5nQ2xpY2siLCJfcHJldmVudENsaWNrIiwiX2FkZExheWVyIiwiX3VwZGF0ZSIsIl9jaGVja0Rpc2FibGVkTGF5ZXJzIiwiX29uTGF5ZXJDaGFuZ2UiLCJfZXhwYW5kSWZOb3RDb2xsYXBzZWQiLCJhZGRCYXNlTGF5ZXIiLCJhZGRPdmVybGF5IiwicmVtb3ZlTGF5ZXIiLCJfZ2V0TGF5ZXIiLCJleHBhbmQiLCJfc2VjdGlvbiIsImFjY2VwdGFibGVIZWlnaHQiLCJvZmZzZXRUb3AiLCJjb2xsYXBzZSIsInNldEF0dHJpYnV0ZSIsInNlY3Rpb24iLCJfZXhwYW5kU2FmZWx5IiwibGluayIsIl9sYXllcnNMaW5rIiwiaHJlZiIsInRpdGxlIiwia2V5ZG93biIsImtleUNvZGUiLCJjbGljayIsIl9iYXNlTGF5ZXJzTGlzdCIsIl9zZXBhcmF0b3IiLCJfb3ZlcmxheXNMaXN0Iiwib3ZlcmxheSIsInNvcnQiLCJzZXRaSW5kZXgiLCJiYXNlTGF5ZXJzUHJlc2VudCIsIm92ZXJsYXlzUHJlc2VudCIsImJhc2VMYXllcnNDb3VudCIsIl9hZGRJdGVtIiwiZGlzcGxheSIsIl9jcmVhdGVSYWRpb0VsZW1lbnQiLCJjaGVja2VkIiwicmFkaW9IdG1sIiwicmFkaW9GcmFnbWVudCIsImxhYmVsIiwiaGFzTGF5ZXIiLCJpbnB1dCIsImRlZmF1bHRDaGVja2VkIiwibGF5ZXJJZCIsIl9vbklucHV0Q2xpY2siLCJob2xkZXIiLCJpbnB1dHMiLCJhZGRlZExheWVycyIsInJlbW92ZWRMYXllcnMiLCJhZGRMYXllciIsImRpc2FibGVkIiwidGhhdCIsIlpvb20iLCJ6b29tSW5UZXh0Iiwiem9vbUluVGl0bGUiLCJ6b29tT3V0VGV4dCIsInpvb21PdXRUaXRsZSIsInpvb21OYW1lIiwiX3pvb21JbkJ1dHRvbiIsIl9jcmVhdGVCdXR0b24iLCJfem9vbUluIiwiX3pvb21PdXRCdXR0b24iLCJfem9vbU91dCIsIl91cGRhdGVEaXNhYmxlZCIsIl9kaXNhYmxlZCIsInNoaWZ0S2V5IiwiaHRtbCIsInpvb21Db250cm9sIiwiU2NhbGUiLCJtYXhXaWR0aCIsIm1ldHJpYyIsImltcGVyaWFsIiwiX2FkZFNjYWxlcyIsInVwZGF0ZVdoZW5JZGxlIiwiX21TY2FsZSIsIl9pU2NhbGUiLCJtYXhNZXRlcnMiLCJfdXBkYXRlU2NhbGVzIiwiX3VwZGF0ZU1ldHJpYyIsIl91cGRhdGVJbXBlcmlhbCIsIm1ldGVycyIsIl9nZXRSb3VuZE51bSIsIl91cGRhdGVTY2FsZSIsIm1heEZlZXQiLCJtYXhNaWxlcyIsIm1pbGVzIiwiZmVldCIsInRleHQiLCJyYXRpbyIsInBvdzEwIiwidWtyYWluaWFuRmxhZyIsIkF0dHJpYnV0aW9uIiwicHJlZml4IiwiX2F0dHJpYnV0aW9ucyIsImF0dHJpYnV0aW9uQ29udHJvbCIsImdldEF0dHJpYnV0aW9uIiwiYWRkQXR0cmlidXRpb24iLCJfYWRkQXR0cmlidXRpb24iLCJyZW1vdmVBdHRyaWJ1dGlvbiIsInNldFByZWZpeCIsImF0dHJpYnMiLCJwcmVmaXhBbmRBdHRyaWJzIiwiYXR0cmlidXRpb24iLCJIYW5kbGVyIiwiX2VuYWJsZWQiLCJhZGRIb29rcyIsInJlbW92ZUhvb2tzIiwiU1RBUlQiLCJEcmFnZ2FibGUiLCJjbGlja1RvbGVyYW5jZSIsImRyYWdTdGFydFRhcmdldCIsIl9lbGVtZW50IiwiX2RyYWdTdGFydFRhcmdldCIsIl9wcmV2ZW50T3V0bGluZSIsIl9vbkRvd24iLCJfZHJhZ2dpbmciLCJmaW5pc2hEcmFnIiwid2hpY2giLCJidXR0b24iLCJfbW92aW5nIiwiZmlyc3QiLCJzaXplZFBhcmVudCIsIl9zdGFydFBvaW50IiwiX3BhcmVudFNjYWxlIiwibW91c2VldmVudCIsIl9vbk1vdmUiLCJfb25VcCIsIl9sYXN0VGFyZ2V0IiwiU1ZHRWxlbWVudEluc3RhbmNlIiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJfbmV3UG9zIiwiX2xhc3RFdmVudCIsIl91cGRhdGVQb3NpdGlvbiIsIm5vSW5lcnRpYSIsImZpcmVEcmFnZW5kIiwiY2xpcFBvbHlnb24iLCJjbGlwcGVkUG9pbnRzIiwiZWRnZXMiLCJrIiwiX2NvZGUiLCJfZ2V0Qml0Q29kZSIsIl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwicG9seWdvbkNlbnRlciIsInAxIiwicDIiLCJmIiwiYXJlYSIsImlzRmxhdCIsImNlbnRyb2lkTGF0TG5nIiwiYXJlYUJvdW5kcyIsImNlbnRyb2lkIiwibGF0bG5nQ2VudGVyIiwibGF0U3VtIiwibG5nU3VtIiwiUG9seVV0aWwiLCJzaW1wbGlmeSIsInRvbGVyYW5jZSIsInNxVG9sZXJhbmNlIiwiX3JlZHVjZVBvaW50cyIsIl9zaW1wbGlmeURQIiwicG9pbnRUb1NlZ21lbnREaXN0YW5jZSIsIl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCIsImNsb3Nlc3RQb2ludE9uU2VnbWVudCIsIkFycmF5Q29uc3RydWN0b3IiLCJVaW50OEFycmF5IiwibWFya2VycyIsIl9zaW1wbGlmeURQU3RlcCIsIm5ld1BvaW50cyIsIm1heFNxRGlzdCIsInNxRGlzdCIsInJlZHVjZWRQb2ludHMiLCJwcmV2IiwiX3NxRGlzdCIsIl9sYXN0Q29kZSIsImNsaXBTZWdtZW50IiwidXNlTGFzdENvZGUiLCJjb2RlQSIsImNvZGVCIiwiY29kZU91dCIsIm5ld0NvZGUiLCJkb3QiLCJfZmxhdCIsInBvbHlsaW5lQ2VudGVyIiwiaGFsZkRpc3QiLCJzZWdEaXN0IiwiZGlzdCIsIkxpbmVVdGlsIiwiTG9uTGF0IiwiTWVyY2F0b3IiLCJSX01JTk9SIiwidG1wIiwiY29uIiwidHMiLCJ0YW4iLCJwaGkiLCJkcGhpIiwiRVBTRzMzOTUiLCJFUFNHNDMyNiIsIlNpbXBsZSIsIkxheWVyIiwicmVtb3ZlRnJvbSIsIl9tYXBUb0FkZCIsImFkZEludGVyYWN0aXZlVGFyZ2V0IiwidGFyZ2V0RWwiLCJyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCIsIl9sYXllckFkZCIsImdldEV2ZW50cyIsImV2ZW50cyIsImJlZm9yZUFkZCIsImVhY2hMYXllciIsIm1ldGhvZCIsIl9hZGRab29tTGltaXQiLCJfdXBkYXRlWm9vbUxldmVscyIsIl9yZW1vdmVab29tTGltaXQiLCJvbGRab29tU3BhbiIsIkxheWVyR3JvdXAiLCJnZXRMYXllcklkIiwiY2xlYXJMYXllcnMiLCJpbnZva2UiLCJtZXRob2ROYW1lIiwiZ2V0TGF5ZXIiLCJnZXRMYXllcnMiLCJ6SW5kZXgiLCJsYXllckdyb3VwIiwiRmVhdHVyZUdyb3VwIiwic2V0U3R5bGUiLCJicmluZ1RvRnJvbnQiLCJicmluZ1RvQmFjayIsImZlYXR1cmVHcm91cCIsIkljb24iLCJwb3B1cEFuY2hvciIsInRvb2x0aXBBbmNob3IiLCJjcm9zc09yaWdpbiIsImNyZWF0ZUljb24iLCJvbGRJY29uIiwiX2NyZWF0ZUljb24iLCJjcmVhdGVTaGFkb3ciLCJfZ2V0SWNvblVybCIsImltZyIsIl9jcmVhdGVJbWciLCJfc2V0SWNvblN0eWxlcyIsInNpemVPcHRpb24iLCJhbmNob3IiLCJzaGFkb3dBbmNob3IiLCJpY29uQW5jaG9yIiwibWFyZ2luTGVmdCIsIm1hcmdpblRvcCIsImljb24iLCJJY29uRGVmYXVsdCIsImljb25VcmwiLCJpY29uUmV0aW5hVXJsIiwic2hhZG93VXJsIiwiaWNvblNpemUiLCJzaGFkb3dTaXplIiwiaW1hZ2VQYXRoIiwiX2RldGVjdEljb25QYXRoIiwiX3N0cmlwVXJsIiwic3RyaXAiLCJyZSIsImlkeCIsIm1hdGNoIiwicXVlcnlTZWxlY3RvciIsInN1YnN0cmluZyIsIk1hcmtlckRyYWciLCJtYXJrZXIiLCJfbWFya2VyIiwiX2ljb24iLCJfZHJhZ2dhYmxlIiwiZHJhZ3N0YXJ0IiwiX29uRHJhZ1N0YXJ0IiwicHJlZHJhZyIsIl9vblByZURyYWciLCJkcmFnIiwiX29uRHJhZyIsImRyYWdlbmQiLCJfb25EcmFnRW5kIiwiX2FkanVzdFBhbiIsInNwZWVkIiwiYXV0b1BhblNwZWVkIiwiYXV0b1BhblBhZGRpbmciLCJpY29uUG9zIiwib3JpZ2luIiwicGFuQm91bmRzIiwibW92ZW1lbnQiLCJfcGFuUmVxdWVzdCIsIl9vbGRMYXRMbmciLCJjbG9zZVBvcHVwIiwiYXV0b1BhbiIsInNoYWRvdyIsIl9zaGFkb3ciLCJfbGF0bG5nIiwib2xkTGF0TG5nIiwiTWFya2VyIiwiaW50ZXJhY3RpdmUiLCJrZXlib2FyZCIsInpJbmRleE9mZnNldCIsInJpc2VPbkhvdmVyIiwicmlzZU9mZnNldCIsImF1dG9QYW5PbkZvY3VzIiwiZHJhZ2dhYmxlIiwiX2luaXRJY29uIiwidXBkYXRlIiwiX3JlbW92ZUljb24iLCJfcmVtb3ZlU2hhZG93Iiwidmlld3Jlc2V0Iiwic2V0TGF0TG5nIiwic2V0WkluZGV4T2Zmc2V0IiwiZ2V0SWNvbiIsInNldEljb24iLCJfcG9wdXAiLCJiaW5kUG9wdXAiLCJnZXRFbGVtZW50IiwiX3NldFBvcyIsImNsYXNzVG9BZGQiLCJhZGRJY29uIiwibW91c2VvdmVyIiwiX2JyaW5nVG9Gcm9udCIsIm1vdXNlb3V0IiwiX3Jlc2V0WkluZGV4IiwiX3Bhbk9uRm9jdXMiLCJuZXdTaGFkb3ciLCJhZGRTaGFkb3ciLCJfdXBkYXRlT3BhY2l0eSIsIl9pbml0SW50ZXJhY3Rpb24iLCJfekluZGV4IiwiX3VwZGF0ZVpJbmRleCIsIm9wdCIsImljb25PcHRzIiwiX2dldFBvcHVwQW5jaG9yIiwiX2dldFRvb2x0aXBBbmNob3IiLCJQYXRoIiwic3Ryb2tlIiwiY29sb3IiLCJ3ZWlnaHQiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJkYXNoQXJyYXkiLCJkYXNoT2Zmc2V0IiwiZmlsbCIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwiZmlsbFJ1bGUiLCJnZXRSZW5kZXJlciIsIl9pbml0UGF0aCIsIl9yZXNldCIsIl9hZGRQYXRoIiwiX3JlbW92ZVBhdGgiLCJyZWRyYXciLCJfdXBkYXRlUGF0aCIsIl91cGRhdGVTdHlsZSIsIl91cGRhdGVCb3VuZHMiLCJfYnJpbmdUb0JhY2siLCJfcGF0aCIsIl9wcm9qZWN0IiwiX2NsaWNrVG9sZXJhbmNlIiwiQ2lyY2xlTWFya2VyIiwicmFkaXVzIiwic2V0UmFkaXVzIiwiZ2V0UmFkaXVzIiwiX3BvaW50IiwicjIiLCJfcmFkaXVzWSIsIl9weEJvdW5kcyIsIl91cGRhdGVDaXJjbGUiLCJfZW1wdHkiLCJfYm91bmRzIiwiX2NvbnRhaW5zUG9pbnQiLCJjaXJjbGVNYXJrZXIiLCJDaXJjbGUiLCJsZWdhY3lPcHRpb25zIiwiX21SYWRpdXMiLCJoYWxmIiwibGF0UiIsImJvdHRvbSIsImxuZ1IiLCJhY29zIiwiY2lyY2xlIiwiUG9seWxpbmUiLCJzbW9vdGhGYWN0b3IiLCJub0NsaXAiLCJfc2V0TGF0TG5ncyIsImdldExhdExuZ3MiLCJfbGF0bG5ncyIsInNldExhdExuZ3MiLCJpc0VtcHR5IiwiY2xvc2VzdExheWVyUG9pbnQiLCJtaW5EaXN0YW5jZSIsIm1pblBvaW50IiwiY2xvc2VzdCIsImpMZW4iLCJfcGFydHMiLCJfZGVmYXVsdFNoYXBlIiwiYWRkTGF0TG5nIiwiX2NvbnZlcnRMYXRMbmdzIiwicmVzdWx0IiwiZmxhdCIsIl9yaW5ncyIsIl9wcm9qZWN0TGF0bG5ncyIsIl9yYXdQeEJvdW5kcyIsInByb2plY3RlZEJvdW5kcyIsInJpbmciLCJfY2xpcFBvaW50cyIsInBhcnRzIiwic2VnbWVudCIsIl9zaW1wbGlmeVBvaW50cyIsIl91cGRhdGVQb2x5IiwicGFydCIsInBvbHlsaW5lIiwiUG9seWdvbiIsInBvcCIsImNsaXBwZWQiLCJwb2x5Z29uIiwiR2VvSlNPTiIsImdlb2pzb24iLCJhZGREYXRhIiwiZmVhdHVyZXMiLCJmZWF0dXJlIiwiZ2VvbWV0cmllcyIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJnZW9tZXRyeVRvTGF5ZXIiLCJhc0ZlYXR1cmUiLCJkZWZhdWx0T3B0aW9ucyIsInJlc2V0U3R5bGUiLCJvbkVhY2hGZWF0dXJlIiwiX3NldExheWVyU3R5bGUiLCJwb2ludFRvTGF5ZXIiLCJfY29vcmRzVG9MYXRMbmciLCJjb29yZHNUb0xhdExuZyIsIl9wb2ludFRvTGF5ZXIiLCJjb29yZHNUb0xhdExuZ3MiLCJnZW9MYXllciIsInByb3BlcnRpZXMiLCJmZWF0dXJlTGF5ZXIiLCJwb2ludFRvTGF5ZXJGbiIsIm1hcmtlcnNJbmhlcml0T3B0aW9ucyIsImxldmVsc0RlZXAiLCJsYXRMbmdUb0Nvb3JkcyIsImxhdExuZ3NUb0Nvb3JkcyIsImdldEZlYXR1cmUiLCJuZXdHZW9tZXRyeSIsIlBvaW50VG9HZW9KU09OIiwidG9HZW9KU09OIiwibXVsdGkiLCJob2xlcyIsInRvTXVsdGlQb2ludCIsImlzR2VvbWV0cnlDb2xsZWN0aW9uIiwianNvbnMiLCJqc29uIiwiZ2VvSlNPTiIsImdlb0pzb24iLCJJbWFnZU92ZXJsYXkiLCJlcnJvck92ZXJsYXlVcmwiLCJ1cmwiLCJfdXJsIiwiX2ltYWdlIiwiX2luaXRJbWFnZSIsInN0eWxlT3B0cyIsInNldFVybCIsInNldEJvdW5kcyIsInpvb21hbmltIiwid2FzRWxlbWVudFN1cHBsaWVkIiwib25zZWxlY3RzdGFydCIsIm9ubW91c2Vtb3ZlIiwib25sb2FkIiwib25lcnJvciIsIl9vdmVybGF5T25FcnJvciIsImltYWdlIiwiZXJyb3JVcmwiLCJpbWFnZU92ZXJsYXkiLCJWaWRlb092ZXJsYXkiLCJhdXRvcGxheSIsImxvb3AiLCJrZWVwQXNwZWN0UmF0aW8iLCJtdXRlZCIsInBsYXlzSW5saW5lIiwidmlkIiwib25sb2FkZWRkYXRhIiwic291cmNlRWxlbWVudHMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInNvdXJjZXMiLCJzb3VyY2UiLCJ2aWRlb092ZXJsYXkiLCJ2aWRlbyIsIlNWR092ZXJsYXkiLCJzdmdPdmVybGF5IiwiRGl2T3ZlcmxheSIsImNvbnRlbnQiLCJfc291cmNlIiwiX2NvbnRlbnQiLCJvcGVuT24iLCJjbG9zZSIsInRvZ2dsZSIsIl9wcmVwYXJlT3BlbiIsIl9yZW1vdmVUaW1lb3V0IiwiZ2V0Q29udGVudCIsInNldENvbnRlbnQiLCJ2aXNpYmlsaXR5IiwiX3VwZGF0ZUNvbnRlbnQiLCJfdXBkYXRlTGF5b3V0IiwiaXNPcGVuIiwibm9kZSIsIl9jb250ZW50Tm9kZSIsImhhc0NoaWxkTm9kZXMiLCJfZ2V0QW5jaG9yIiwiX2NvbnRhaW5lckJvdHRvbSIsIl9jb250YWluZXJMZWZ0IiwiX2NvbnRhaW5lcldpZHRoIiwiX2luaXRPdmVybGF5IiwiT3ZlcmxheUNsYXNzIiwib2xkIiwiUG9wdXAiLCJtaW5XaWR0aCIsIm1heEhlaWdodCIsImF1dG9QYW5QYWRkaW5nVG9wTGVmdCIsImF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQiLCJrZWVwSW5WaWV3IiwiY2xvc2VCdXR0b24iLCJhdXRvQ2xvc2UiLCJjbG9zZU9uRXNjYXBlS2V5IiwicG9wdXAiLCJjbG9zZU9uQ2xpY2siLCJjbG9zZVBvcHVwT25DbGljayIsInByZWNsaWNrIiwibW92ZWVuZCIsIndyYXBwZXIiLCJfd3JhcHBlciIsIl90aXBDb250YWluZXIiLCJfdGlwIiwiX2Nsb3NlQnV0dG9uIiwid2hpdGVTcGFjZSIsInNjcm9sbGVkQ2xhc3MiLCJfYXV0b3Bhbm5pbmciLCJtYXJnaW5Cb3R0b20iLCJjb250YWluZXJIZWlnaHQiLCJjb250YWluZXJXaWR0aCIsImxheWVyUG9zIiwiY29udGFpbmVyUG9zIiwib3BlblBvcHVwIiwiX3BvcHVwSGFuZGxlcnNBZGRlZCIsIl9vcGVuUG9wdXAiLCJrZXlwcmVzcyIsIl9vbktleVByZXNzIiwibW92ZSIsIl9tb3ZlUG9wdXAiLCJ1bmJpbmRQb3B1cCIsInRvZ2dsZVBvcHVwIiwiaXNQb3B1cE9wZW4iLCJzZXRQb3B1cENvbnRlbnQiLCJnZXRQb3B1cCIsIlRvb2x0aXAiLCJkaXJlY3Rpb24iLCJwZXJtYW5lbnQiLCJzdGlja3kiLCJ0b29sdGlwIiwiX3NldFBvc2l0aW9uIiwic3ViWCIsInN1YlkiLCJ0b29sdGlwUG9pbnQiLCJ0b29sdGlwV2lkdGgiLCJ0b29sdGlwSGVpZ2h0Iiwib3BlblRvb2x0aXAiLCJjbG9zZVRvb2x0aXAiLCJiaW5kVG9vbHRpcCIsIl90b29sdGlwIiwiaXNUb29sdGlwT3BlbiIsInVuYmluZFRvb2x0aXAiLCJfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMiLCJfdG9vbHRpcEhhbmRsZXJzQWRkZWQiLCJfbW92ZVRvb2x0aXAiLCJfb3BlblRvb2x0aXAiLCJfYWRkRm9jdXNMaXN0ZW5lcnMiLCJtb3VzZW1vdmUiLCJfc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllciIsInRvZ2dsZVRvb2x0aXAiLCJzZXRUb29sdGlwQ29udGVudCIsImdldFRvb2x0aXAiLCJfYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyIiwibW92aW5nIiwiX29wZW5PbmNlRmxhZyIsIkRpdkljb24iLCJiZ1BvcyIsIkVsZW1lbnQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJkaXZJY29uIiwiRGVmYXVsdCIsIkdyaWRMYXllciIsInRpbGVTaXplIiwidXBkYXRlV2hlblpvb21pbmciLCJ1cGRhdGVJbnRlcnZhbCIsIm1heE5hdGl2ZVpvb20iLCJtaW5OYXRpdmVab29tIiwibm9XcmFwIiwia2VlcEJ1ZmZlciIsIl9sZXZlbHMiLCJfdGlsZXMiLCJfcmVtb3ZlQWxsVGlsZXMiLCJfdGlsZVpvb20iLCJfc2V0QXV0b1pJbmRleCIsImlzTG9hZGluZyIsIl9sb2FkaW5nIiwidGlsZVpvb20iLCJfY2xhbXBab29tIiwiX3VwZGF0ZUxldmVscyIsInZpZXdwcmVyZXNldCIsIl9pbnZhbGlkYXRlQWxsIiwiY3JlYXRlVGlsZSIsImdldFRpbGVTaXplIiwiY29tcGFyZSIsImNoaWxkcmVuIiwiZWRnZVpJbmRleCIsImlzRmluaXRlIiwibmV4dEZyYW1lIiwid2lsbFBydW5lIiwidGlsZSIsImN1cnJlbnQiLCJsb2FkZWQiLCJmYWRlIiwiYWN0aXZlIiwiX29uT3BhcXVlVGlsZSIsIl9ub1BydW5lIiwiX3BydW5lVGlsZXMiLCJfZmFkZUZyYW1lIiwiTnVtYmVyIiwiX29uVXBkYXRlTGV2ZWwiLCJfcmVtb3ZlVGlsZXNBdFpvb20iLCJfb25SZW1vdmVMZXZlbCIsImxldmVsIiwiX3NldFpvb21UcmFuc2Zvcm0iLCJfb25DcmVhdGVMZXZlbCIsIl9sZXZlbCIsInJldGFpbiIsIl9yZXRhaW5QYXJlbnQiLCJfcmV0YWluQ2hpbGRyZW4iLCJfcmVtb3ZlVGlsZSIsIngyIiwieTIiLCJ6MiIsImNvb3JkczIiLCJfdGlsZUNvb3Jkc1RvS2V5IiwiYW5pbWF0aW5nIiwiX3NldFZpZXciLCJub1BydW5lIiwidGlsZVpvb21DaGFuZ2VkIiwiX2Fib3J0TG9hZGluZyIsIl9yZXNldEdyaWQiLCJfc2V0Wm9vbVRyYW5zZm9ybXMiLCJ0cmFuc2xhdGUiLCJfdGlsZVNpemUiLCJfZ2xvYmFsVGlsZVJhbmdlIiwiX3B4Qm91bmRzVG9UaWxlUmFuZ2UiLCJfd3JhcFgiLCJfd3JhcFkiLCJfZ2V0VGlsZWRQaXhlbEJvdW5kcyIsIm1hcFpvb20iLCJoYWxmU2l6ZSIsInRpbGVSYW5nZSIsInRpbGVDZW50ZXIiLCJxdWV1ZSIsIm5vUHJ1bmVSYW5nZSIsIl9pc1ZhbGlkVGlsZSIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIl9hZGRUaWxlIiwidGlsZUJvdW5kcyIsIl90aWxlQ29vcmRzVG9Cb3VuZHMiLCJfa2V5VG9Cb3VuZHMiLCJfa2V5VG9UaWxlQ29vcmRzIiwiX3RpbGVDb29yZHNUb053U2UiLCJud1BvaW50Iiwic2VQb2ludCIsImJwIiwiX2luaXRUaWxlIiwidGlsZVBvcyIsIl9nZXRUaWxlUG9zIiwiX3dyYXBDb29yZHMiLCJfdGlsZVJlYWR5IiwiX25vVGlsZXNUb0xvYWQiLCJuZXdDb29yZHMiLCJncmlkTGF5ZXIiLCJUaWxlTGF5ZXIiLCJzdWJkb21haW5zIiwiZXJyb3JUaWxlVXJsIiwiem9vbU9mZnNldCIsInRtcyIsInpvb21SZXZlcnNlIiwiZGV0ZWN0UmV0aW5hIiwicmVmZXJyZXJQb2xpY3kiLCJfb25UaWxlUmVtb3ZlIiwibm9SZWRyYXciLCJkb25lIiwiX3RpbGVPbkxvYWQiLCJfdGlsZU9uRXJyb3IiLCJnZXRUaWxlVXJsIiwiX2dldFN1YmRvbWFpbiIsIl9nZXRab29tRm9yVXJsIiwiaW52ZXJ0ZWRZIiwiZ2V0QXR0cmlidXRlIiwidGlsZVBvaW50IiwiY29tcGxldGUiLCJ0aWxlTGF5ZXIiLCJUaWxlTGF5ZXJXTVMiLCJkZWZhdWx0V21zUGFyYW1zIiwic2VydmljZSIsInJlcXVlc3QiLCJzdHlsZXMiLCJmb3JtYXQiLCJ0cmFuc3BhcmVudCIsIndtc1BhcmFtcyIsInJlYWxSZXRpbmEiLCJfY3JzIiwiX3dtc1ZlcnNpb24iLCJwYXJzZUZsb2F0IiwicHJvamVjdGlvbktleSIsImJib3giLCJzZXRQYXJhbXMiLCJ0aWxlTGF5ZXJXTVMiLCJXTVMiLCJ3bXMiLCJSZW5kZXJlciIsIl91cGRhdGVQYXRocyIsIl9kZXN0cm95Q29udGFpbmVyIiwiX29uWm9vbSIsInpvb21lbmQiLCJfb25ab29tRW5kIiwiX29uQW5pbVpvb20iLCJfdXBkYXRlVHJhbnNmb3JtIiwiY3VycmVudENlbnRlclBvaW50IiwiX2NlbnRlciIsInRvcExlZnRPZmZzZXQiLCJDYW52YXMiLCJfb25WaWV3UHJlUmVzZXQiLCJfcG9zdHBvbmVVcGRhdGVQYXRocyIsIl9kcmF3IiwiX29uTW91c2VNb3ZlIiwiX29uQ2xpY2siLCJfaGFuZGxlTW91c2VPdXQiLCJfY3R4IiwiX3JlZHJhd1JlcXVlc3QiLCJfcmVkcmF3Qm91bmRzIiwiX3JlZHJhdyIsIm0iLCJfdXBkYXRlRGFzaEFycmF5Iiwib3JkZXIiLCJfb3JkZXIiLCJfZHJhd0xhc3QiLCJuZXh0IiwiX2RyYXdGaXJzdCIsIl9yZXF1ZXN0UmVkcmF3IiwiX2V4dGVuZFJlZHJhd0JvdW5kcyIsImRhc2hWYWx1ZSIsIl9kYXNoQXJyYXkiLCJfY2xlYXIiLCJjbGVhclJlY3QiLCJzYXZlIiwicmVzdG9yZSIsImJlZ2luUGF0aCIsImNsaXAiLCJfZHJhd2luZyIsImNsb3NlUGF0aCIsIl9maWxsU3Ryb2tlIiwiYXJjIiwiZ2xvYmFsQWxwaGEiLCJmaWxsU3R5bGUiLCJzZXRMaW5lRGFzaCIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwiY2xpY2tlZExheWVyIiwiX2ZpcmVFdmVudCIsIl9oYW5kbGVNb3VzZUhvdmVyIiwiX2hvdmVyZWRMYXllciIsIl9tb3VzZUhvdmVyVGhyb3R0bGVkIiwiY2FuZGlkYXRlSG92ZXJlZExheWVyIiwidm1sQ3JlYXRlIiwibmFtZXNwYWNlcyIsInZtbE1peGluIiwiY29vcmRzaXplIiwiX3N0cm9rZSIsIl9maWxsIiwic3Ryb2tlZCIsImZpbGxlZCIsImRhc2hTdHlsZSIsImVuZGNhcCIsImpvaW5zdHlsZSIsIl9zZXRQYXRoIiwiU1ZHIiwiX3Jvb3RHcm91cCIsIl9zdmdTaXplIiwicmVtb3ZlQXR0cmlidXRlIiwiX2dldFBhbmVSZW5kZXJlciIsIl9jcmVhdGVSZW5kZXJlciIsInByZWZlckNhbnZhcyIsIlJlY3RhbmdsZSIsIl9ib3VuZHNUb0xhdExuZ3MiLCJyZWN0YW5nbGUiLCJCb3hab29tIiwiX3BhbmUiLCJvdmVybGF5UGFuZSIsIl9yZXNldFN0YXRlVGltZW91dCIsIl9kZXN0cm95IiwiX29uTW91c2VEb3duIiwiX3Jlc2V0U3RhdGUiLCJfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUiLCJjb250ZXh0bWVudSIsIm1vdXNldXAiLCJfb25Nb3VzZVVwIiwiX29uS2V5RG93biIsIl9ib3giLCJfZmluaXNoIiwiYm94Wm9vbUJvdW5kcyIsImRvdWJsZUNsaWNrWm9vbSIsIkRvdWJsZUNsaWNrWm9vbSIsIl9vbkRvdWJsZUNsaWNrIiwiaW5lcnRpYSIsImluZXJ0aWFEZWNlbGVyYXRpb24iLCJpbmVydGlhTWF4U3BlZWQiLCJ3b3JsZENvcHlKdW1wIiwibWF4Qm91bmRzVmlzY29zaXR5IiwiRHJhZyIsIl9vblByZURyYWdMaW1pdCIsIl9vblByZURyYWdXcmFwIiwiX3Bvc2l0aW9ucyIsIl90aW1lcyIsIl9vZmZzZXRMaW1pdCIsIl92aXNjb3NpdHkiLCJfbGFzdFRpbWUiLCJfbGFzdFBvcyIsIl9hYnNQb3MiLCJfcHJ1bmVQb3NpdGlvbnMiLCJzaGlmdCIsInB4Q2VudGVyIiwicHhXb3JsZENlbnRlciIsIl9pbml0aWFsV29ybGRPZmZzZXQiLCJfd29ybGRXaWR0aCIsIl92aXNjb3VzTGltaXQiLCJ0aHJlc2hvbGQiLCJsaW1pdCIsIndvcmxkV2lkdGgiLCJoYWxmV2lkdGgiLCJuZXdYMSIsIm5ld1gyIiwibmV3WCIsImVhc2UiLCJzcGVlZFZlY3RvciIsImxpbWl0ZWRTcGVlZCIsImxpbWl0ZWRTcGVlZFZlY3RvciIsImRlY2VsZXJhdGlvbkR1cmF0aW9uIiwia2V5Ym9hcmRQYW5EZWx0YSIsIktleWJvYXJkIiwia2V5Q29kZXMiLCJkb3duIiwidXAiLCJfc2V0UGFuRGVsdGEiLCJfc2V0Wm9vbURlbHRhIiwiX29uRm9jdXMiLCJibHVyIiwiX29uQmx1ciIsIm1vdXNlZG93biIsIl9hZGRIb29rcyIsIl9yZW1vdmVIb29rcyIsIl9mb2N1c2VkIiwiZG9jRWwiLCJzY3JvbGxUbyIsInBhbkRlbHRhIiwia2V5cyIsIl9wYW5LZXlzIiwiY29kZXMiLCJfem9vbUtleXMiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsIm5ld0xhdExuZyIsInNjcm9sbFdoZWVsWm9vbSIsIndoZWVsRGVib3VuY2VUaW1lIiwid2hlZWxQeFBlclpvb21MZXZlbCIsIlNjcm9sbFdoZWVsWm9vbSIsIl9vbldoZWVsU2Nyb2xsIiwiX2RlbHRhIiwiZGVib3VuY2UiLCJfbGFzdE1vdXNlUG9zIiwiX3RpbWVyIiwiX3BlcmZvcm1ab29tIiwiZDIiLCJkMyIsImQ0IiwidGFwSG9sZERlbGF5IiwidGFwSG9sZCIsInRhcFRvbGVyYW5jZSIsIlRhcEhvbGQiLCJfaG9sZFRpbWVvdXQiLCJfY2FuY2VsIiwiX2lzVGFwVmFsaWQiLCJfY2FuY2VsQ2xpY2tQcmV2ZW50IiwiX3NpbXVsYXRlRXZlbnQiLCJjYW5jZWxDbGlja1ByZXZlbnQiLCJzaW11bGF0ZWRFdmVudCIsIk1vdXNlRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInZpZXciLCJkaXNwYXRjaEV2ZW50IiwidG91Y2hab29tIiwiYm91bmNlQXRab29tTGltaXRzIiwiVG91Y2hab29tIiwiX29uVG91Y2hTdGFydCIsIl96b29taW5nIiwiX2NlbnRlclBvaW50IiwiX3N0YXJ0TGF0TG5nIiwiX3BpbmNoU3RhcnRMYXRMbmciLCJfc3RhcnREaXN0IiwiX3N0YXJ0Wm9vbSIsIl9vblRvdWNoTW92ZSIsIl9vblRvdWNoRW5kIiwiX2FuaW1SZXF1ZXN0IiwibW92ZUZuIiwiUHJvamVjdGlvbiIsImxhdExuZyIsIm9sZEwiLCJub0NvbmZsaWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/leaflet/dist/leaflet-src.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/leaflet/dist/leaflet.css":
/*!***********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"ec929f1100c6\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29ycG9yYXRlLXRyYXZlbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvbGVhZmxldC5jc3M/YjJiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImVjOTI5ZjExMDBjNlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/leaflet/dist/leaflet.css\n");

/***/ })

};
;